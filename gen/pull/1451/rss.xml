<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-22T07:40:14.569093</updated>
  <id>4ebf296c-b72e-49d7-b834-7b176bb333ea</id>

  
    <entry>
      <title>abs -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/abs.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/abs.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/abs.md b/reference/cmath/abs.md
index 8ae5febb3..faf0f2b9a 100644
--- a/reference/cmath/abs.md
+++ b/reference/cmath/abs.md
@@ -51,7 +51,7 @@ namespace std {
 ## 備考
 - $$ f(x) = | x | $$
 - 任意の整数型に対するオーバーロード(5)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(6),(7),(8)が追加された
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>acos -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/acos.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/acos.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/acos.md b/reference/cmath/acos.md
index ec8954c95..ec36db7eb 100644
--- a/reference/cmath/acos.md
+++ b/reference/cmath/acos.md
@@ -59,7 +59,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = 1` の場合、戻り値は `+0` となる。
     - `x &amp;gt; |1|` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>acosh -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/acosh.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/acosh.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/acosh.md b/reference/cmath/acosh.md
index 37351dd1a..24648e456 100644
--- a/reference/cmath/acosh.md
+++ b/reference/cmath/acosh.md
@@ -59,7 +59,7 @@ namespace std {
     - `x = 1` の場合、戻り値は `+0` となる。
     - `x &amp;lt; 1` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>asin -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/asin.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/asin.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/asin.md b/reference/cmath/asin.md
index aed3a97b7..bd4645e54 100644
--- a/reference/cmath/asin.md
+++ b/reference/cmath/asin.md
@@ -59,7 +59,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
     - `x &amp;gt; |1|` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>asinh -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/asinh.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/asinh.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/asinh.md b/reference/cmath/asinh.md
index 744ff3e8f..086f25b22 100644
--- a/reference/cmath/asinh.md
+++ b/reference/cmath/asinh.md
@@ -55,7 +55,7 @@ namespace std {
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
     - `x = ±0` の場合、戻り値は `±0` となる。
     - `x = ±∞` の場合、戻り値は `±∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atan -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/atan.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/atan.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/atan.md b/reference/cmath/atan.md
index 2fa1667e7..06612bb69 100644
--- a/reference/cmath/atan.md
+++ b/reference/cmath/atan.md
@@ -46,7 +46,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
     - `x = ±∞` の場合、戻り値は `±π/2` となる。（複号同順）
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atan2 -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/atan2.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/atan2.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/atan2.md b/reference/cmath/atan2.md
index 2cb6bf45b..51087c783 100644
--- a/reference/cmath/atan2.md
+++ b/reference/cmath/atan2.md
@@ -81,7 +81,7 @@ namespace std {
     - `y = ±∞` で `x = +∞` の場合、戻り値は `±π/4` となる。
 
     特に、`y` と `x` の両方がゼロの場合に定義域エラー（[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外））となったり、`y` が非ゼロで `x` がゼロの場合に極エラー（[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外））となったりは**しない**事に注意。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atanh -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/atanh.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/atanh.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/atanh.md b/reference/cmath/atanh.md
index 0233b76ca..76787833a 100644
--- a/reference/cmath/atanh.md
+++ b/reference/cmath/atanh.md
@@ -59,7 +59,7 @@ namespace std {
     - `x = ±0` の場合、戻り値は `±0` となる。
     - `x = ±1` の場合、戻り値は `±∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
     - `|x| &amp;gt; 1` の場合、戻り値は NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cbrt -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cbrt.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/cbrt.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cbrt.md b/reference/cmath/cbrt.md
index 07cb2f3f4..9db2a6277 100644
--- a/reference/cmath/cbrt.md
+++ b/reference/cmath/cbrt.md
@@ -55,7 +55,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
     - `x = ±0` の場合、戻り値は `±0` となる。
     - `x = ±∞` の場合、戻り値は `±∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ceil -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ceil.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/ceil.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ceil.md b/reference/cmath/ceil.md
index eaf8388e5..8fba8b842 100644
--- a/reference/cmath/ceil.md
+++ b/reference/cmath/ceil.md
@@ -56,7 +56,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_UPWARD`](/reference/cfenv/fe_upward.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copysign -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/copysign.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/copysign.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/copysign.md b/reference/cmath/copysign.md
index 378d7a66a..b4679ea14 100644
--- a/reference/cmath/copysign.md
+++ b/reference/cmath/copysign.md
@@ -64,7 +64,7 @@ namespace std {
 
 ## 備考
 - 符号付きゼロを表現するが負のゼロを取り扱わない実装では、この関数はゼロを正と見なす。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cos -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cos.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/cos.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cos.md b/reference/cmath/cos.md
index c86438c44..8a1f3543d 100644
--- a/reference/cmath/cos.md
+++ b/reference/cmath/cos.md
@@ -54,7 +54,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `1` となる。
     - `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cosh -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cosh.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/cosh.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cosh.md b/reference/cmath/cosh.md
index ebc6b8c31..bc9d9eafa 100644
--- a/reference/cmath/cosh.md
+++ b/reference/cmath/cosh.md
@@ -57,7 +57,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `1` となる。
     - `x = ±∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erf -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/erf.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/erf.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/erf.md b/reference/cmath/erf.md
index 32fdcefea..ee557797f 100644
--- a/reference/cmath/erf.md
+++ b/reference/cmath/erf.md
@@ -56,7 +56,7 @@ namespace std {
     - `x = ±0` の場合、戻り値は `±0` となる。
     - `x = ±∞` の場合、戻り値は `±1` となる。
 - 平均μ, 標準偏差σの正規分布の累積分布関数は $$\frac{1}{2} \left( 1 + \mathrm{erf} ~ \frac{x - \mu}{\sqrt{2} \sigma} \right)$$ で与えられる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erfc -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/erfc.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/erfc.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/erfc.md b/reference/cmath/erfc.md
index fb6191431..268d3b7ec 100644
--- a/reference/cmath/erfc.md
+++ b/reference/cmath/erfc.md
@@ -56,7 +56,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = -∞` の場合、戻り値は `2` となる。
     - `x = +∞` の場合、戻り値は `+0` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exp -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/exp.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/exp.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/exp.md b/reference/cmath/exp.md
index a2d16e2b9..fc84b3496 100644
--- a/reference/cmath/exp.md
+++ b/reference/cmath/exp.md
@@ -58,7 +58,7 @@ namespace std {
     - `x = ±0` の場合、戻り値は `1` となる。
     - `x = -∞` の場合、戻り値は `+0` となる。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exp2 -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/exp2.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/exp2.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/exp2.md b/reference/cmath/exp2.md
index cf5fef37f..dc5b55ed4 100644
--- a/reference/cmath/exp2.md
+++ b/reference/cmath/exp2.md
@@ -59,7 +59,7 @@ namespace std {
     - `x = ±0` の場合、戻り値は `1` となる。
     - `x = -∞` の場合、戻り値は `+0` となる。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fabs -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fabs.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/fabs.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fabs.md b/reference/cmath/fabs.md
index dbdc987de..62bbf60f1 100644
--- a/reference/cmath/fabs.md
+++ b/reference/cmath/fabs.md
@@ -55,7 +55,7 @@ namespace std {
 - `value = ±0` の場合、戻り値は `+0` となる。
 - `value = ±∞` の場合、戻り値は `+∞` となる。
 - 戻り値は正確で、現在の丸め方式には依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fdim -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fdim.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/fdim.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fdim.md b/reference/cmath/fdim.md
index 00b146ce4..4c843e797 100644
--- a/reference/cmath/fdim.md
+++ b/reference/cmath/fdim.md
@@ -55,7 +55,7 @@ namespace std {
 
 
 ## 備考
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>floor -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/floor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/floor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/floor.md b/reference/cmath/floor.md
index b3bb3b5b9..1d732e2dc 100644
--- a/reference/cmath/floor.md
+++ b/reference/cmath/floor.md
@@ -56,7 +56,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_DOWNWARD`](/reference/cfenv/fe_downward.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fma -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fma.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/fma.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fma.md b/reference/cmath/fma.md
index 7e633925f..39f924d8d 100644
--- a/reference/cmath/fma.md
+++ b/reference/cmath/fma.md
@@ -90,7 +90,7 @@ namespace std {
 
 - 本関数が単純に `x * y + z` を計算するのと等価か、より速い場合には、引数の型に応じて [`FP_FAST_FMA`](fp_fast_fma.md)（`double` の場合）、[`FP_FAST_FMAF`](fp_fast_fmaf.md)（`float` の場合）、[`FP_FAST_FMAL`](fp_fast_fmal.md)（`long double` の場合）と言ったマクロが定義される。  
 	これらのマクロは、一般的に本関数がハードウェアによる積和演算命令を使用している場合にのみ定義される。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmax -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmax.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/fmax.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmax.md b/reference/cmath/fmax.md
index 5acd81805..efb7214c5 100644
--- a/reference/cmath/fmax.md
+++ b/reference/cmath/fmax.md
@@ -58,7 +58,7 @@ namespace std {
     - 引数の1つが NaN の場合 NaN でない方を返す。
     - 引数が2つとも NaN の場合 NaN を返す。
 - 理想的には `fmax(-0.0, +0.0)` は `+0` を返す。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmin -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmin.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/fmin.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmin.md b/reference/cmath/fmin.md
index 11bc5ae4e..9798f518a 100644
--- a/reference/cmath/fmin.md
+++ b/reference/cmath/fmin.md
@@ -59,7 +59,7 @@ namespace std {
     - 引数の1つが NaN の場合 NaN でない方を返す。
     - 引数が2つとも NaN の場合 NaN を返す。
 - 理想的には `fmin(-0.0, +0.0)` は `-0` を返す。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fpclassify -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fpclassify.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/fpclassify.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fpclassify.md b/reference/cmath/fpclassify.md
index 16242d32d..222ecf4ad 100644
--- a/reference/cmath/fpclassify.md
+++ b/reference/cmath/fpclassify.md
@@ -48,7 +48,7 @@ namespace std {
 
 ## 備考
 - C標準ライブラリでは`fpclassify`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>frexp -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/frexp.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/frexp.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/frexp.md b/reference/cmath/frexp.md
index 27e351ad4..679e0826b 100644
--- a/reference/cmath/frexp.md
+++ b/reference/cmath/frexp.md
@@ -61,7 +61,7 @@ C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std:
 - `value = ±∞` の場合、戻り値は `±∞` となり、`*exp` には未規定の値が設定される。
 - `value` が NaN の場合、戻り値は NaN となり、`*exp` には未規定の値が設定される。
 - この関数は浮動小数点例外を発生させない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hypot -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/hypot.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/hypot.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/hypot.md b/reference/cmath/hypot.md
index 9bd9dd244..70b9e8c11 100644
--- a/reference/cmath/hypot.md
+++ b/reference/cmath/hypot.md
@@ -127,7 +127,7 @@ $$ f(x, y) = \sqrt{x^2 + y^2} $$
     - `hypot(x, y)` と `hypot(y, x)` と `hypot(x, -y)` は等価である。
     - `hypot(x, ±0)` は、[`fabs`](fabs.md)`(x)` と等価である。
     - `hypot(±∞, y)` の戻り値は、たとえ `y` が NaN の場合でも `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合、(8)、(9)、(10)が(11)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合、(8), (9), (10)が(11)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ilogb -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ilogb.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/ilogb.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ilogb.md b/reference/cmath/ilogb.md
index af2c447da..7abababfd 100644
--- a/reference/cmath/ilogb.md
+++ b/reference/cmath/ilogb.md
@@ -55,7 +55,7 @@ namespace std {
 	- 正しい結果が戻り値の型（`int`）の範囲で表現可能な場合は、戻り値は正確で、現在の丸め方式に依存しない。
 	- 正しい結果が戻り値の型（`int`）の範囲外の場合は、戻り値は未規定で、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
 	- `x` がゼロ、無限大、あるいは NaN の場合には、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isfinite -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isfinite.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isfinite.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isfinite.md b/reference/cmath/isfinite.md
index 30ca0708c..39e1ebaed 100644
--- a/reference/cmath/isfinite.md
+++ b/reference/cmath/isfinite.md
@@ -37,7 +37,7 @@ namespace std {
 
 ## 備考
 - C標準ライブラリでは`isfinite`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isgreater -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isgreater.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isgreater.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isgreater.md b/reference/cmath/isgreater.md
index 9f325007c..4a3f4798f 100644
--- a/reference/cmath/isgreater.md
+++ b/reference/cmath/isgreater.md
@@ -41,7 +41,7 @@ namespace std {
 ## 備考
 - C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
 - C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isgreaterequal -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isgreaterequal.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isgreaterequal.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isgreaterequal.md b/reference/cmath/isgreaterequal.md
index 81362665c..59bbdd814 100644
--- a/reference/cmath/isgreaterequal.md
+++ b/reference/cmath/isgreaterequal.md
@@ -41,7 +41,7 @@ namespace std {
 ## 備考
 - C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
 - C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isinf -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isinf.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isinf.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isinf.md b/reference/cmath/isinf.md
index f962c92ec..54bdfbe17 100644
--- a/reference/cmath/isinf.md
+++ b/reference/cmath/isinf.md
@@ -37,7 +37,7 @@ namespace std {
 
 ## 備考
 - C標準ライブラリでは`isinf`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isless -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isless.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isless.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isless.md b/reference/cmath/isless.md
index 78fc46a87..78bed4d0c 100644
--- a/reference/cmath/isless.md
+++ b/reference/cmath/isless.md
@@ -41,7 +41,7 @@ namespace std {
 ## 備考
 - C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
 - C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>islessequal -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/islessequal.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/islessequal.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/islessequal.md b/reference/cmath/islessequal.md
index 44a39cfe6..d4ab66480 100644
--- a/reference/cmath/islessequal.md
+++ b/reference/cmath/islessequal.md
@@ -41,7 +41,7 @@ namespace std {
 ## 備考
 - C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
 - C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>islessgreater -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/islessgreater.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/islessgreater.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/islessgreater.md b/reference/cmath/islessgreater.md
index 60cb3e87a..d10f1947b 100644
--- a/reference/cmath/islessgreater.md
+++ b/reference/cmath/islessgreater.md
@@ -41,7 +41,7 @@ namespace std {
 ## 備考
 - C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
 - C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isnan -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isnan.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isnan.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isnan.md b/reference/cmath/isnan.md
index 440e2a07c..0052da26d 100644
--- a/reference/cmath/isnan.md
+++ b/reference/cmath/isnan.md
@@ -37,7 +37,7 @@ namespace std {
 
 ## 備考
 - C標準ライブラリでは`isnan`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isnormal -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isnormal.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isnormal.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isnormal.md b/reference/cmath/isnormal.md
index 6aeaa4183..051ac7fc4 100644
--- a/reference/cmath/isnormal.md
+++ b/reference/cmath/isnormal.md
@@ -37,7 +37,7 @@ namespace std {
 
 ## 備考
 - C標準ライブラリでは`isnormal`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isunordered -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isunordered.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/isunordered.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isunordered.md b/reference/cmath/isunordered.md
index 7adb78141..f1013c2bd 100644
--- a/reference/cmath/isunordered.md
+++ b/reference/cmath/isunordered.md
@@ -41,7 +41,7 @@ NaNに対する順序付けはされないため、`x`と`y`のいずれかがNa
 ## 備考
 - C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
 - C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ldexp -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ldexp.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/ldexp.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ldexp.md b/reference/cmath/ldexp.md
index 00ca44339..ee18fec2c 100644
--- a/reference/cmath/ldexp.md
+++ b/reference/cmath/ldexp.md
@@ -55,7 +55,7 @@ namespace std {
 ## 備考
 - オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、かつ、基数が 2 の場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`radix`](../limits/numeric_limits/radix.md)`() == 2`）、[`scalbn`](scalbn.md)`(x, exp)` と等価である。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lgamma -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lgamma.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/lgamma.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lgamma.md b/reference/cmath/lgamma.md
index 03027e27d..f0cec5c2f 100644
--- a/reference/cmath/lgamma.md
+++ b/reference/cmath/lgamma.md
@@ -59,7 +59,7 @@ namespace std {
     [`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
     - `x = -∞` の場合、戻り値は `+∞` となる。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 - この関数はガンマ関数 ([`tgamma`](tgamma.md)) がオーバーフローするような場合に使う。
   具体例については[ガンマ関数の備考](tgamma.md#remarks-lgamma)を参照のこと。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>llrint -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/llrint.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/llrint.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/llrint.md b/reference/cmath/llrint.md
index aa478ca9b..141355dfc 100644
--- a/reference/cmath/llrint.md
+++ b/reference/cmath/llrint.md
@@ -46,7 +46,7 @@ namespace std {
     なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は四捨五入ではなく、最近接偶数への丸めであることに注意。（例を参照）  
     四捨五入が必要であれば、[`llround`](llround.md) を使用すること。（ただし、[`llround`](llround.md) は本関数と異なり、ISO IEC 60559 に準拠していても [`FE_INEXACT`](../cfenv/fe_inexact.md) が発生するか否かは処理系定義である）  
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>llround -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/llround.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/llround.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/llround.md b/reference/cmath/llround.md
index 57a106b16..fba7a7fe8 100644
--- a/reference/cmath/llround.md
+++ b/reference/cmath/llround.md
@@ -54,7 +54,7 @@ namespace std {
 - [`round`](round.md)関数と違い、本関数において戻り値が非整数型引数 `x` と異なる場合に、例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) を発生させる必要はない。
 - 戻り値が[`long long`型](/lang/cpp11/long_long_type.md)の範囲を超えた場合、定義域エラーが起こる可能性がある。その際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - なお、本関数の挙動は、現在の丸めモードには依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/log.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log.md b/reference/cmath/log.md
index 9faf89171..6e21aa624 100644
--- a/reference/cmath/log.md
+++ b/reference/cmath/log.md
@@ -59,7 +59,7 @@ namespace std {
     - `x = 1` の場合、戻り値は `+0` となる。
     - `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log10 -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log10.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/log10.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log10.md b/reference/cmath/log10.md
index 7ecd19f59..af742ee0b 100644
--- a/reference/cmath/log10.md
+++ b/reference/cmath/log10.md
@@ -59,7 +59,7 @@ namespace std {
     - `x = 1` の場合、戻り値は `+0` となる。
     - `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log1p -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log1p.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/log1p.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log1p.md b/reference/cmath/log1p.md
index f8cd0da40..360293555 100644
--- a/reference/cmath/log1p.md
+++ b/reference/cmath/log1p.md
@@ -62,7 +62,7 @@ namespace std {
     - `x = -1` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
     - `x &amp;lt; -1` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log2 -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log2.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/log2.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log2.md b/reference/cmath/log2.md
index 3995ae461..ff0566f41 100644
--- a/reference/cmath/log2.md
+++ b/reference/cmath/log2.md
@@ -60,7 +60,7 @@ namespace std {
     - `x = 1` の場合、戻り値は `+0` となる。
     - `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
     - `x = +∞` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>logb -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/logb.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/logb.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/logb.md b/reference/cmath/logb.md
index c0c2f54ea..5a704abad 100644
--- a/reference/cmath/logb.md
+++ b/reference/cmath/logb.md
@@ -57,7 +57,7 @@ namespace std {
 	- `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
 	- `x = ±∞` の場合、戻り値は `+∞` となる。
 	- 戻り値は正確で、現在の丸め方式に依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lrint -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lrint.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/lrint.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lrint.md b/reference/cmath/lrint.md
index 387b950a3..ffa8687f7 100644
--- a/reference/cmath/lrint.md
+++ b/reference/cmath/lrint.md
@@ -45,7 +45,7 @@ namespace std {
     なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は単なる四捨五入ではないことに注意。  
     四捨五入が必要であれば、[`lround`](lround.md) を使用すること。（ただし、[`lround`](lround.md) は本関数と異なり、ISO IEC 60559 に準拠していても [`FE_INEXACT`](../cfenv/fe_inexact.md) が発生するか否かは処理系定義である）  
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lround -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lround.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/lround.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lround.md b/reference/cmath/lround.md
index d3bc0e7db..4be8c303a 100644
--- a/reference/cmath/lround.md
+++ b/reference/cmath/lround.md
@@ -54,7 +54,7 @@ namespace std {
 - [`round`](round.md)関数と違い、本関数において戻り値が非整数型引数 `x` と異なる場合に、例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) を発生させる必要はない。
 - 戻り値が`long`型の範囲を超えた場合、定義域エラーが起こる可能性がある。その際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - なお、本関数の挙動は、現在の丸めモードには依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>modf -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/modf.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/modf.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/modf.md b/reference/cmath/modf.md
index b0f620b46..3a271bac6 100644
--- a/reference/cmath/modf.md
+++ b/reference/cmath/modf.md
@@ -63,7 +63,7 @@ namespace std {
 
 - C++11 で `value` が整数型のオーバーロードが追加されているが、`iptr` の型によって呼び出されるオーバーロードが一意に決まるため、存在意義は無いものと思われる。  
     （`value` に整数型、`iptr` に `nullptr` を渡した場合のみ当該オーバーロードによって呼び出しが曖昧ではなくなるが、その場合は未定義動作となってしまうため、本オーバーロードの存在はむしろ有害）
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nearbyint -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nearbyint.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/nearbyint.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nearbyint.md b/reference/cmath/nearbyint.md
index 339a58b2c..ccb56c833 100644
--- a/reference/cmath/nearbyint.md
+++ b/reference/cmath/nearbyint.md
@@ -46,7 +46,7 @@ namespace std {
 - C99 では、丸めモードの設定時には `#pragma STDC FENV_ACCESS ON` でなければなければならないと記載されているが、C++ には該当する記載を見つけることができなかった。  
     なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は単なる四捨五入ではないことに注意。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nextafter -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nextafter.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/nextafter.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nextafter.md b/reference/cmath/nextafter.md
index f66bdfebb..8a5647008 100644
--- a/reference/cmath/nextafter.md
+++ b/reference/cmath/nextafter.md
@@ -69,7 +69,7 @@ namespace std {
 
 
 ## 備考
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nexttoward -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nexttoward.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/nexttoward.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nexttoward.md b/reference/cmath/nexttoward.md
index 5d285c4fe..f1568f7a1 100644
--- a/reference/cmath/nexttoward.md
+++ b/reference/cmath/nexttoward.md
@@ -70,7 +70,7 @@ namespace std {
 
 
 ## 備考
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pow -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/pow.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/pow.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/pow.md b/reference/cmath/pow.md
index 8b27ff64a..5878da2f8 100644
--- a/reference/cmath/pow.md
+++ b/reference/cmath/pow.md
@@ -102,7 +102,7 @@ namespace std {
     - `x = -∞` で `y` が正でかつ奇数ではない場合、戻り値は `+∞` となる。
     - `x = +∞` で `y &amp;lt; 0` の場合、戻り値は `+0` となる。
     - `x = +∞` で `y &amp;gt; 0` の場合、戻り値は `+∞` となる。
-- C++23では、(1)、(2)、(3)が(7)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(7)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remainder -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remainder.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/remainder.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remainder.md b/reference/cmath/remainder.md
index d0e32ab57..4d4a6e1c4 100644
--- a/reference/cmath/remainder.md
+++ b/reference/cmath/remainder.md
@@ -59,7 +59,7 @@ IEC 60559で要求された`x REM y`を計算して返す。
 - 本関数は、C99 の規格にある `remainder`（より正確には `math.h` ヘッダの `remainder`、`remainderf`、`remainderl` の 3 つ。それぞれ C++ の `double`、`float`、`long double` バージョンに相当）と等価である。
 - IEC 60559で要求された`x REM y`の計算とは以下のようなものであり、全ての実装に適用できる。
     - 「y≠0である場合、剰余r = x REM yは、丸めモードに関係なく数学的な関係r = x - nyによって定義される。ここで、nはx/yの正確な値に最も近い整数である。| n - x/y | = 1/2ならば、nは常に偶数である。したがって、剰余は常に正確である。r = 0の場合、その符号はxの符号とする」
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remquo -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remquo.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/remquo.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remquo.md b/reference/cmath/remquo.md
index 4696daaf5..40c30b2ec 100644
--- a/reference/cmath/remquo.md
+++ b/reference/cmath/remquo.md
@@ -80,7 +80,7 @@ namespace std {
 `remquo`関数では`x/y`の厳密な商を求めることはできない。
 三角関数のような周期性をもつ数学関数の内部実装において、商の低次ビットを利用した引数の還元(argument reduction)操作で利用する。
 
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rint -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/rint.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/rint.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/rint.md b/reference/cmath/rint.md
index c656b58ff..4dcdeeafa 100644
--- a/reference/cmath/rint.md
+++ b/reference/cmath/rint.md
@@ -47,7 +47,7 @@ namespace std {
 - C99 では、丸めモードの設定時には `#pragma STDC FENV_ACCESS ON` でなければなければならないと記載されているが、C++ には該当する記載を見つけることができなかった。  
     なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は単なる四捨五入ではないことに注意。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>round -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/round.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/round.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/round.md b/reference/cmath/round.md
index a685b14ea..c88d88beb 100644
--- a/reference/cmath/round.md
+++ b/reference/cmath/round.md
@@ -85,7 +85,7 @@ namespace std {
 
 	ただし、本関数において戻り値が引数 `x` と異なる場合に、上記の実装のように例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scalbln -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/scalbln.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/scalbln.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/scalbln.md b/reference/cmath/scalbln.md
index 3fee1c1b0..ad0fafd0b 100644
--- a/reference/cmath/scalbln.md
+++ b/reference/cmath/scalbln.md
@@ -63,7 +63,7 @@ namespace std {
 	- もしオーバーフローエラーやアンダーフローエラーを起こさなければ、結果は正確で現在の丸め方式には依存しない。
 
 - `scalbln()` 関数は、パラメータ `n` の型が `long int` であることを除いて、`scalbn()` 関数と等価である。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scalbn -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/scalbn.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/scalbn.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/scalbn.md b/reference/cmath/scalbn.md
index f30f9fdb1..0e0cc2315 100644
--- a/reference/cmath/scalbn.md
+++ b/reference/cmath/scalbn.md
@@ -71,7 +71,7 @@ namespace std {
 	- もしオーバーフローエラーやアンダーフローエラーを起こさなければ、結果は正確で現在の丸め方式には依存しない。
 
 - `scalbln()` 関数は、パラメータ `n` の型が `long int` であることを除いて、`scalbn()` 関数と等価である。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>signbit -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/signbit.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/signbit.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/signbit.md b/reference/cmath/signbit.md
index 70b744e3d..9689541ea 100644
--- a/reference/cmath/signbit.md
+++ b/reference/cmath/signbit.md
@@ -40,7 +40,7 @@ namespace std {
 
 ## 備考
 - C標準ライブラリでは`signbit`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sin -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sin.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/sin.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sin.md b/reference/cmath/sin.md
index 60450378a..1978c2964 100644
--- a/reference/cmath/sin.md
+++ b/reference/cmath/sin.md
@@ -54,7 +54,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
     - `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sinh -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sinh.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/sinh.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sinh.md b/reference/cmath/sinh.md
index 6e8594c3f..5f0e4441b 100644
--- a/reference/cmath/sinh.md
+++ b/reference/cmath/sinh.md
@@ -57,7 +57,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
     - `x = ±0` の場合、戻り値は `±0` となる。
     - `x = ±∞` の場合、戻り値は `±∞` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sqrt -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sqrt.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/sqrt.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sqrt.md b/reference/cmath/sqrt.md
index f837ec613..be41bd8c0 100644
--- a/reference/cmath/sqrt.md
+++ b/reference/cmath/sqrt.md
@@ -58,7 +58,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
     - `x = ±0` の場合、戻り値は `±0` となる。
 - `-0.0`は`0.0`と等しいため、定義域エラーにはならず、`-0.0`が返る
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tan -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tan.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/tan.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tan.md b/reference/cmath/tan.md
index 2eecf915b..eb4ab0fe4 100644
--- a/reference/cmath/tan.md
+++ b/reference/cmath/tan.md
@@ -54,7 +54,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
     - `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tanh -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tanh.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/tanh.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tanh.md b/reference/cmath/tanh.md
index bfae3387e..b4580f294 100644
--- a/reference/cmath/tanh.md
+++ b/reference/cmath/tanh.md
@@ -54,7 +54,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
     - `x = ±0` の場合、戻り値は `±0` となる。
     - `x = ±∞` の場合、戻り値は `±1` となる。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tgamma -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tgamma.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/tgamma.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tgamma.md b/reference/cmath/tgamma.md
index 615ff7717..ae4b949ec 100644
--- a/reference/cmath/tgamma.md
+++ b/reference/cmath/tgamma.md
@@ -62,7 +62,7 @@ $$ \Gamma (x) = \int_0^\infty t^{x-1} e^{-t} dt $$
     [`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
     - `x = +∞` の場合、戻り値は `+∞` となる。
 - `gamma` という関数は既にあったが処理系によって定義が違ったため、本当の (true) ガンマ関数 `tgamma` と名付けられた。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 ### &amp;lt;a id=&amp;#34;remarks-lgamma&amp;#34; href=&amp;#34;#remarks-lgamma&amp;#34;&amp;gt;lgamma との使い分け&amp;lt;/a&amp;gt;
 ガンマ関数は急激に増加し容易にオーバーフローするので、代わりにガンマ関数の結果を自然対数で返す関数 [`lgamma`](lgamma.md) を用いた方が良いことが多くある。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>trunc -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cmath/trunc.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cmath/trunc.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/trunc.md b/reference/cmath/trunc.md
index d81a623db..7b9b27c17 100644
--- a/reference/cmath/trunc.md
+++ b/reference/cmath/trunc.md
@@ -58,7 +58,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_TOWARDZERO`](/reference/cfenv/fe_towardzero.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
-- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(1), (2), (3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/cstdlib/abs.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/cstdlib/abs.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdlib/abs.md b/reference/cstdlib/abs.md
index ad61f0b6a..d8dd259e0 100644
--- a/reference/cstdlib/abs.md
+++ b/reference/cstdlib/abs.md
@@ -65,7 +65,7 @@ namespace std {
 ## 備考
 - パラメータの型`X`において[`is_unsigned_v`](/reference/type_traits/is_unsigned.md)`&amp;lt;X&amp;gt;`が`true`であり、`X`が整数昇格によって`int`に変換できない場合、プログラムは不適格となる
     - Cとの互換性のため、`int`に昇格できる符号なし整数型は許可される
-- C++23では、(4)、(5)、(6)が(7)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+- C++23では、(4), (5), (6)が(7)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_or_assign -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert_or_assign.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/flat_map/flat_map/insert_or_assign.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert_or_assign.md b/reference/flat_map/flat_map/insert_or_assign.md
index 0a0328719..95f532422 100644
--- a/reference/flat_map/flat_map/insert_or_assign.md
+++ b/reference/flat_map/flat_map/insert_or_assign.md
@@ -93,17 +93,17 @@ iterator
 
 
 ## 戻り値
-- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1), (2), (3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 代入された場合には、`first` に代入された要素へのイテレータ、`second` に `false` が設定される。
-- (4)、(5)、(6) :
+- (4), (5), (6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 代入された場合には、代入された要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2)、(3) : [`emplace`](emplace.md) と同じ
-- (4)、(5)、(6) : [`emplace_hint`](emplace_hint.md) と同じ
+- (1), (2), (3) : [`emplace`](emplace.md) と同じ
+- (4), (5), (6) : [`emplace_hint`](emplace_hint.md) と同じ
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ios/ios_base/failure/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ios/ios_base/failure/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ios/ios_base/failure/op_constructor.md b/reference/ios/ios_base/failure/op_constructor.md
index 1b068c360..e2841223a 100644
--- a/reference/ios/ios_base/failure/op_constructor.md
+++ b/reference/ios/ios_base/failure/op_constructor.md
@@ -20,7 +20,7 @@ explicit failure(const char* msg, const error_code&amp;amp; ec = io_errc::stream);
 
 ## 効果
 - (1) [`strcmp`](../../../cstring/strcmp.md.nolink)`(`[`what`](what.md)`(), msg.`[`c_str`](../../../string/basic_string/c_str.md)`()) == 0` となる [`ios_base`](../../ios_base.md)`::`[`failure`](../failure.md) オブジェクトを構築する。
-- (2)、(3) 引数 `msg` と `ec` を用いて基底クラスを構築して、[`ios_base`](../../ios_base.md)`::`[`failure`](../failure.md) オブジェクトを構築する。
+- (2), (3) 引数 `msg` と `ec` を用いて基底クラスを構築して、[`ios_base`](../../ios_base.md)`::`[`failure`](../failure.md) オブジェクトを構築する。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_or_assign -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/map/map/insert_or_assign.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/map/map/insert_or_assign.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/insert_or_assign.md b/reference/map/map/insert_or_assign.md
index f6c5c07df..a9e0b2b62 100644
--- a/reference/map/map/insert_or_assign.md
+++ b/reference/map/map/insert_or_assign.md
@@ -54,29 +54,29 @@ iterator
 
 
 ## 適格要件
-- (1)、(3)、(4)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
-- (2)、(5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (1), (3), (4), (6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (2), (5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
 
 ## 効果
-- (1)、(3)、(4)、(6) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(5) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1), (3), (4), (6) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2), (5) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1), (2), (3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 代入された場合には、`first` に代入された要素へのイテレータ、`second` に `false` が設定される。
-- (4)、(5)、(6) :
+- (4), (5), (6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 代入された場合には、代入された要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2)、(3) : [`emplace`](emplace.md) と同じ。
-- (4)、(5)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1), (2), (3) : [`emplace`](emplace.md) と同じ。
+- (4), (5), (6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/map/map/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/map/map/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/op_constructor.md b/reference/map/map/op_constructor.md
index 1ff4175f9..e3f9c22a3 100644
--- a/reference/map/map/op_constructor.md
+++ b/reference/map/map/op_constructor.md
@@ -75,13 +75,13 @@ map(from_range_t, R&amp;amp;&amp;amp; rg,
 
 
 ## 計算量
-- (1)、(2)、(3) 定数時間
-- (4)、(5) `N =` [`distance`](../../iterator/distance.md)`(first, last)` とすると、範囲 `[first, last)` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
-- (6)、(7) `x.`[`size`](size.md)`()`  に対して線形時間
+- (1), (2), (3) 定数時間
+- (4), (5) `N =` [`distance`](../../iterator/distance.md)`(first, last)` とすると、範囲 `[first, last)` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (6), (7) `x.`[`size`](size.md)`()`  に対して線形時間
 - (8) 定数時間
 - (9) 定数時間。但し、`alloc == y.`[`get_allocator`](get_allocator.md)`()` でなければ `y.`[`size`](size.md)`()` に対して線形時間
-- (10)、(11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
-- (12)、(13) `N =` [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` とすると、`rg` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (10), (11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (12), (13) `N =` [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` とすると、`rg` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
 
 
 ## 備考
@@ -166,5 +166,5 @@ Size of c2: 2
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
     (1) + (2) を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (5)、(11) を追加するきっかけとなったレポート  
+    (5), (11) を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_emplace -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/map/map/try_emplace.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/map/map/try_emplace.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/try_emplace.md b/reference/map/map/try_emplace.md
index c6b4b178b..0659acc06 100644
--- a/reference/map/map/try_emplace.md
+++ b/reference/map/map/try_emplace.md
@@ -55,9 +55,9 @@ iterator
 
 
 ## テンプレートパラメータ制約
-- (1)、(3)、(5)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
-- (2)、(4) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
-- (5)、(6) :
+- (1), (3), (5), (6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
+- (2), (4) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
+- (5), (6) :
     - `key_compare::is_transparent` が妥当な式であること
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
@@ -66,22 +66,22 @@ iterator
 
 
 ## 効果
-- (1)、(3)、(5)、(6) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1), (3), (5), (6) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2), (4) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2)、(5) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1), (2), (5) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 挿入されなかった場合には、`first` に `k` と等価のキーを持つ既存の要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4)、(6) :
+- (3), (4), (6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 挿入されなかった場合には、`k` と等価のキーを持つ既存の要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2)、(5) : [`emplace`](emplace.md) と同じ。
-- (3)、(4)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1), (2), (5) : [`emplace`](emplace.md) と同じ。
+- (3), (4), (6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/map/multimap/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/op_constructor.md b/reference/map/multimap/op_constructor.md
index b3d68db06..8543c63cd 100644
--- a/reference/map/multimap/op_constructor.md
+++ b/reference/map/multimap/op_constructor.md
@@ -78,13 +78,13 @@ multimap(from_range_t, R&amp;amp;&amp;amp; rg,
 
 
 ## 計算量
-- (1)、(2)、(3) 定数時間
-- (4)、(5) `N =` [`distance`](../../iterator/distance.md)`(first, last)` とすると、範囲 `[first, last)` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
-- (6)、(7) `x.`[`size`](size.md)`()` に対して線形時間
+- (1), (2), (3) 定数時間
+- (4), (5) `N =` [`distance`](../../iterator/distance.md)`(first, last)` とすると、範囲 `[first, last)` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (6), (7) `x.`[`size`](size.md)`()` に対して線形時間
 - (8) 定数時間
 - (9) 定数時間。ただし、`alloc == y.`[`get_allocator`](get_allocator.md)`()` でなければ `y.`[`size`](size.md)`()` に対して線形時間
-- (10)、(11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
-- (12)、(13) `N =` [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` とすると、`rg` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (10), (11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (12), (13) `N =` [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` とすると、`rg` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
 
 
 ## 備考
@@ -169,5 +169,5 @@ Size of m2: 3
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
     (1) + (2) の形式を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (5)、(11) の形式を追加するきっかけとなったレポート  
+    (5), (11) の形式を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform_reduce -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/numeric/transform_reduce.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/numeric/transform_reduce.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/transform_reduce.md b/reference/numeric/transform_reduce.md
index a0731dc3c..32c7cbcf7 100644
--- a/reference/numeric/transform_reduce.md
+++ b/reference/numeric/transform_reduce.md
@@ -86,7 +86,7 @@ namespace std {
 ## 概要
 `transform_reduce()`は、イテレータ範囲の要素を変換しながら集計する関数である。
 
-(1)、(2)、(4)、(5)は、イテレータ範囲`[first1, last1)`の各要素を`x`、イテレータ範囲`[first2, first2+(last1 - first1))`の各要素を`y`として、初期値(`init`)と`binary_op2(x, y)`した各要素を合算したリストの任意の組み合わせに、順不同で`binary_op1(binary_op1(a, b), binary_op1(c, d))`のように適用していき、集計値を計算する。
+(1), (2), (4), (5)は、イテレータ範囲`[first1, last1)`の各要素を`x`、イテレータ範囲`[first2, first2+(last1 - first1))`の各要素を`y`として、初期値(`init`)と`binary_op2(x, y)`した各要素を合算したリストの任意の組み合わせに、順不同で`binary_op1(binary_op1(a, b), binary_op1(c, d))`のように適用していき、集計値を計算する。
 
 (3)と(6)は、初期値(`init`)と、イテレータ範囲`[first, last)`の各要素に関数オブジェクト`unary_op`を適用して合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;&lt; (非メンバ関数) -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream_free.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ostream/basic_ostream/op_ostream_free.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ostream/basic_ostream/op_ostream_free.md b/reference/ostream/basic_ostream/op_ostream_free.md
index 3ea6ffb76..45e9ac08c 100644
--- a/reference/ostream/basic_ostream/op_ostream_free.md
+++ b/reference/ostream/basic_ostream/op_ostream_free.md
@@ -119,7 +119,7 @@ namespace std {
 
 ## 例
 
-### (1)、(2)、(13)、(14) の例
+### (1), (2), (13), (14) の例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;iomanip&amp;gt;
@@ -148,7 +148,7 @@ cpprefjp++
 cpprefjp++
 ```
 
-### (3)～(5)、(15)～(17) の例
+### (3)～(5), (15)～(17) の例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;iomanip&amp;gt;
@@ -227,7 +227,7 @@ int main()
 
 これは`char8_t`/`char16_t`/`char32_t`に対するostreamの`operator&amp;lt;&amp;lt;`が提供されないため、他のオーバーロードが選ばれるためにこのような直感に反する挙動が発生する。
 
-そこで(6)～(12)、(18)～(24)のように`delete`指定された`operator&amp;lt;&amp;lt;`を追加することで不適格にし、このような直感的ではない挙動を避ける。
+そこで(6)～(12), (18)～(24)のように`delete`指定された`operator&amp;lt;&amp;lt;`を追加することで不適格にし、このような直感的ではない挙動を避ける。
 
 [機能テストマクロ](/lang/cpp20/feature_test_macros.md)は`__cpp_lib_char8_t`で、値は`201907`。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>back -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/back.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/back.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/back.md b/reference/ranges/view_interface/back.md
index ab7524777..51a2d6d3b 100644
--- a/reference/ranges/view_interface/back.md
+++ b/reference/ranges/view_interface/back.md
@@ -28,7 +28,7 @@ Rangeの末尾の要素を取得する。
 `!`[`empty`](empty.md)`()`
 
 ## 戻り値
-(1)、(2)共に、以下と等価：
+(1), (2)共に、以下と等価：
 
 ```cpp
 *ranges::prev(ranges::end(derived()))
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cbegin -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/cbegin.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/cbegin.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/cbegin.md b/reference/ranges/view_interface/cbegin.md
index 39c4b302d..f00bb033a 100644
--- a/reference/ranges/view_interface/cbegin.md
+++ b/reference/ranges/view_interface/cbegin.md
@@ -20,7 +20,7 @@ Rangeの定数イテレータを取得する。
 
 ## 戻り値
 
-(1)、(2)共に、以下と等価
+(1), (2)共に、以下と等価
 
 ```cpp
 return ranges::cbegin(derived());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cend -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/cend.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/cend.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/cend.md b/reference/ranges/view_interface/cend.md
index 5c652bc21..76fd620a1 100644
--- a/reference/ranges/view_interface/cend.md
+++ b/reference/ranges/view_interface/cend.md
@@ -20,7 +20,7 @@ Rangeの定数イテレータに対応する番兵を取得する。
 
 ## 戻り値
 
-(1)、(2)共に、以下と等価
+(1), (2)共に、以下と等価
 
 ```cpp
 return ranges::cend(derived());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>data -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/data.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/data.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/data.md b/reference/ranges/view_interface/data.md
index d42c3a64f..2ad22e1b3 100644
--- a/reference/ranges/view_interface/data.md
+++ b/reference/ranges/view_interface/data.md
@@ -26,7 +26,7 @@ Rangeの要素へのポインタを取得する。
 - (2): `const D`が[`range`](../range.md)かつ`const D`のイテレータが[`contiguous_iterator`](/reference/iterator/contiguous_iterator.md)であること。
 
 ## 戻り値
-(1)、(2)共に、以下と等価：
+(1), (2)共に、以下と等価：
 
 ```cpp
 to_address(ranges::begin(derived()));
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>empty -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/empty.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/empty.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/empty.md b/reference/ranges/view_interface/empty.md
index 3ed312c3e..2cdc27261 100644
--- a/reference/ranges/view_interface/empty.md
+++ b/reference/ranges/view_interface/empty.md
@@ -25,7 +25,7 @@ Rangeが空かどうかを判定する。
 - (2): `const D`が[`sized_range`](../sized_range.md)もしくは[`forward_range`](../forward_range.md)であること。
 
 ## 戻り値
-(1)、(2)共に、以下と等価：
+(1), (2)共に、以下と等価：
 
 ```cpp
 ranges::begin(derived()) == ranges::end(derived())
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>front -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/front.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/front.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/front.md b/reference/ranges/view_interface/front.md
index d7b45e158..832ab5167 100644
--- a/reference/ranges/view_interface/front.md
+++ b/reference/ranges/view_interface/front.md
@@ -27,7 +27,7 @@ Rangeの先頭の要素を取得する。
 `!`[`empty`](empty.md)`()`
 
 ## 戻り値
-(1)、(2)共に、以下と等価：
+(1), (2)共に、以下と等価：
 
 ```cpp
 *ranges::begin(derived())
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator [] -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/op_at.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/op_at.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/op_at.md b/reference/ranges/view_interface/op_at.md
index c52ada1e1..00ef7c67c 100644
--- a/reference/ranges/view_interface/op_at.md
+++ b/reference/ranges/view_interface/op_at.md
@@ -22,7 +22,7 @@ Rangeの要素にアクセスする。
 `R`が[`random_access_range`](../random_access_range.md)であること。
 
 ## 戻り値
-(1)、(2)共に、以下と等価：
+(1), (2)共に、以下と等価：
 
 ```cpp
 ranges::begin(derived())[n];
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator bool -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/op_bool.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/op_bool.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/op_bool.md b/reference/ranges/view_interface/op_bool.md
index d02e69d76..00eb64403 100644
--- a/reference/ranges/view_interface/op_bool.md
+++ b/reference/ranges/view_interface/op_bool.md
@@ -22,7 +22,7 @@ Rangeが空かどうかを判定する。
 式[`ranges::empty`](../empty.md)`(`[`derived`](derived.md)`())`が有効であること。
 
 ## 戻り値
-(1)、(2)共に、以下と等価：
+(1), (2)共に、以下と等価：
 
 ```cpp
 !ranges::empty(derived())
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>size -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/size.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/ranges/view_interface/size.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/size.md b/reference/ranges/view_interface/size.md
index 73bbe46b1..33e356b7b 100644
--- a/reference/ranges/view_interface/size.md
+++ b/reference/ranges/view_interface/size.md
@@ -27,7 +27,7 @@ Rangeの大きさを取得する。
 - (2): `const D`が[`forward_range`](../forward_range.md)であり、`const D`のイテレータ`I`と番兵`S`が[`sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)を満たすこと。
 
 ## 戻り値
-(1)、(2)共に、以下と等価：
+(1), (2)共に、以下と等価：
 
 ```cpp
 ranges::end(derived()) - ranges::begin(derived());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/regex/match_results/op_assign.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/regex/match_results/op_assign.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/regex/match_results/op_assign.md b/reference/regex/match_results/op_assign.md
index 40465f41a..9b39f782f 100644
--- a/reference/regex/match_results/op_assign.md
+++ b/reference/regex/match_results/op_assign.md
@@ -26,7 +26,7 @@ match_results&amp;amp; operator=(match_results&amp;amp;&amp;amp; m) noexcept;   // (2)
 
 
 ## 事後条件
-- (1)、(2) 以下の表を満たす。
+- (1), (2) 以下の表を満たす。
 
     | 要素                                    | 値                                                                                            |
     |-----------------------------------------|-----------------------------------------------------------------------------------------------|
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>regex_replace -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/regex/regex_replace.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/regex/regex_replace.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/regex/regex_replace.md b/reference/regex/regex_replace.md
index 1b131f713..97adb92ac 100644
--- a/reference/regex/regex_replace.md
+++ b/reference/regex/regex_replace.md
@@ -64,18 +64,18 @@ namespace std {
 
 
 ## 効果
-- (1)、(2) `[first, last)` で指定された文字列内に出現する、正規表現 `e` にマッチする部分を、置換文字列 `fmt` で置換した結果を出力イテレータ `out` に出力する。  
+- (1), (2) `[first, last)` で指定された文字列内に出現する、正規表現 `e` にマッチする部分を、置換文字列 `fmt` で置換した結果を出力イテレータ `out` に出力する。  
     置換文字列 `fmt` には通常の文字の他、マッチした文字列全体やキャプチャグループを表すシーケンスを使用することができる。  
     指定可能なシーケンスは、デフォルトでは ECMAScript の置換文字列と等価であるが、`flags` に [`regex_constants::format_sed`](regex_constants/match_flag_type.md) が指定されていた場合には POSIX にて規定されている sed の置換文字列と等価となる。  
     なお、デフォルトでは全てのマッチする部分が `fmt` で置換されるが、`flags` に [`regex_constants::format_first_only`](regex_constants/match_flag_type.md) が指定されていた場合には最初にマッチする部分のみが置換される。  
     また、デフォルトではマッチしない部分はそのまま `out` に出力されるが、`flags` に [`regex_constants::format_no_copy`](regex_constants/match_flag_type.md) が指定されていた場合には、マッチしない部分は `out` には出力されない。
-- (3)、(4) 置換対象文字列が [`basic_string`](../string/basic_string.md)`&amp;lt;charT, ST, SA&amp;gt;` 型の文字列 `s` であること、および、置換結果が [`basic_string`](../string/basic_string.md)`&amp;lt;charT, ST, SA&amp;gt;` 型の文字列として返される点を除いて、(1)、(2) と同様である。
-- (5)、(6) 置換対象文字列が `const charT*` 型の文字列 `s` であること、および、置換結果が [`basic_string`](../string/basic_string.md)`&amp;lt;charT&amp;gt;` 型の文字列として返される点を除いて、(1)、(2) と同様である。
+- (3), (4) 置換対象文字列が [`basic_string`](../string/basic_string.md)`&amp;lt;charT, ST, SA&amp;gt;` 型の文字列 `s` であること、および、置換結果が [`basic_string`](../string/basic_string.md)`&amp;lt;charT, ST, SA&amp;gt;` 型の文字列として返される点を除いて、(1), (2) と同様である。
+- (5), (6) 置換対象文字列が `const charT*` 型の文字列 `s` であること、および、置換結果が [`basic_string`](../string/basic_string.md)`&amp;lt;charT&amp;gt;` 型の文字列として返される点を除いて、(1), (2) と同様である。
 
 ## 戻り値
-- (1)、(2) 置換結果出力後の `out`（引数のコピーではない）
-- (3)、(4) 置換結果の文字列
-- (5)、(6) 置換結果の文字列
+- (1), (2) 置換結果出力後の `out`（引数のコピーではない）
+- (3), (4) 置換結果の文字列
+- (5), (6) 置換結果の文字列
 
 
 ## 例外
@@ -86,7 +86,7 @@ namespace std {
 ## 備考
 本関数の正確な挙動は以下の通りである。
 
-- (1)、(2) [`regex_iterator`](regex_iterator.md) 型のオブジェクト `i` を
+- (1), (2) [`regex_iterator`](regex_iterator.md) 型のオブジェクト `i` を
 
     ```cpp
     regex_iterator&amp;lt;BidirectionalIterator, charT, traits&amp;gt; i(first, last, e, flags)
@@ -147,9 +147,9 @@ namespace std {
 
         を呼び出す。
 
-- (3)、(4) [`basic_string`](../string/basic_string.md)`&amp;lt;charT, ST, SA&amp;gt;` 型の空の文字列オブジェクト `result` を構築し、`regex_replace(`[`back_inserter`](../iterator/back_inserter.md)`(result), s.`[`begin`](../string/basic_string/begin.md)`(), s.`[`end`](../string/basic_string/end.md)`(), e, fmt, flags)` を呼び出す。  
+- (3), (4) [`basic_string`](../string/basic_string.md)`&amp;lt;charT, ST, SA&amp;gt;` 型の空の文字列オブジェクト `result` を構築し、`regex_replace(`[`back_inserter`](../iterator/back_inserter.md)`(result), s.`[`begin`](../string/basic_string/begin.md)`(), s.`[`end`](../string/basic_string/end.md)`(), e, fmt, flags)` を呼び出す。  
     戻り値は `result` となる。
-- (5)、(6) [`basic_string`](../string/basic_string.md)`&amp;lt;charT&amp;gt;` 型の空の文字列オブジェクト `result` を構築し、`regex_replace(`[`back_inserter`](../iterator/back_inserter.md)`(result), s, s +` [`char_traits`](../string/char_traits.md)`::`[`length`](../string/char_traits/length.md)`(s), e, fmt, flags)` を呼び出す。  
+- (5), (6) [`basic_string`](../string/basic_string.md)`&amp;lt;charT&amp;gt;` 型の空の文字列オブジェクト `result` を構築し、`regex_replace(`[`back_inserter`](../iterator/back_inserter.md)`(result), s, s +` [`char_traits`](../string/char_traits.md)`::`[`length`](../string/char_traits/length.md)`(s), e, fmt, flags)` を呼び出す。  
     戻り値は `result` となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/set/multiset/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/op_constructor.md b/reference/set/multiset/op_constructor.md
index dff5fb8b5..d4022a8a6 100644
--- a/reference/set/multiset/op_constructor.md
+++ b/reference/set/multiset/op_constructor.md
@@ -152,6 +152,6 @@ Size of c2: 7
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
 	`explicit set(const Compare&amp;amp; comp = Compare(), const Allocator&amp;amp; alloc = Allocator());` を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (5)、(11) を追加するきっかけとなったレポート  
+    (5), (11) を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/set/set/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/set/set/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/op_constructor.md b/reference/set/set/op_constructor.md
index 69d2b4834..30ab3f2a0 100644
--- a/reference/set/set/op_constructor.md
+++ b/reference/set/set/op_constructor.md
@@ -152,6 +152,6 @@ Size of c2: 6
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
 	`explicit set(const Compare&amp;amp; comp = Compare(), const Allocator&amp;amp; alloc = Allocator());` を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (5)、(11) を追加するきっかけとなったレポート  
+    (5), (11) を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/string/basic_string/op_plus.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index d44c7578e..0452ec6fd 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -222,7 +222,7 @@ namespace std {
 
 
 ## 備考
-(5)、(6) の形式の `lhs`、および、(9)、(10) の形式の `rhs` の文字列長算出のために `traits::length()` が使用される
+(5), (6) の形式の `lhs`、および、(9), (10) の形式の `rhs` の文字列長算出のために `traits::length()` が使用される
 
 ## アロケータの伝播
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/equal_range.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_map/equal_range.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/equal_range.md b/reference/unordered_map/unordered_map/equal_range.md
index 4b6f78796..c3ba4e15b 100644
--- a/reference/unordered_map/unordered_map/equal_range.md
+++ b/reference/unordered_map/unordered_map/equal_range.md
@@ -30,7 +30,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/find.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_map/find.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/find.md b/reference/unordered_map/unordered_map/find.md
index 912c23c02..43066fc4f 100644
--- a/reference/unordered_map/unordered_map/find.md
+++ b/reference/unordered_map/unordered_map/find.md
@@ -21,7 +21,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`型が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`型が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/insert.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_map/insert.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/insert.md b/reference/unordered_map/unordered_map/insert.md
index 4eec85b02..3b89f15a1 100644
--- a/reference/unordered_map/unordered_map/insert.md
+++ b/reference/unordered_map/unordered_map/insert.md
@@ -75,13 +75,13 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
 
 
 ## 戻り値
-- (1)、(2), (3) :
+- (1), (2), (3) :
     - [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`を返す
     - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータを返す
-- (4)、(5) :
+- (4), (5) :
     - 新たな要素が追加された場合、その追加された要素を指すイテレータを返す
     - 新たな要素が追加されなかった場合、すでにあった要素を指すイテレータを返す
-- (6)、(7) : なし
+- (6), (7) : なし
 - (9) :
     - [`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2), (3)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
         - 挿入された場合には、空の[ノードハンドル](/reference/node_handle/node_handle.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_or_assign -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/insert_or_assign.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_map/insert_or_assign.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/insert_or_assign.md b/reference/unordered_map/unordered_map/insert_or_assign.md
index 259f0ef98..64a133fb1 100644
--- a/reference/unordered_map/unordered_map/insert_or_assign.md
+++ b/reference/unordered_map/unordered_map/insert_or_assign.md
@@ -59,27 +59,27 @@ iterator
 
 
 ## 適格要件
-- (1)、(3)、(4)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
-- (2)、(5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (1), (3), (4), (6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (2), (5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
 
 
 ## 効果
-- (1)、(3)、(4)、(6) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(5) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1), (3), (4), (6) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2), (5) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1), (2), (3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 代入された場合には、`first` に代入された要素へのイテレータ、`second` に `false` が設定される。
-- (4)、(5)、(6) :
+- (4), (5), (6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 代入された場合には、代入された要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2)、(3) : [`emplace`](emplace.md) と同じ。
-- (4)、(5)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1), (2), (3) : [`emplace`](emplace.md) と同じ。
+- (4), (5), (6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_map/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_constructor.md b/reference/unordered_map/unordered_map/op_constructor.md
index 34b0d996e..52717ff23 100644
--- a/reference/unordered_map/unordered_map/op_constructor.md
+++ b/reference/unordered_map/unordered_map/op_constructor.md
@@ -102,7 +102,7 @@ unordered_map(std::from_range_t, R&amp;amp;&amp;amp; rg,
 
 - (3) の形式の場合、`value_type` は `*first` からこの `unordered_map` に EmplaceConstructible であること。
 
-- (4)、(7)、および (9) の形式の場合、`value_type` はこの `unordered_map` に CopyInsertable であること。
+- (4), (7)、および (9) の形式の場合、`value_type` はこの `unordered_map` に CopyInsertable であること。
 
 - (5) の形式の場合、`allocator_type` のムーブ構築は例外終了しないこと。
 
@@ -242,7 +242,7 @@ unordered_map(std::from_range_t, R&amp;amp;&amp;amp; rg,
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 #### 備考
-libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
+libstdc++ には 4.8.2 現在、(6), (7), (8)の形式はない。
 
 
 ## 関連項目
@@ -259,6 +259,6 @@ libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
     (1) + (2) を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (10)、(11)、(12)、(13)、(14)、(15) を追加するきっかけとなったレポート  
+    (10), (11), (12), (13), (14), (15) を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_emplace -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/try_emplace.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_map/try_emplace.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/try_emplace.md b/reference/unordered_map/unordered_map/try_emplace.md
index b4a3ccbd2..8ad001b14 100644
--- a/reference/unordered_map/unordered_map/try_emplace.md
+++ b/reference/unordered_map/unordered_map/try_emplace.md
@@ -56,9 +56,9 @@ iterator
 
 
 ## テンプレートパラメータ制約
-- (1)、(3)、(4)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
-- (2)、(5) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
-- (3)、(6) :
+- (1), (3), (4), (6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (2), (5) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (3), (6) :
     - `key_compare::is_transparent` が妥当な式であること
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
@@ -67,22 +67,22 @@ iterator
 
 
 ## 効果
-- (1)、(3)、(4)、(6) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(5) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1), (3), (4), (6) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2), (5) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1), (2), (3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 挿入されなかった場合には、`first` に `k` と等価のキーを持つ既存の要素へのイテレータ、`second` に `false` が設定される。
-- (4)、(5)、(6) :
+- (4), (5), (6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 挿入されなかった場合には、`k` と等価のキーを持つ既存の要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2) : [`emplace`](emplace.md) と同じ。
-- (4)、(5) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1), (2) : [`emplace`](emplace.md) と同じ。
+- (4), (5) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/equal_range.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_multimap/equal_range.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/equal_range.md b/reference/unordered_map/unordered_multimap/equal_range.md
index 533f2f3a7..a9bdc8180 100644
--- a/reference/unordered_map/unordered_multimap/equal_range.md
+++ b/reference/unordered_map/unordered_multimap/equal_range.md
@@ -30,7 +30,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/find.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_multimap/find.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/find.md b/reference/unordered_map/unordered_multimap/find.md
index d31985692..219cf8226 100644
--- a/reference/unordered_map/unordered_multimap/find.md
+++ b/reference/unordered_map/unordered_multimap/find.md
@@ -23,7 +23,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/insert.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_multimap/insert.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/insert.md b/reference/unordered_map/unordered_multimap/insert.md
index 209d4ca8a..fd2dd08f5 100644
--- a/reference/unordered_map/unordered_multimap/insert.md
+++ b/reference/unordered_map/unordered_multimap/insert.md
@@ -76,7 +76,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
 
 ## 戻り値
 - (1)から(6) : 追加された要素を指すイテレータを返す
-- (7)、(8) : なし
+- (7), (8) : なし
 - (9), (10) : `nh` が空の場合は終端イテレータ、そうでなければ挿入された要素を指すイテレータを返す
 
 
@@ -106,7 +106,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
 	これは規格の誤りとして C++17 で修正されたが、使用する処理系やそのバージョンによっては以前の「よりも小さい」という条件でしかイテレータの有効性を保証していない可能性があるため、注意が必要である。
 
 - これらの関数が呼ばれた後、たとえ呼び出しの前後でこのコンテナのバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）が変わった（＝リハッシュが発生した）場合でも、等価なキーの要素同士の相対的な順序は変わらない。
-- (4)、(5), (6) :
+- (4), (5), (6) :
     - 本関数呼び出しで構築されるオブジェクトを `t` とすると、`t.first` と等価なキーの要素が既に存在する場合、`position` に応じて既存の要素と新規の要素が順序付けられると期待されるが、規格書にそのような規定は存在しない。従って、そのような期待はすべきではない。[`emplace_hint`](emplace_hint.md) も参照。
     - 引数 `position` は、C++14 までは間接参照可能（dereferenceable）でなければならない（つまり、[`cend`](cend.md)`()` ではいけない）との記載になっていたが、これは規格の誤りとして C++17 で修正された。
 - 上記の要件に示したように、`first`、および、`last` の参照先の要素は `value_type` 型でなければならないとされているが、その要件を満たさなくてももう一つの要件である直接構築可能を満たすだけで十分にライブラリを実装可能と思われる。  
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_map/unordered_multimap/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/op_constructor.md b/reference/unordered_map/unordered_multimap/op_constructor.md
index 0e44aed11..677cf0816 100644
--- a/reference/unordered_map/unordered_multimap/op_constructor.md
+++ b/reference/unordered_map/unordered_multimap/op_constructor.md
@@ -103,7 +103,7 @@ unordered_multimap(std::from_range_t, R&amp;amp;&amp;amp; rg,
 
 - (3) の形式の場合、`value_type` は `*first` からこの `unordered_multimap` に EmplaceConstructible であること。
 
-- (4)、(7)、および (9) の形式の場合、`value_type` はこの `unordered_multimap` に CopyInsertable であること。
+- (4), (7)、および (9) の形式の場合、`value_type` はこの `unordered_multimap` に CopyInsertable であること。
 
 - (5) の形式の場合、`allocator_type` のムーブ構築は例外終了しないこと。
 
@@ -246,7 +246,7 @@ unordered_multimap(std::from_range_t, R&amp;amp;&amp;amp; rg,
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 #### 備考
-libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
+libstdc++ には 4.8.2 現在、(6), (7), (8)の形式はない。
 
 
 ## 関連項目
@@ -263,6 +263,6 @@ libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
     (1) + (2) を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (10)、(11)、(12)、(13)、(14)、(15) を追加するきっかけとなったレポート  
+    (10), (11), (12), (13), (14), (15) を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/equal_range.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_multiset/equal_range.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/equal_range.md b/reference/unordered_set/unordered_multiset/equal_range.md
index db8e2b7e9..8c54ff70e 100644
--- a/reference/unordered_set/unordered_multiset/equal_range.md
+++ b/reference/unordered_set/unordered_multiset/equal_range.md
@@ -30,7 +30,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/find.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_multiset/find.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/find.md b/reference/unordered_set/unordered_multiset/find.md
index bc0fefa02..4c3809a4a 100644
--- a/reference/unordered_set/unordered_multiset/find.md
+++ b/reference/unordered_set/unordered_multiset/find.md
@@ -23,7 +23,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/insert.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_multiset/insert.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/insert.md b/reference/unordered_set/unordered_multiset/insert.md
index 918f905b2..40b564a3f 100644
--- a/reference/unordered_set/unordered_multiset/insert.md
+++ b/reference/unordered_set/unordered_multiset/insert.md
@@ -27,12 +27,12 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 
 
 ## 要件
-- `v` を引数にとる形式（(1)、(2)の上側）では、`value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。  
+- `v` を引数にとる形式（(1), (2)の上側）では、`value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。  
 	コンテナに対してコピー挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
 
 	`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
 
-- `rv` を引数にとる形式（(1)、(2)の下側）では、`value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。  
+- `rv` を引数にとる形式（(1), (2)の下側）では、`value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。  
 	コンテナに対してムーブ挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
 
 	`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_multiset/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/op_constructor.md b/reference/unordered_set/unordered_multiset/op_constructor.md
index 3cbeb1ced..fe3d5b79b 100644
--- a/reference/unordered_set/unordered_multiset/op_constructor.md
+++ b/reference/unordered_set/unordered_multiset/op_constructor.md
@@ -104,7 +104,7 @@ unordered_multiset(std::from_range_t, R&amp;amp;&amp;amp; rg,
 
 - (3) の形式の場合、`value_type` は `*first` からこの `unordered_multiset` に EmplaceConstructible であること。
 
-- (4)、(7)、および (9) の形式の場合、`value_type` はこの `unordered_multiset` に CopyInsertable であること。
+- (4), (7)、および (9) の形式の場合、`value_type` はこの `unordered_multiset` に CopyInsertable であること。
 
 - (5) の形式の場合、`allocator_type` のムーブ構築は例外終了しないこと。
 
@@ -247,7 +247,7 @@ unordered_multiset(std::from_range_t, R&amp;amp;&amp;amp; rg,
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 #### 備考
-libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
+libstdc++ には 4.8.2 現在、(6), (7), (8)の形式はない。
 
 
 ## 関連項目
@@ -264,6 +264,6 @@ libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
     (1) + (2) を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (10)、(11)、(12)、(13)、(14)、(15) を追加するきっかけとなったレポート  
+    (10), (11), (12), (13), (14), (15) を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/equal_range.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_set/equal_range.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/equal_range.md b/reference/unordered_set/unordered_set/equal_range.md
index 60c1abf6f..a49cae008 100644
--- a/reference/unordered_set/unordered_set/equal_range.md
+++ b/reference/unordered_set/unordered_set/equal_range.md
@@ -30,7 +30,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/find.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_set/find.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/find.md b/reference/unordered_set/unordered_set/find.md
index 51fd19ffc..50e36f60b 100644
--- a/reference/unordered_set/unordered_set/find.md
+++ b/reference/unordered_set/unordered_set/find.md
@@ -21,7 +21,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3), (4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 6aaa0be13..072f428bb 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -68,13 +68,13 @@ iterator
 
 
 ## 適格要件
-- (1)、(4) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
+- (1), (4) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
     - コンテナに対してコピー挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
-- (2)、(5) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
+- (2), (5) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
     - コンテナに対してムーブ挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
-- (4)、(5) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
+- (4), (5) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
     - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
 - (7) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。
     - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。
@@ -89,8 +89,8 @@ iterator
 
 
 ## 効果
-- (1)、(2)、(3) : 引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
-- (4)、(5)、(6) : 第1引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+- (1), (2), (3) : 引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+- (4), (5), (6) : 第1引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
     - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
 - (7) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (8) : (7)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
@@ -100,9 +100,9 @@ iterator
 
 
 ## 戻り値
-- (1)、(2)、(3) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
+- (1), (2), (3) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
     - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
-- (4)、(5)、(6) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
+- (4), (5), (6) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
     - 新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
 - (7) : なし
 - (8) : なし
@@ -117,8 +117,8 @@ iterator
 
 
 ## 計算量
-- (1)、(2)、(3) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
-- (4)、(5)、(6) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
+- (1), (2), (3) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
+- (4), (5), (6) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
 - (7) : 平均的なケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` に比例（O(N)）するが、最悪のケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` とコンテナの要素数 [`size()`](size.md) に 1 加えたものの積に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last) * (`[`size`](size.md)`() + 1)`)）。
 - (8) : (7)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価。
 - (9), (10) : 平均的なケースでは `O(1)`、最悪のケースでは `O(size())`。
@@ -160,7 +160,7 @@ int main()
 {
   std::cout &amp;lt;&amp;lt; std::boolalpha;
 
-  // 一つの要素を挿入（(1)、(2)、(3)の形式）
+  // 一つの要素を挿入（(1), (2), (3)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -171,7 +171,7 @@ int main()
     print(&amp;#34;insert one element&amp;#34;, us);
   }
 
-  // 一つの要素を挿入（(4)、(5)、(6)の形式）
+  // 一つの要素を挿入（(4), (5), (6)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -233,7 +233,7 @@ insert initializer_list : 7 8 6 5 4 3 2 1 0
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 ## 実装例
-(4)、(5)、(7)、(8)の形式は、(1)、(2)の形式を使って実装することができる。
+(4), (5), (7), (8)の形式は、(1), (2)の形式を使って実装することができる。
 
 ```cpp
 template &amp;lt;class Key, class Hash, class Pred, class Allocator&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の区切りが「、」「, 」で表記揺れしていたため「, 」に統一</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/op_constructor.html"/>
      <id>e34727d477d17ad4aa7a92b2cddeec2eace0e9b2:reference/unordered_set/unordered_set/op_constructor.md</id>
      <updated>2025-05-22T16:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/op_constructor.md b/reference/unordered_set/unordered_set/op_constructor.md
index e55faf15e..28886dd98 100644
--- a/reference/unordered_set/unordered_set/op_constructor.md
+++ b/reference/unordered_set/unordered_set/op_constructor.md
@@ -104,7 +104,7 @@ unordered_set(std::from_range_t, R&amp;amp;&amp;amp; rg,
 
 - (3) の形式の場合、`value_type` は `*first` からこの `unordered_set` に EmplaceConstructible であること。
 
-- (4)、(7)、および (9) の形式の場合、`value_type` はこの `unordered_set` に CopyInsertable であること。
+- (4), (7)、および (9) の形式の場合、`value_type` はこの `unordered_set` に CopyInsertable であること。
 
 - (5) の形式の場合、`allocator_type` のムーブ構築は例外終了しないこと。
 
@@ -247,7 +247,7 @@ unordered_set(std::from_range_t, R&amp;amp;&amp;amp; rg,
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 #### 備考
-libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
+libstdc++ には 4.8.2 現在、(6), (7), (8)の形式はない。
 
 
 ## 関連項目
@@ -264,6 +264,6 @@ libstdc++ には 4.8.2 現在、(6)、(7)、(8)の形式はない。
 - [LWG 2193. Default constructors for standard library containers are explicit](http://cplusplus.github.io/LWG/lwg-defects.html#2193)  
     (1) + (2) を 2 つのオーバーロードに分割するきっかけとなったレポート
 - [LWG 2210. Missing allocator-extended constructor for allocator-aware containers](http://cplusplus.github.io/LWG/lwg-defects.html#2210)  
-    (10)、(11)、(12)、(13)、(14)、(15) を追加するきっかけとなったレポート  
+    (10), (11), (12), (13), (14), (15) を追加するきっかけとなったレポート  
     なお、Discussion の例はアロケータの型が誤っているので注意
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bucket -- unordered_(multi)set::bucket : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/bucket.html"/>
      <id>9bcd535b0cb4a69bb29748b0a10fa83c8b58ac20:reference/unordered_set/unordered_multiset/bucket.md</id>
      <updated>2025-05-22T16:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/bucket.md b/reference/unordered_set/unordered_multiset/bucket.md
index d970e5566..165c9ec60 100644
--- a/reference/unordered_set/unordered_multiset/bucket.md
+++ b/reference/unordered_set/unordered_multiset/bucket.md
@@ -6,20 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-size_type bucket(const key_type&amp;amp; k) const;
+size_type bucket(const key_type&amp;amp; k) const; // (1) C++11
+
+template &amp;lt;class K&amp;gt;
+size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ```
 
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
+- (1) : `key_type`型のキーを受け取って、バケットのインデックスを取得する
+- (2) : `key_type`と比較可能なキーを受け取って、バケットのインデックスを取得する
+
+
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent` が妥当な式であること
 
-## 要件
+
+## 事前条件
 当該コンテナは [`bucket_count`](bucket_count.md)`() &amp;gt; 0` であること
 
 
 ## 戻り値
 パラメータ `k` と等価なキーの要素が格納されているバケットのインデックス（添え字）
 
+
+## 事後条件
 戻り値は `[0,` [`bucket_count`](bucket_count.md)`())` の範囲である。
 
 
@@ -28,7 +40,10 @@ size_type bucket(const key_type&amp;amp; k) const;
 
 
 ## 備考
-指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- 指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -94,3 +109,6 @@ key = H, bucket = 3, bucket_size = 0
 |----------------------------------------------|----------------------|
 | [`max_bucket_count`](max_bucket_count.md)  | 最大バケット数の取得 |
 
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bucket -- unordered_(multi)set::bucket : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/bucket.html"/>
      <id>9bcd535b0cb4a69bb29748b0a10fa83c8b58ac20:reference/unordered_set/unordered_set/bucket.md</id>
      <updated>2025-05-22T16:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/bucket.md b/reference/unordered_set/unordered_set/bucket.md
index c8c990ed4..a7d2700cb 100644
--- a/reference/unordered_set/unordered_set/bucket.md
+++ b/reference/unordered_set/unordered_set/bucket.md
@@ -6,20 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-size_type bucket(const key_type&amp;amp; k) const;
+size_type bucket(const key_type&amp;amp; k) const; // (1) C++11
+
+template &amp;lt;class K&amp;gt;
+size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ```
 
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
+- (1) : `key_type`型のキーを受け取って、バケットのインデックスを取得する
+- (2) : `key_type`と比較可能なキーを受け取って、バケットのインデックスを取得する
+
+
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent` が妥当な式であること
 
-## 要件
+
+## 事前条件
 当該コンテナは [`bucket_count`](bucket_count.md)`() &amp;gt; 0` であること
 
 
 ## 戻り値
 パラメータ `k` と等価なキーの要素が格納されているバケットのインデックス（添え字）
 
+
+## 事後条件
 戻り値は `[0,` [`bucket_count`](bucket_count.md)`())` の範囲である。
 
 
@@ -28,7 +40,10 @@ size_type bucket(const key_type&amp;amp; k) const;
 
 
 ## 備考
-指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- 指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -85,8 +100,10 @@ key = H, bucket = 2, bucket_size = 0
 
 ## 関連項目
 
-
 | 名前 | 説明 |
 |-------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------|
 | [`max_bucket_count`](max_bucket_count.md) | 最大バケット数の取得 |
 
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- unordered_set::insert : C++26異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/set/set/insert.html"/>
      <id>6216138ce74cd31f4d2b8567733a769fc9f5f320:reference/set/set/insert.md</id>
      <updated>2025-05-22T16:18:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/insert.md b/reference/set/set/insert.md
index 5310bb901..180fb3d7a 100644
--- a/reference/set/set/insert.md
+++ b/reference/set/set/insert.md
@@ -37,10 +37,10 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (10) C++17
 
 - (1) : 新たな要素`x`をコピー挿入する
 - (2) : 新たな要素`y`をムーブ挿入する
-- (3) : `value_type`に変換可能な`Key`型の新たな要素`x`を転送して挿入する
+- (3) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する
 - (4) : 新たな要素`x`をコピー挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
 - (5) : 新たな要素`y`をムーブ挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (6) : `value_type`に変換可能な`Key`型の新たな要素`x`を転送して挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (6) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
 - (7) : イテレータ範囲`[first, last)`の要素を挿入する
 - (8) : 初期化子リスト`init`の要素を挿入する
 - (9) : `nh`が空の場合、効果はない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- unordered_set::insert : C++26異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>6216138ce74cd31f4d2b8567733a769fc9f5f320:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2025-05-22T16:18:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 0db8c87cf..6aaa0be13 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -6,19 +6,40 @@
 * cpp11[meta cpp]
 
 ```cpp
-pair&amp;lt;iterator, bool&amp;gt; insert(const value_type&amp;amp; v);              // (1) C++11
-pair&amp;lt;iterator, bool&amp;gt; insert(value_type&amp;amp;&amp;amp; rv);                  // (2) C++11
-
-iterator insert(const_iterator position, const value_type&amp;amp; v); // (3) C++11
-iterator insert(const_iterator position, value_type&amp;amp;&amp;amp; rv);     // (4) C++11
+pair&amp;lt;iterator, bool&amp;gt;
+  insert(const value_type&amp;amp; v);             // (1) C++11
+pair&amp;lt;iterator, bool&amp;gt;
+  insert(value_type&amp;amp;&amp;amp; rv);                 // (2) C++11
+
+template &amp;lt;class K&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  insert(K&amp;amp;&amp;amp; x);                           // (3) C++26
+
+iterator
+  insert(const_iterator position,
+         const value_type&amp;amp; v);             // (4) C++11
+iterator
+  insert(const_iterator position,
+         value_type&amp;amp;&amp;amp; rv);                 // (5) C++11
+
+template &amp;lt;class K&amp;gt;
+iterator
+  insert(const_iterator hint,
+         K&amp;amp;&amp;amp; x);                           // (6) C++11
 
 template &amp;lt;class InputIterator&amp;gt;
-void insert(InputIterator first, InputIterator last);          // (5) C++11
-
-void insert(initializer_list&amp;lt;value_type&amp;gt; il);                  // (6) C++11
-
-insert_return_type insert(node_type&amp;amp;&amp;amp; nh);                     // (7) C++17
-iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
+void
+  insert(InputIterator first,
+         InputIterator last);              // (7) C++11
+
+void
+  insert(initializer_list&amp;lt;value_type&amp;gt; il); // (8) C++11
+
+insert_return_type
+  insert(node_type&amp;amp;&amp;amp; nh);                  // (9) C++17
+iterator
+  insert(const_iterator hint,
+         node_type&amp;amp;&amp;amp; nh);                  // (10) C++17
 ```
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
@@ -28,57 +49,67 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 - (1) : 新たな要素`v`をコピー挿入する
 - (2) : 新たな要素`rv`をムーブ挿入する
-- (3) : 新たな要素`v`をコピー挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (4) : 新たな要素`rv`をムーブ挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (5) : イテレータ範囲`[first, last)`の要素を挿入する
-- (6) : 初期化子リスト`il`の要素を挿入する
-- (7) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
-- (8) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。 `nh.key()`と同等のキーの要素を指すイテレータを常に返す。要素は、`hint`の直前の位置のできるだけ近くに挿入される。
+- (3) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する
+- (4) : 新たな要素`v`をコピー挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (5) : 新たな要素`rv`をムーブ挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (6) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (7) : イテレータ範囲`[first, last)`の要素を挿入する
+- (8) : 初期化子リスト`il`の要素を挿入する
+- (9) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
+- (10) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。 `nh.key()`と同等のキーの要素を指すイテレータを常に返す。要素は、`hint`の直前の位置のできるだけ近くに挿入される。
+
+
+## テンプレートパラメータ制約
+- (3), (6) :
+    - `key_compare::is_transparent` が妥当な式であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
+    - `value_type`が[`std::forward`](/reference/utility/forward.md)`&amp;lt;K&amp;gt;(x)`によって直接構築可能であること
 
 
 ## 適格要件
-- (1)、(3) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
+- (1)、(4) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
     - コンテナに対してコピー挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
-- (2)、(4) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
+- (2)、(5) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
     - コンテナに対してムーブ挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
-- (3)、(4) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
+- (4)、(5) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
     - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
-- (5) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。
+- (7) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。
     - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。
     - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
     - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
-- (6) : `value_type` はコンテナに対してコピー挿入可能でなければならない。
+- (8) : `value_type` はコンテナに対してコピー挿入可能でなければならない。
 
 
 ## 事前条件
-- (5), (6) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない。
+- (9), (10) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない。
 
 
 ## 効果
-- (1)、(2) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
-- (3)、(4) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+- (1)、(2)、(3) : 引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+- (4)、(5)、(6) : 第1引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
     - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
-- (5) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
-- (6) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
-- (7) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
-- (8) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。`nh.key()`と等価のキーの要素を指すイテレータを常に返す。
+- (7) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
+- (8) : (7)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
+- (9) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
+- (10) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。`nh.key()`と等価のキーの要素を指すイテレータを常に返す。
     - 要素は、`hint`の直前の位置のできるだけ近くに挿入される。
 
 
 ## 戻り値
-- (1)、(2) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
+- (1)、(2)、(3) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
     - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
-- (3)、(4) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
+- (4)、(5)、(6) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
     - 新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
-- (5) : なし
-- (6) : なし
-- (7) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
+- (7) : なし
+- (8) : なし
+- (9) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
     - 挿入された場合には、空の[ノードハンドル](/reference/node_handle/node_handle.md)。
     - 挿入されなかった場合には、`nh`の値である。 
-- (8) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
+- (10) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
 
 
 ## 例外
@@ -86,11 +117,11 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 
 ## 計算量
-- (1)、(2) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
-- (3)、(4) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
-- (5) : 平均的なケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` に比例（O(N)）するが、最悪のケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` とコンテナの要素数 [`size()`](size.md) に 1 加えたものの積に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last) * (`[`size`](size.md)`() + 1)`)）。
-- (6) : (4)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価。
-- (7), (8) : 平均的なケースでは `O(1)`、最悪のケースでは `O(size())`。
+- (1)、(2)、(3) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
+- (4)、(5)、(6) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
+- (7) : 平均的なケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` に比例（O(N)）するが、最悪のケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` とコンテナの要素数 [`size()`](size.md) に 1 加えたものの積に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last) * (`[`size`](size.md)`() + 1)`)）。
+- (8) : (7)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価。
+- (9), (10) : 平均的なケースでは `O(1)`、最悪のケースでは `O(size())`。
 
 
 ## 備考
@@ -102,7 +133,10 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
         - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
         - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
     - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
-- (7), (8) の場合、要素はコピーもムーブもされない。
+- (9), (10) の場合、要素はコピーもムーブもされない。
+- (3), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -126,7 +160,7 @@ int main()
 {
   std::cout &amp;lt;&amp;lt; std::boolalpha;
 
-  // 一つの要素を挿入（(1)、(2)の形式）
+  // 一つの要素を挿入（(1)、(2)、(3)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -137,7 +171,7 @@ int main()
     print(&amp;#34;insert one element&amp;#34;, us);
   }
 
-  // 一つの要素を挿入（(3)、(4)の形式）
+  // 一つの要素を挿入（(4)、(5)、(6)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -148,7 +182,7 @@ int main()
     print(&amp;#34;insert one element with hint&amp;#34;, us);
   }
 
-  // 複数の要素を挿入（(5)の形式）
+  // 複数の要素を挿入（(7)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -157,7 +191,7 @@ int main()
     print(&amp;#34;insert range&amp;#34;, us);
   }
 
-  // 複数の要素を挿入（(6)の形式）
+  // 複数の要素を挿入（(8)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -199,7 +233,7 @@ insert initializer_list : 7 8 6 5 4 3 2 1 0
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 ## 実装例
-(3)、(4)、(5)、(6)の形式は、(1)、(2)の形式を使って実装することができる。
+(4)、(5)、(7)、(8)の形式は、(1)、(2)の形式を使って実装することができる。
 
 ```cpp
 template &amp;lt;class Key, class Hash, class Pred, class Allocator&amp;gt;
@@ -253,7 +287,9 @@ inline void unordered_set&amp;lt;Key, Hash, Pred, Allocator&amp;gt;::insert(initializer_list&amp;lt;K
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
 - [N2679 Initializer Lists for Standard Containers(Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2679.pdf)
-    - (6)の経緯となる提案文書
+    - (8)の経緯となる提案文書
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-    - (7), (7)経緯となる提案文書
+    - (9), (10)経緯となる提案文書
 - [How useful is the hint passed to the std::unordered_... collections? - The Old New Thing](https://devblogs.microsoft.com/oldnewthing/20241028-00/?p=110428)
+- [P2363R5: Extending associative containers with the remaining heterogeneous overloads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- インデントを再修正</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>0ff1c70cff068a5069c9a2f51a7727e763055e1e:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2025-05-22T16:04:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 29a16a84d..0db8c87cf 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -37,19 +37,19 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 
 ## 適格要件
-- (1)、(3) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。  
+- (1)、(3) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
     - コンテナに対してコピー挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
-- (2)、(4) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。  
+        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
+- (2)、(4) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
     - コンテナに対してムーブ挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
-- (3)、(4) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。  
-	   - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
-- (5) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
-	   - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
-	   - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	       - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
-	   - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
+        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
+- (3)、(4) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
+    - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
+- (5) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。
+    - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。
+    - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
+        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
+    - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
 - (6) : `value_type` はコンテナに対してコピー挿入可能でなければならない。
 
 
@@ -59,8 +59,8 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 ## 効果
 - (1)、(2) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
-- (3)、(4) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。  
-	   - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
+- (3)、(4) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+    - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
 - (5) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (6) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
 - (7) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
@@ -69,10 +69,10 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 
 ## 戻り値
-- (1)、(2) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。  
-	   - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
-- (3)、(4) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。  
-	新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
+- (1)、(2) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
+    - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
+- (3)、(4) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
+    - 新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
 - (5) : なし
 - (6) : なし
 - (7) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
@@ -95,13 +95,13 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 ## 備考
 - これらの関数が呼ばれた後も、当該コンテナ内の要素を指す参照は無効にはならない。
-	なお、規格書に明確な記載は無いが、当該コンテナ内の要素を指すポインタも無効にはならない。
-- これらの関数が呼ばれた後も、呼び出しの前後でこのコンテナのバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）が変わらなかった場合には当該コンテナを指すイテレータは無効にはならない。  
-	   - それ以外の場合は、当該コンテナを指すイテレータは無効になる可能性がある。  
-	   - コンテナのバケット数が変わらない場合とは、以下のいずれかである：
-	       - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
-	       - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
-	   - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
+    - なお、規格書に明確な記載は無いが、当該コンテナ内の要素を指すポインタも無効にはならない。
+- これらの関数が呼ばれた後も、呼び出しの前後でこのコンテナのバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）が変わらなかった場合には当該コンテナを指すイテレータは無効にはならない。
+    - それ以外の場合は、当該コンテナを指すイテレータは無効になる可能性がある。
+    - コンテナのバケット数が変わらない場合とは、以下のいずれかである：
+        - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
+        - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
+    - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
 - (7), (8) の場合、要素はコピーもムーブもされない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- インデントを修正</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>b809dbcf989f2c69f46ddec3c55a40e5686f2ad0:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2025-05-22T15:56:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 7a2b87647..29a16a84d 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -39,17 +39,17 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 ## 適格要件
 - (1)、(3) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。  
     - コンテナに対してコピー挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	      - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
+	        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
 - (2)、(4) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。  
     - コンテナに対してムーブ挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	      - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
+	        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
 - (3)、(4) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。  
-	  - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
+	   - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
 - (5) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
-	  - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
-	  - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	      - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
-	  - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
+	   - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
+	   - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
+	       - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
+	   - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
 - (6) : `value_type` はコンテナに対してコピー挿入可能でなければならない。
 
 
@@ -60,7 +60,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 ## 効果
 - (1)、(2) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
 - (3)、(4) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。  
-	  - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
+	   - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
 - (5) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (6) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
 - (7) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
@@ -70,7 +70,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 ## 戻り値
 - (1)、(2) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。  
-	  - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
+	   - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
 - (3)、(4) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。  
 	新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
 - (5) : なし
@@ -97,11 +97,11 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 - これらの関数が呼ばれた後も、当該コンテナ内の要素を指す参照は無効にはならない。
 	なお、規格書に明確な記載は無いが、当該コンテナ内の要素を指すポインタも無効にはならない。
 - これらの関数が呼ばれた後も、呼び出しの前後でこのコンテナのバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）が変わらなかった場合には当該コンテナを指すイテレータは無効にはならない。  
-	  - それ以外の場合は、当該コンテナを指すイテレータは無効になる可能性がある。  
-	  - コンテナのバケット数が変わらない場合とは、以下のいずれかである：
-	      - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
-	      - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
-	  - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
+	   - それ以外の場合は、当該コンテナを指すイテレータは無効になる可能性がある。  
+	   - コンテナのバケット数が変わらない場合とは、以下のいずれかである：
+	       - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
+	       - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
+	   - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
 - (7), (8) の場合、要素はコピーもムーブもされない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>