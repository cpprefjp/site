<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-09-03T15:11:39.186053</updated>
  <id>358e97f1-5928-48ec-862f-71c43c9ace78</id>

  
    <entry>
      <title>組み込み配列の比較を非推奨化 [P1120R0] -- P1120R0: コメントの解説の誤植を修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecate_array_comparisons.html"/>
      <id>1db2ef444f24ef0c04765f530fe956756994a8bb:lang/cpp20/deprecate_array_comparisons.md</id>
      <updated>2025-09-04T00:04:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecate_array_comparisons.md b/lang/cpp20/deprecate_array_comparisons.md
index 72be0f359..cb0515bc5 100644
--- a/lang/cpp20/deprecate_array_comparisons.md
+++ b/lang/cpp20/deprecate_array_comparisons.md
@@ -17,7 +17,7 @@
 ```cpp
 int arr1[5];
 int arr2[5];
-bool same = arr1 == arr2; // C++20で非推奨。&amp;amp;arr[0] == &amp;amp;arr[1]と同じ。
+bool same = arr1 == arr2; // C++20で非推奨。&amp;amp;arr1[0] == &amp;amp;arr2[0]と同じ。
                           // 配列の要素は比較されない
 auto cmp = arr1 &amp;lt;=&amp;gt; arr2; // エラー！
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ACUVE</name>
        <email>601805+ACUVE@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>非推奨だった組み込み配列の比較を削除 [P2865R6] -- Merge pull request #1527 from ACUVE/fix/P2865R6</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/remove_deprecated_array_comparisons.html"/>
      <id>909d638caecaa7a6b61e1db5ab34a0ad5dd7be03:lang/cpp26/remove_deprecated_array_comparisons.md</id>
      <updated>2025-09-03T23:54:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/remove_deprecated_array_comparisons.md b/lang/cpp26/remove_deprecated_array_comparisons.md
index 83fff0fd0..308150ca1 100644
--- a/lang/cpp26/remove_deprecated_array_comparisons.md
+++ b/lang/cpp26/remove_deprecated_array_comparisons.md
@@ -18,7 +18,7 @@ C++20での[三方比較演算子](/lang/cpp20/consistent_comparison.md)の導
 int arr1[5];
 int arr2[5];
 bool same = arr1 == arr2; // C++20: 非推奨、C++26: エラー。
-                          // &amp;amp;arr[0] == &amp;amp;arr[1]と同じ。
+                          // &amp;amp;arr1[0] == &amp;amp;arr2[0]と同じ。
                           // 配列の要素は比較されない
 auto cmp = arr1 &amp;lt;=&amp;gt; arr2; // エラー！
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>非推奨だった組み込み配列の比較を削除 [P2865R6] -- P2865R6: コメントの解説の誤植を修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/remove_deprecated_array_comparisons.html"/>
      <id>957695995f2ea44d12c1bb54439a4a4982fcc22f:lang/cpp26/remove_deprecated_array_comparisons.md</id>
      <updated>2025-09-03T23:44:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/remove_deprecated_array_comparisons.md b/lang/cpp26/remove_deprecated_array_comparisons.md
index 83fff0fd0..308150ca1 100644
--- a/lang/cpp26/remove_deprecated_array_comparisons.md
+++ b/lang/cpp26/remove_deprecated_array_comparisons.md
@@ -18,7 +18,7 @@ C++20での[三方比較演算子](/lang/cpp20/consistent_comparison.md)の導
 int arr1[5];
 int arr2[5];
 bool same = arr1 == arr2; // C++20: 非推奨、C++26: エラー。
-                          // &amp;amp;arr[0] == &amp;amp;arr[1]と同じ。
+                          // &amp;amp;arr1[0] == &amp;amp;arr2[0]と同じ。
                           // 配列の要素は比較されない
 auto cmp = arr1 &amp;lt;=&amp;gt; arr2; // エラー！
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ACUVE</name>
        <email>601805+ACUVE@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get-domain-early -- execution/get-domain-{early,late}: 関連項目</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/get-domain-early.html"/>
      <id>171949a4d82b8d9b0f311d087b0bdf9dce336583:reference/execution/execution/get-domain-early.md</id>
      <updated>2025-09-02T12:04:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/get-domain-early.md b/reference/execution/execution/get-domain-early.md
index 8ca93cb86..57875cca8 100644
--- a/reference/execution/execution/get-domain-early.md
+++ b/reference/execution/execution/get-domain-early.md
@@ -37,6 +37,16 @@ constexpr auto get-domain-early(const Sndr&amp;amp; sndr) noexcept;
 
 
 ## 関連項目
+- [`execution::continues_on`](continues_on.md)
+- [`execution::then`](then.md)
+- [`execution::let_value`](let_value.md)
+- [`execution::bulk`](bulk.md)
+- [`execution::when_all`](when_all.md)
+- [`execution::into_variant`](into_variant.md)
+- [`execution::stopped_as_optional`](stopped_as_optional.md)
+- [`execution::stopped_as_error`](stopped_as_error.md)
+- [`execution::associate`](associate.md.nolink)
+- [`execution::affine_on`](affine_on.md.nolink)
 - [`this_thread::sync_wait`](../this_thread/sync_wait.md)
 - [`this_thread::sync_wait_with_variant`](../this_thread/sync_wait_with_variant.md)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get-domain-late -- execution/get-domain-{early,late}: 関連項目</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/get-domain-late.html"/>
      <id>171949a4d82b8d9b0f311d087b0bdf9dce336583:reference/execution/execution/get-domain-late.md</id>
      <updated>2025-09-02T12:04:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/get-domain-late.md b/reference/execution/execution/get-domain-late.md
index 877a17341..20eb3fe6b 100644
--- a/reference/execution/execution/get-domain-late.md
+++ b/reference/execution/execution/get-domain-late.md
@@ -61,6 +61,7 @@ Senderアダプタ[`continues_on`](continues_on.md)は[`schedule_from`](schedule
 ## 関連項目
 - [`execution::connect`](connect.md)
 - [`execution::continues_on`](continues_on.md)
+- [`execution::get_completion_signatures`](get_completion_signatures.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- execution: P3149R11 scope_token(#1510)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>a510758913f926956ab0c34fa98ee0db461f8678:reference/execution/execution.md</id>
      <updated>2025-09-02T01:37:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index 8c2b21edb..dd27c311b 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -131,6 +131,8 @@ namespace std::execution {
 | [`execution::into_variant`](execution/into_variant.md) | 複数の値完了シグネチャを単一[`variant`](/reference/variant/variant.md)型の値完了シグネチャに変換 (customization point object) | C++26 |
 | [`execution::stopped_as_optional`](execution/stopped_as_optional.md) | 入力Senderの停止完了を空の[`optional`](/reference/optional/optional.md)値完了に変換 (customization point object) | C++26 |
 | [`execution::stopped_as_error`](execution/stopped_as_error.md) | 入力Senderの停止完了をエラー完了に変換 (customization point object) | C++26 |
+| [`execution::associate`](execution/associate.md.nolink) | 非同期スコープへの関連付け (customization point object) | C++26 |
+| [`execution::spawn_future`](execution/spawn_future.md.nolink) | 非同期操作を早期開始 (customization point object) | C++26 |
 
 ### Senderコンシューマ
 
@@ -138,8 +140,9 @@ namespace std::execution {
 |------|------|----------------|
 | [`this_thread::sync_wait`](this_thread/sync_wait.md) | 現在のスレッド上でSender完了を待機 (customization point object) | C++26 |
 | [`this_thread::sync_wait_with_variant`](this_thread/sync_wait_with_variant.md) | 現在のスレッド上でSender完了を待機 (customization point object) | C++26 |
+| [`execution::spawn`](execution/spawn.md.nolink) | 非同期操作を早期開始 (customization point object) | C++26 |
 
-Senderコンシューマは名前空間 `std::this_thread` で定義される。
+Senderコンシューマは名前空間 `std::this_thread` および名前空間 `std::execution` で定義される。
 
 ### Sender/Receiverユーティリティ
 
@@ -158,6 +161,14 @@ Senderコンシューマは名前空間 `std::this_thread` で定義される。
 | [`execution::as_awaitable`](execution/as_awaitable.md) | Senderを[Awaitable型](/lang/cpp20/coroutines.md)へ変換 (customization point object) | C++26 |
 | [`execution::with_awaitable_senders`](execution/with_awaitable_senders.md) | [Promise型](/lang/cpp20/coroutines.md)の基底クラス (class template) | C++26 |
 
+### 実行スコープユーティリティ
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`execution::scope_token`](execution/scope_token.md) | 非同期スコープトークン (concept) | C++26 |
+| [`execution::simple_counting_scope`](execution/simple_counting_scope.md) | カウント式非同期スコープ (class) | C++26 |
+| [`execution::counting_scope`](execution/counting_scope.md) | 停止要求可能なカウント式非同期スコープ (class) | C++26 |
+
 ### 並列Scheduler
 
 | 名前 | 説明 | 対応バージョン |
@@ -176,6 +187,7 @@ Senderコンシューマは名前空間 `std::this_thread` で定義される。
 - [P0024R2 The Parallelism TS Should be Standardized](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
 - [P2079R10 Parallel scheduler](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r10.html)
+- [P3149R11 `async_scope` - Creating scopes for non-sequential concurrency](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r11.html)
 - [P3284R4 `write_env` and `unstoppable` Sender Adaptors](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3284r4.html)
 - [P3481R5 `std::execution::bulk()` issues](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r5.html)
 - [P3557R3 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>counting_scope -- execution: P3149R11 scope_token(#1510)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/counting_scope.html"/>
      <id>a510758913f926956ab0c34fa98ee0db461f8678:reference/execution/execution/counting_scope.md</id>
      <updated>2025-09-02T01:37:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/counting_scope.md b/reference/execution/execution/counting_scope.md
new file mode 100644
index 000000000..4819fa15b
--- /dev/null
+++ b/reference/execution/execution/counting_scope.md
@@ -0,0 +1,57 @@
+# counting_scope
+* execution[meta header]
+* class[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  class counting_scope;
+}
+```
+
+## 概要
+`counting_scope`は、停止要求を作成可能なカウント式の非同期スコープを表現する。
+
+
+## メンバ関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`(constructor)`](counting_scope/op_constructor.md.nolink) | コンストラクタ | C++26 |
+| [`(destructor)`](counting_scope/op_destructor.md.nolink) | デストラクタ | C++26 |
+| [`get_token`](counting_scope/get_token.md.nolink) | 非同期スコープトークンを取得 | C++26 |
+| [`close`](counting_scope/close.md.nolink) | 非同期スコープを閉じる | C++26 |
+| [`join`](counting_scope/join.md.nolink) | 非同期スコープを合流する[Sender](sender.md)取得 | C++26 |
+| [`request_stop`](counting_scope/request_stop.md.nolink) | 停止要求を行う | C++26 |
+
+## メンバ型
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`token`](counting_scope/token.md.nolink) | 非同期スコープトークン型 | C++26 |
+
+## 静的メンバ変数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| `constexpr size_t max_associations = implementation-defined;` | 関連付けの最大数 | C++26 |
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::simple_counting_scope`](simple_counting_scope.md)
+
+
+## 参照
+- [P3149R11 `async_scope` - Creating scopes for non-sequential concurrency](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r11.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scope_token -- execution: P3149R11 scope_token(#1510)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/scope_token.html"/>
      <id>a510758913f926956ab0c34fa98ee0db461f8678:reference/execution/execution/scope_token.md</id>
      <updated>2025-09-02T01:37:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/scope_token.md b/reference/execution/execution/scope_token.md
new file mode 100644
index 000000000..f44f23393
--- /dev/null
+++ b/reference/execution/execution/scope_token.md
@@ -0,0 +1,77 @@
+# scope_token
+* execution[meta header]
+* concept[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  template&amp;lt;class Token&amp;gt;
+  concept scope_token =
+    copyable&amp;lt;Token&amp;gt; &amp;amp;&amp;amp;
+    requires(const Token token) {
+      { token.try_associate() } -&amp;gt; same_as&amp;lt;bool&amp;gt;;
+      { token.disassociate() } noexcept -&amp;gt; same_as&amp;lt;void&amp;gt;;
+      { token.wrap(declval&amp;lt;test-sender&amp;gt;()) } -&amp;gt; sender_in&amp;lt;test-env&amp;gt;;
+    };
+}
+```
+* copyable[link /reference/concepts/copyable.md]
+* sender_in[link sender_in.md]
+* test-sender[italic]
+* test-env[italic]
+
+## 概要
+`scope_token`コンセプトは、[Sender](sender.md)と非同期スコープ間の関連付けを作成するために利用できる型`Token`に対する要件を定義する。
+
+`test-sender`と`test-env`は、[`sender_in`](sender_in.md)`&amp;lt;test-sender, test-env&amp;gt;`のモデルである未規定の型とする。
+
+
+## モデル
+型`Token`は、次のとき`scope_token`のモデルとなる。
+
+- `Token`型オブジェクトのコピー構築、ムーブ構築、コピー代入、ムーブ代入から例外送出しない、かつ
+- （const修飾の可能性のある）型`Token`の左辺値`token`が与えられたとき、型`decltype((sndr))`が[`sender`](sender.md)のモデルである全ての式`sndr`に対して、
+    - `token.warp(sndr)`が有効な式、かつ
+    - `decltype(token.warp(sndr))`は[`sender`](sender.md)のモデルであり、かつ
+    - [`sender_in`](sender_in.md)`&amp;lt;decltype((sndr)), E&amp;gt;`のモデルである全ての`E`型に対して、[`completion_signatures_of_t`](completion_signatures_of_t.md)`&amp;lt;decltype(token.wrap(sndr)), E&amp;gt;`は[`completion_signatures_of_t`](completion_signatures_of_t.md)`&amp;lt;decltype((sndr)), E&amp;gt;`と同一の完了シグネチャを含むこと。
+
+
+## 例
+```cpp example
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+int main()
+{
+  ex::counting_scope scope;
+  ex::scope_token auto token = scope.get_token();
+}
+```
+* ex::scope_token[color ff0000]
+* ex::counting_scope[link counting_scope.md]
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::associate`](associate.md.nolink)
+- [`execution::spawn_future`](spawn_future.md.nolink)
+- [`execution::spawn`](spawn.md.nolink)
+
+
+## 参照
+- [P3149R11 `async_scope` - Creating scopes for non-sequential concurrency](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r11.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>simple_counting_scope -- execution: P3149R11 scope_token(#1510)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/simple_counting_scope.html"/>
      <id>a510758913f926956ab0c34fa98ee0db461f8678:reference/execution/execution/simple_counting_scope.md</id>
      <updated>2025-09-02T01:37:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/simple_counting_scope.md b/reference/execution/execution/simple_counting_scope.md
new file mode 100644
index 000000000..6ca315a01
--- /dev/null
+++ b/reference/execution/execution/simple_counting_scope.md
@@ -0,0 +1,201 @@
+# simple_counting_scope
+* execution[meta header]
+* class[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  class simple_counting_scope;
+}
+```
+
+## 概要
+`simple_counting_scope`は、カウント式の非同期スコープを表現する。
+
+
+## クラス仕様
+`simple_counting_scope`型と[`counting_scope`](counting_scope.md)型による非同期スコープは関連付けカウントを管理する。
+
+クラス動作説明用のメンバ変数として下記を保持する。
+
+- `count` : `size_t`型の関連付けカウント値
+- `state` : `scope-state-type`列挙型（後述）の状態
+
+
+### 状態遷移
+説明専用の各種エンティティを下記の通り定義する。
+
+- `Scope`型 : `simple_counting_scope`または`counting_scope`のいずれか
+- `scope`オブジェクト : `Scope`型のオブジェクト
+- `tkn`オブジェクト : `scope.get_token()`が返す`Scope::token`型のオブジェクト
+- `jsndr` : `scope.join()`が返す[Sender](sender.md)
+- `op` : `jsndr`を[Receiver](receiver.md)と接続して得られる[Operation State](operation_state.md)
+
+```cpp
+enum scope-state-type {  // exposition only
+  unused,                // exposition only
+  open,                  // exposition only
+  closed,                // exposition only
+  open-and-joining,      // exposition only
+  closed-and-joining,    // exposition only
+  unused-and-closed,     // exposition only
+  joined,                // exposition only
+};
+```
+
+`scope`はその生存期間中にさまざまな状態をとり、各状態で許可される操作とその結果を決定する：
+
+- `unused` : 新しく構築されたオブジェクトは`unused`状態で開始する。
+- `open` : `scope`が`unused`状態にあるとき`tkn.try_associate()`が呼び出されると、`scope`は`open`状態に遷移する。
+- `open-and-joining` : `scope`が`unused`または`open`状態にあるとき[Operation State](operation_state.md)`op`が[開始(start)](start.md)されると、`scope`は`open-and-joining`状態に遷移する。
+- `closed` : `scope`が`open`状態にあるとき`scope.close()`が呼び出されると、`scope`は`closed`状態に遷移する。
+- `unused-and-closed` : `scope`が`unused`状態にあるとき`scope.close()`が呼び出されると、`scope`は`unused-and-closed`状態に遷移する。
+- `closed-and-joining` : `scope`が`open-and-joining`状態にあるとき`scope.close()`が呼び出される、もしくは`scope`が`closed`または`unused-and-closed`状態にあるとき[Operation State](operation_state.md)`op`が[開始(start)](start.md)されると、`scope`は`closed-and-joining`状態に遷移する。
+- `joined` : `scope`が`open-and-joining`または`closed-and-joining`状態にあるとき関連付けカウントがゼロに到達すると、`scope`は`joined`状態に遷移する。
+
+
+### Senderアルゴリズムタグ `scope-join-t`
+説明専用の[Senderアルゴリズムタグ型](tag_of_t.md)`scope-join-t`を定義する。
+
+```cpp
+struct scope-join-t {};  // exposition only
+```
+
+Senderアルゴリズム動作説明用のクラステンプレート[`impls-for`](impls-for.md)に対して、下記の特殊化が定義される。
+
+```cpp
+namespace std::execution {
+  template&amp;lt;&amp;gt;
+  struct impls-for&amp;lt;scope-join-t&amp;gt; : default-impls {
+    template&amp;lt;class Scope, class Rcvr&amp;gt;
+    struct state {                          // exposition only
+      struct rcvr-t {                       // exposition only
+        using receiver_concept = receiver_t;
+
+        Rcvr&amp;amp; rcvr;                         // exposition only
+
+        void set_value() &amp;amp;&amp;amp; noexcept {
+          execution::set_value(std::move(rcvr));
+        }
+
+        template&amp;lt;class E&amp;gt;
+          void set_error(E&amp;amp;&amp;amp; e) &amp;amp;&amp;amp; noexcept {
+            execution::set_error(std::move(rcvr), std::forward&amp;lt;E&amp;gt;(e));
+          }
+
+        void set_stopped() &amp;amp;&amp;amp; noexcept {
+          execution::set_stopped(std::move(rcvr));
+        }
+
+        decltype(auto) get_env() const noexcept {
+          return execution::get_env(rcvr);
+        }
+      };
+
+      using sched-sender =                  // exposition only
+        decltype(schedule(get_scheduler(get_env(declval&amp;lt;Rcvr&amp;amp;&amp;gt;()))));
+      using op-t =                          // exposition only
+        connect_result_t&amp;lt;sched-sender, rcvr-t&amp;gt;;
+
+      Scope* scope;                         // exposition only
+      Rcvr&amp;amp; receiver;                       // exposition only
+      op-t op;                              // exposition only
+
+      state(Scope* scope, Rcvr&amp;amp; rcvr)       // exposition only
+        noexcept(nothrow-callable&amp;lt;connect_t, sched-sender, rcvr-t&amp;gt;)
+        : scope(scope),
+          receiver(rcvr),
+          op(connect(schedule(get_scheduler(get_env(rcvr))), rcvr-t(rcvr))) {}
+
+      void complete() noexcept {            // exposition only
+        start(op);
+      }
+
+      void complete-inline() noexcept {     // exposition only
+        set_value(std::move(receiver));
+      }
+    };
+
+    static constexpr auto get-state =       // exposition only
+      []&amp;lt;class Rcvr&amp;gt;(auto&amp;amp;&amp;amp; sender, Rcvr&amp;amp; receiver)
+        noexcept(is_nothrow_constructible_v&amp;lt;state&amp;lt;Rcvr&amp;gt;, data-type&amp;lt;decltype(sender)&amp;gt;, Rcvr&amp;amp;&amp;gt;) {
+        auto[_, self] = sender;
+        return state(self, receiver);
+      };
+
+    static constexpr auto start =           // exposition only
+      [](auto&amp;amp; s, auto&amp;amp;) noexcept {
+        if (s.scope-&amp;gt;start-join-sender(s))
+          s.complete-inline();
+      };
+  };
+}
+```
+* impls-for[link impls-for.md]
+* default-impls[link impls-for.md]
+* receiver_t[link receiver.md]
+* execution::set_value[link set_value.md]
+* execution::set_error[link set_error.md]
+* execution::set_stopped[link set_stopped.md]
+* execution::get_env[link get_env.md]
+* schedule[link schedule.md]
+* get_scheduler[link get_scheduler.md]
+* connect_result_t[link connect_result_t.md]
+* connect_t[link connect.md]
+* connect[link connect.md]
+* start[link start.md]
+* data-type[link data-type.md]
+* nothrow-callable[link /reference/functional/nothrow-callable.md]
+* is_nothrow_constructible_v[link /reference/type_traits/is_nothrow_constructible.md]
+* std::move[link /reference/utility/move.md]
+
+
+## メンバ関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`(constructor)`](simple_counting_scope/op_constructor.md.nolink) | コンストラクタ | C++26 |
+| [`(destructor)`](simple_counting_scope/op_destructor.md.nolink) | デストラクタ | C++26 |
+| [`get_token`](simple_counting_scope/get_token.md.nolink) | 非同期スコープトークンを取得 | C++26 |
+| [`close`](simple_counting_scope/close.md.nolink) | 非同期スコープを閉じる | C++26 |
+| [`join`](simple_counting_scope/join.md.nolink) | 非同期スコープを合流する[Sender](sender.md)取得 | C++26 |
+
+### 説明専用メンバ関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`try-associate`](simple_counting_scope/try-associate.md.nolink) | 関連付けを試行 | C++26 |
+| [`disassociate`](simple_counting_scope/disassociate.md.nolink) | 関連付けを解除| C++26 |
+| [`start-join-sender`](simple_counting_scope/start-join-sender.md.nolink) | 合流[Sender](sender.md)を開始 | C++26 |
+
+## メンバ型
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`token`](simple_counting_scope/token.md.nolink) | 非同期スコープトークン型 | C++26 |
+
+## 静的メンバ変数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| `constexpr size_t max_associations = implementation-defined;` | 関連付けの最大数 | C++26 |
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::counting_scope`](counting_scope.md)
+
+
+## 参照
+- [P3149R11 `async_scope` - Creating scopes for non-sequential concurrency](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r11.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>スタイル -- execution: P3149R11 scope_token(#1510)</title>
      <link href="https://cpprefjp.github.io/working_style.html"/>
      <id>a510758913f926956ab0c34fa98ee0db461f8678:working_style.md</id>
      <updated>2025-09-02T01:37:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/working_style.md b/working_style.md
index 86ed8088d..b0209396b 100644
--- a/working_style.md
+++ b/working_style.md
@@ -68,6 +68,7 @@ C++11以降対応については対応バージョンを明記します。バー
 | arithmetic type                    | 算術型                       |
 | associative container(s)           | 連想コンテナ                 |
 | asynchronous operation             | 非同期操作                   |
+| async scope                        | 非同期スコープ               |
 | base class                         | 基底クラス                   |
 | bidirectional iterator             | 双方向イテレータ             |
 | bucket                             | バケット                     |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>