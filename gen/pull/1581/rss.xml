<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2026-02-05T04:58:19.490898</updated>
  <id>ec9d3ff4-d230-4fa1-b56a-7a9f1d013a02</id>

  
    <entry>
      <title>adjacent_find -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index e9b81315a..72ce400c5 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -20,9 +20,36 @@ namespace std::ranges {
             projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;,
+            projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  I adjacent_find(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  S last,
+                  Pred pred = {},
+                  Proj proj = {});                                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    adjacent_find(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  Pred pred = {},
+                  Proj proj = {});                                  // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -30,6 +57,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 このアルゴリズムは、範囲の先頭から1つづつ進みながら隣接するペアに対して条件を満たすかをチェックし、その条件を満たす最初の要素へのイテレータを返す。指定された条件を満たしているかをチェックされるのは、現在位置にある要素とその次の位置にある要素の2つについてであり、1つの要素は最大2回参照される。
 
@@ -61,6 +90,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iterator&amp;gt;
@@ -83,13 +113,13 @@ int main() {
 * std::ranges::distance[link /reference/iterator/ranges_distance.md]
 * std::ranges::adjacent_find[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==2
 *it == *(it+1): true
 ```
 
-### 動作イメージ
+#### 動作イメージ
 
 ```
 |0  1  2  3  4  5  6| : index
@@ -102,6 +132,32 @@ found: index==2
                [2, 2]
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2};
+
+  // 並列に同じ値が連続している最初の要素を検索する
+  auto it = std::ranges::adjacent_find(std::execution::par, v);
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::adjacent_find[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct adjacent_find_impl {
@@ -144,3 +200,4 @@ inline constexpr adjacent_find_impl adjacent_find;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_all_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_all_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_all_of.md b/reference/algorithm/ranges_all_of.md
index 861c19bff..d04dd5edf 100644
--- a/reference/algorithm/ranges_all_of.md
+++ b/reference/algorithm/ranges_all_of.md
@@ -18,14 +18,40 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr bool
     all_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool all_of(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool all_of(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の全ての要素が条件を満たすかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -43,6 +69,7 @@ namespace std::ranges {
 最大で `last - first` 回 `proj` と `pred` を実行する。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -64,12 +91,37 @@ int main() {
 ```
 * std::ranges::all_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 true
 false
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 8, 10};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に全ての要素が偶数であるかを判定
+  bool result = std::ranges::all_of(std::execution::par, v,
+                                    [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::all_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct all_of_impl {
@@ -111,3 +163,4 @@ inline constexpr all_of_impl all_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_any_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_any_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_any_of.md b/reference/algorithm/ranges_any_of.md
index 25e3f53fb..4802baf5c 100644
--- a/reference/algorithm/ranges_any_of.md
+++ b/reference/algorithm/ranges_any_of.md
@@ -18,14 +18,40 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr bool
     any_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool any_of(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool any_of(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲のいずれかの要素が条件を満たすかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -45,6 +71,7 @@ namespace std::ranges {
 最大で `last - first` 回 `pred` を実行する。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -66,12 +93,37 @@ int main() {
 ```
 * std::ranges::any_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 7, 8};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にいずれかの要素が偶数であるかを判定
+  bool result = std::ranges::any_of(std::execution::par, v,
+                                    [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::any_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct any_of_impl {
@@ -114,3 +166,4 @@ inline constexpr any_of_impl any_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_contains.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains.md b/reference/algorithm/ranges_contains.md
index 761004798..ec958c6c1 100644
--- a/reference/algorithm/ranges_contains.md
+++ b/reference/algorithm/ranges_contains.md
@@ -59,14 +59,52 @@ namespace std::ranges {
     contains(R&amp;amp;&amp;amp; r,
              const T&amp;amp; value,
              Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  bool
+    contains(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  bool
+    contains(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値が含まれるか調べる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -148,6 +186,30 @@ found
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に値が含まれるかを判定
+  bool result = std::ranges::contains(std::execution::par, v, 4);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::contains[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct contains_impl {
@@ -182,3 +244,4 @@ inline constexpr contains_impl contains;
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains_subrange -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains_subrange.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_contains_subrange.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains_subrange.md b/reference/algorithm/ranges_contains_subrange.md
index 9be4d01fe..55bbe2a5b 100644
--- a/reference/algorithm/ranges_contains_subrange.md
+++ b/reference/algorithm/ranges_contains_subrange.md
@@ -6,7 +6,7 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
+  // (1) C++23
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1,
            forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
@@ -14,20 +14,43 @@ namespace std::ranges {
   constexpr bool ranges::contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                            Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
 
-  // (2)
+  // (2) C++23
   template&amp;lt;forward_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
   requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
   constexpr bool ranges::contains_subrange(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {},
                                            Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  // (3) C++26
+  template&amp;lt;execution-policy Ep,
+           random_access_iterator I1, sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+           random_access_iterator I2, sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool ranges::contains_subrange(Ep&amp;amp;&amp;amp; exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                                 Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  // (4) C++26
+  template&amp;lt;execution-policy Ep,
+           sized-random-access-range R1, sized-random-access-range R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool ranges::contains_subrange(Ep&amp;amp;&amp;amp; exec, R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {},
+                                 Proj1 proj1 = {}, Proj2 proj2 = {});
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 あるシーケンスの中に、特定のサブシーケンスが含まれるか調べる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 サブシーケンスが空の場合は、常に`true`を返す。
 
@@ -40,6 +63,7 @@ first2 == last2 || !ranges::search(first1, last1, first2, last2, pred, proj1, pr
 最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;print&amp;gt;
@@ -64,6 +88,32 @@ int main() {
 found
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; sub = {2, 3, 4};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にサブ範囲が含まれるかを判定
+  bool result = std::ranges::contains_subrange(
+    std::execution::par, v, sub);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::contains_subrange[color ff0000]
+
+#### 出力
+```
+true
+```
+
 
 ## 実装例
 ```cpp
@@ -101,3 +151,4 @@ inline constexpr contains_subrange_impl contains_subrange;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy.md b/reference/algorithm/ranges_copy.md
index 7e13c6f73..d2579c96f 100644
--- a/reference/algorithm/ranges_copy.md
+++ b/reference/algorithm/ranges_copy.md
@@ -18,18 +18,46 @@ namespace std::ranges {
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     copy(R&amp;amp;&amp;amp; r, O result);           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_result&amp;lt;I, O&amp;gt;
+    copy(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         O result,
+         OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    copy(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * copy_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素をコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -57,6 +85,7 @@ copy_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,11 +112,38 @@ int main() {
 ```
 * std::ranges::copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 3,1,2,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列にコピーする
+  std::ranges::copy(std::execution::par, src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -100,3 +156,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_copy_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_if.md b/reference/algorithm/ranges_copy_if.md
index 978a8b995..faf63d736 100644
--- a/reference/algorithm/ranges_copy_if.md
+++ b/reference/algorithm/ranges_copy_if.md
@@ -22,18 +22,54 @@ namespace std::ranges {
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_if_result&amp;lt;I, O&amp;gt;
+    copy_if(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            O result,
+            OutS result_last,
+            Pred pred,
+            Proj proj = {});                                       // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    copy_if(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            OutR&amp;amp;&amp;amp; result_r,
+            Pred pred,
+            Proj proj = {});                                       // (4) C++26
 }
 ```
 * copy_if_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素のみをコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -60,6 +96,7 @@ copy_if_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -91,6 +128,34 @@ int main() {
 3,1,1,5,9,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に偶数のみをコピーする
+  auto result = std::ranges::copy_if(std::execution::par, src, dst,
+                                     [](int x) { return x % 2 == 0; });
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy_if[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -103,3 +168,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_copy_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_n.md b/reference/algorithm/ranges_copy_n.md
index 34cb49ca2..2bb46e287 100644
--- a/reference/algorithm/ranges_copy_n.md
+++ b/reference/algorithm/ranges_copy_n.md
@@ -13,17 +13,33 @@ namespace std::ranges {
   constexpr copy_n_result&amp;lt;I, O&amp;gt;
     copy_n(I first,
            iter_difference_t&amp;lt;I&amp;gt; n,
-           O result); // (1) C++20
+           O result);                // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_n_result&amp;lt;I, O&amp;gt;
+    copy_n(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           iter_difference_t&amp;lt;I&amp;gt; n,
+           O result,
+           OutS result_last);        // (2) C++26
 }
 ```
 * copy_n_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 指定された数の要素をコピーする。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
 
 
 ## 効果
@@ -45,6 +61,7 @@ copy_n_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -67,6 +84,34 @@ int main() {
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(5);
+
+  // 並列に先頭3要素をコピー
+  std::ranges::copy_n(std::execution::par, src.begin(), 3,
+                      dst.begin(), dst.begin() + 3);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy_n[color ff0000]
+
+#### 出力
+```
+1 2 3 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -79,3 +124,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_count.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 58a13d5e8..05e78aae0 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -43,14 +43,44 @@ namespace std::ranges {
     count(R&amp;amp;&amp;amp; r,
           const T&amp;amp; value,
           Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  iter_difference_t&amp;lt;I&amp;gt;
+    count(Ep&amp;amp;&amp;amp; exec,
+          I first,
+          S last,
+          const T&amp;amp; value,
+          Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  range_difference_t&amp;lt;R&amp;gt;
+    count(Ep&amp;amp;&amp;amp; exec,
+          R&amp;amp;&amp;amp; r,
+          const T&amp;amp; value,
+          Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値と等値な要素の数を数える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -170,6 +200,28 @@ count of id==1: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2, 1};
+
+  // 並列に値が 1 の要素がいくつあるかを数える
+  auto n = std::ranges::count(std::execution::par, v, 1);
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of 1: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count[color ff0000]
+
+#### 出力
+```
+count of 1: 3
+```
+
 ## 実装例
 ```cpp
 struct count_impl {
@@ -210,3 +262,4 @@ inline constexpr count_impl count;
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_count_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 265ff9c5a..3aa760e14 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -18,8 +18,34 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr range_difference_t&amp;lt;R&amp;gt;
     count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  iter_difference_t&amp;lt;I&amp;gt;
+    count_if(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             Pred pred,
+             Proj proj = {});                             // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  range_difference_t&amp;lt;R&amp;gt;
+    count_if(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             Pred pred,
+             Proj proj = {});                             // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -27,6 +53,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -47,6 +75,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -62,12 +91,35 @@ int main() {
 ```
 * std::ranges::count_if[color ff0000]
 
-### 出力
+#### 出力
 ```cpp
 count of 1 or 3: 5
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2, 1};
+
+  // 並列に値が偶数の要素がいくつあるかを数える
+  auto n = std::ranges::count_if(std::execution::par, v,
+                                 [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of even: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count_if[color ff0000]
+
+#### 出力
+```
+count of even: 3
+```
+
 ## 実装例
 ```cpp
 struct count_if_impl {
@@ -104,3 +156,4 @@ inline constexpr count_if_impl count_if;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ends_with -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_ends_with.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_ends_with.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_ends_with.md b/reference/algorithm/ranges_ends_with.md
index 4b15e622c..a5e321787 100644
--- a/reference/algorithm/ranges_ends_with.md
+++ b/reference/algorithm/ranges_ends_with.md
@@ -39,9 +39,46 @@ namespace std::ranges {
               Pred pred = {},
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool
+    ends_with(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool
+    ends_with(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -49,6 +86,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 
@@ -66,6 +105,7 @@ namespace std::ranges {
 最大で `N2` 回の対応する述語が適用される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,7 +123,7 @@ int main() {
 ```
 * std::ranges::ends_with[color ff0000]
 
-### 出力
+#### 出力
 ```
 0
 0
@@ -91,6 +131,31 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; suffix = {4, 5, 6};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に末尾が一致するかを判定
+  bool result = std::ranges::ends_with(std::execution::par, v, suffix);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::ends_with[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct ends_with_impl {
@@ -138,3 +203,4 @@ inline constexpr ends_with_impl ends_with;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_equal.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index d3a0c6d14..2493dbde1 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -35,14 +35,52 @@ namespace std::ranges {
           Pred pred = {},
           Proj1 proj1 = {},
           Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool equal(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool equal(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つの範囲を等値比較する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 2つの範囲の要素数および各要素が等値であった場合、`true`を返す。
 
@@ -57,6 +95,7 @@ namespace std::ranges {
 最大で `min(last1 - first1, last2 - first2)` 回の述語が適用される。ただし、2つの範囲の長さを定数時間で求められ、かつ、長さが異なる場合、1 度も述語は適用されない。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -79,13 +118,38 @@ int main() {
 ```
 * std::ranges::equal[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {1, 2, 3, 4, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に2つの範囲が等しいかを判定
+  bool result = std::ranges::equal(std::execution::par, v1, v2);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::equal[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 
 ```cpp
@@ -130,3 +194,4 @@ inline constexpr equal_impl equal;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_fill.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill.md b/reference/algorithm/ranges_fill.md
index 2c2985e6b..3987beacd 100644
--- a/reference/algorithm/ranges_fill.md
+++ b/reference/algorithm/ranges_fill.md
@@ -10,32 +10,58 @@ namespace std::ranges {
             output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
             sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
   constexpr O
-    fill(O first, S last, const T&amp;amp; value); // (1) C++20
+    fill(O first, S last, const T&amp;amp; value);           // (1) C++20
   template &amp;lt;class I,
             sentinel_for&amp;lt;O&amp;gt; S,
             class T = iter_value_t&amp;lt;O&amp;gt;&amp;gt;
     requires output_iterator&amp;lt;O, const T&amp;amp;&amp;gt;
   constexpr O
-    fill(O first, S last, const T&amp;amp; value); // (1) C++26
+    fill(O first, S last, const T&amp;amp; value);           // (1) C++26
 
   template &amp;lt;class T,
             output_range&amp;lt;const T&amp;amp;&amp;gt; R&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
-    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++20
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);                     // (2) C++20
   template &amp;lt;class R,
             class T = range_value_t&amp;lt;R&amp;gt;&amp;gt;
     requires output_range&amp;lt;R, const T&amp;amp;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
-    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++26
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);                     // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;O, const T&amp;amp;&amp;gt;
+  O fill(Ep&amp;amp;&amp;amp; exec,
+         O first,
+         S last,
+         const T&amp;amp; value);                            // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    fill(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value);                            // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値で出力の範囲に書き込む。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -118,6 +144,32 @@ int main() {
 1,2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(10);
+
+  // 並列に全要素を42で埋める
+  std::ranges::fill(std::execution::par, v, 42);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::fill[color ff0000]
+
+#### 出力
+```
+42 42 42 42 42 42 42 42 42 42
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -132,3 +184,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_fill_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill_n.md b/reference/algorithm/ranges_fill_n.md
index dfca5a816..64bfa0c80 100644
--- a/reference/algorithm/ranges_fill_n.md
+++ b/reference/algorithm/ranges_fill_n.md
@@ -11,20 +11,35 @@ namespace std::ranges {
   constexpr O
     fill_n(O first,
            iter_difference_t&amp;lt;O&amp;gt; n,
-           const T&amp;amp; value);   // (1) C++20
+           const T&amp;amp; value);             // (1) C++20
   template &amp;lt;class O,
             class T = iter_value_t&amp;lt;O&amp;gt;&amp;gt;
     requires output_iterator&amp;lt;O, const T&amp;amp;&amp;gt;
   constexpr O
     fill_n(O first,
            iter_difference_t&amp;lt;O&amp;gt; n,
-           const T&amp;amp; value);   // (1) C++26
+           const T&amp;amp; value);             // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;O, const T&amp;amp;&amp;gt;
+  O fill_n(Ep&amp;amp;&amp;amp; exec,
+           O first,
+           iter_difference_t&amp;lt;O&amp;gt; n,
+           const T&amp;amp; value);             // (2) C++26
 }
 ```
+* indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 指定された値で出力の範囲に `n` 個を書き込む。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## 効果
 `n` が 1 以上の場合は `[first,first + n)` 内の全ての要素に `value` を代入し、そうでない場合は何もしない。
@@ -102,6 +117,32 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(5);
+
+  // 並列に先頭3要素を42で埋める
+  std::ranges::fill_n(std::execution::par, v.begin(), 3, 42);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::fill_n[color ff0000]
+
+#### 出力
+```
+42 42 42 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +157,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 8823240a0..67daa20d7 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -43,15 +43,44 @@ namespace std::ranges {
     find(R&amp;amp;&amp;amp; r,
          const T&amp;amp; value,
          Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  I find(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         const T&amp;amp; value,
+         Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value,
+         Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -186,6 +215,29 @@ int main() {
 found: 3,4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に値を検索する
+  auto it = std::ranges::find(std::execution::par, v, 5);
+  if (it != v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find[color ff0000]
+
+#### 出力
+```
+found: 5
+```
 
 ## 実装例
 ```cpp
@@ -226,3 +278,4 @@ inline constexpr find_impl find;
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_end.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
index 6369dfd7e..8d6310f30 100644
--- a/reference/algorithm/ranges_find_end.md
+++ b/reference/algorithm/ranges_find_end.md
@@ -35,14 +35,54 @@ namespace std::ranges {
              Pred pred = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  subrange&amp;lt;I1&amp;gt;
+    find_end(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_subrange_t&amp;lt;R1&amp;gt;
+    find_end(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、特定のサブシーケンスを検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -61,6 +101,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -85,12 +126,39 @@ int main() {
 ```
 * std::ranges::find_end[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==2
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 1, 2, 3};
+  std::vector&amp;lt;int&amp;gt; pattern = {1, 2};
+
+  // 並列にサブシーケンスを末尾から検索する
+  auto sr = std::ranges::find_end(std::execution::par, v, pattern);
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_end[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct find_end_impl {
@@ -130,3 +198,4 @@ inline constexpr find_end_impl find_end;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index a4beb961a..db300c21b 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -35,15 +35,55 @@ namespace std::ranges {
                   Pred pred = {},
                   Proj1 proj1 = {},
                   Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  I1
+    find_first_of(Ep&amp;amp;&amp;amp; exec,
+                  I1 first1,
+                  S1 last1,
+                  I2 first2,
+                  S2 last2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_iterator_t&amp;lt;R1&amp;gt;
+    find_first_of(Ep&amp;amp;&amp;amp; exec,
+                  R1&amp;amp;&amp;amp; r1,
+                  R2&amp;amp;&amp;amp; r2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 ある集合の1つとマッチする最初の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -57,6 +97,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -78,12 +119,40 @@ int main() {
 ```
 * std::ranges::find_first_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==3, value==4
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 7, 4, 2};
+  std::vector&amp;lt;int&amp;gt; targets = {2, 4, 6, 8};
+
+  // 並列に targets のいずれかと一致する最初の要素を検索する
+  auto it = std::ranges::find_first_of(std::execution::par, v, targets);
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it)
+              &amp;lt;&amp;lt; &amp;#34;, value==&amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_first_of[color ff0000]
+
+#### 出力
+```
+found: index==3, value==4
+```
+
 ## 実装例
 ```cpp
 struct find_first_of_impl {
@@ -124,3 +193,4 @@ inline constexpr find_first_of_impl find_first_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index e6cf396a7..bd5d39c34 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -23,15 +23,42 @@ namespace std::ranges {
     find_if(R&amp;amp;&amp;amp; r,
             Pred pred,
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  I find_if(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            Pred pred,
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            Pred pred,
+            Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たす最初の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -61,12 +89,39 @@ int main() {
 ```
 * std::ranges::find_if[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9};
+
+  // 並列に5以上の最初の要素を検索する
+  auto result = std::ranges::find_if(std::execution::par, v,
+                                     [](int x) { return x &amp;gt;= 5; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if[color ff0000]
+
+#### 出力
+```
+found: 5
+```
+
 ## 実装例
 ```cpp
 struct find_if_impl {
@@ -103,3 +158,4 @@ inline constexpr find_if_impl find_if;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 250693822..edee510d5 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -23,15 +23,42 @@ namespace std::ranges {
     find_if_not(R&amp;amp;&amp;amp; r,
                 Pred pred,
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  I find_if_not(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Pred pred,
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if_not(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Pred pred,
+                Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たさない最初の要素を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -61,12 +89,39 @@ int main() {
 ```
 * std::ranges::find_if_not[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 5, 6, 8};
+
+  // 並列に偶数でない最初の要素を検索する
+  auto result = std::ranges::find_if_not(std::execution::par, v,
+                                         [](int x) { return x % 2 == 0; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if_not[color ff0000]
+
+#### 出力
+```
+found: 5
+```
+
 ## 実装例
 ```cpp
 struct find_if_not_impl {
@@ -103,3 +158,4 @@ inline constexpr find_if_not_impl find_if_not;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_last.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last.md b/reference/algorithm/ranges_find_last.md
index 228a6d65f..41a33158c 100644
--- a/reference/algorithm/ranges_find_last.md
+++ b/reference/algorithm/ranges_find_last.md
@@ -59,14 +59,52 @@ namespace std::ranges {
     find_last(R&amp;amp;&amp;amp; r,
               const T&amp;amp; value,
               Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              const T&amp;amp; value,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              const T&amp;amp; value,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を末尾から検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -153,6 +191,33 @@ found: 3,4
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 3, 7};
+
+  // 並列に最後の3を検索
+  auto result = std::ranges::find_last(std::execution::par, v, 3);
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last[color ff0000]
+
+#### 出力
+```
+found: 3
+position: 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -169,3 +234,4 @@ found: 3,4
     - C++26で波カッコ初期化 (リスト初期化) に対応した
     - 関連文書：
         - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_last_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last_if.md b/reference/algorithm/ranges_find_last_if.md
index 3364c92a8..83e9417b7 100644
--- a/reference/algorithm/ranges_find_last_if.md
+++ b/reference/algorithm/ranges_find_last_if.md
@@ -23,14 +23,42 @@ namespace std::ranges {
     find_last_if(R&amp;amp;&amp;amp; r,
                  Pred pred,
                  Proj proj = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last_if(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 Pred pred,
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last_if(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 Pred pred,
+                 Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たす最後の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -42,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -60,12 +89,40 @@ int main() {
 ```
 * std::ranges::find_last_if[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 6, 5};
+
+  // 並列に最後の偶数を検索
+  auto result = std::ranges::find_last_if(std::execution::par, v,
+                                          [](int x) { return x % 2 == 0; });
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last_if[color ff0000]
+
+#### 出力
+```
+found: 6
+position: 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -78,3 +135,4 @@ found: 1
 
 ## 参照
 - [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last_if_not -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last_if_not.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_last_if_not.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last_if_not.md b/reference/algorithm/ranges_find_last_if_not.md
index fbbc83a07..5d7e3e689 100644
--- a/reference/algorithm/ranges_find_last_if_not.md
+++ b/reference/algorithm/ranges_find_last_if_not.md
@@ -23,14 +23,42 @@ namespace std::ranges {
     find_last_if_not(R&amp;amp;&amp;amp; r,
                      Pred pred,
                      Proj proj = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last_if_not(Ep&amp;amp;&amp;amp; exec,
+                     I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last_if_not(Ep&amp;amp;&amp;amp; exec,
+                     R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たさない最後の要素を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -42,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -60,12 +89,40 @@ int main() {
 ```
 * std::ranges::find_last_if_not[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 3, 6, 8};
+
+  // 並列に最後の偶数でない要素を検索
+  auto result = std::ranges::find_last_if_not(std::execution::par, v,
+                                              [](int x) { return x % 2 == 0; });
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last_if_not[color ff0000]
+
+#### 出力
+```
+found: 3
+position: 2
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -78,3 +135,4 @@ found: 1
 
 ## 参照
 - [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_for_each.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 8638277ae..8617440cf 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -23,11 +23,36 @@ namespace std::ranges {
     for_each(R&amp;amp;&amp;amp; r,
              Fun f,
              Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  I for_each(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             Fun f,
+             Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    for_each(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             Fun f,
+             Proj proj = {}); // (4) C++26
 }
 ```
 * indirectly_unary_invocable[link /reference/iterator/indirectly_unary_invocable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 * for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +60,8 @@ namespace std::ranges {
 
 * (1): イテレータ範囲を指定する
 * (2): Rangeを直接指定する
+* (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+* (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -54,14 +81,16 @@ namespace std::ranges {
 
 
 ## 戻り値
+- (1), (2):
+    ```cpp
+    for_each_result {
+      .in = last,
+      .fun = std::move(f),
+    }
+    ```
+    * for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
 
-```cpp
-for_each_result {
-  .in = last,
-  .fun = std::move(f),
-}
-```
-* for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
+- (3), (4): `last`
 
 ## 計算量
 正確に `f` を `last - first` 回適用する
@@ -72,7 +101,7 @@ for_each_result {
 
 
 ## 例
-
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -105,6 +134,35 @@ int main() {
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に全ての要素を2倍にする
+  std::ranges::for_each(std::execution::par, v, [](int&amp;amp; x) { x *= 2; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::for_each[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
+## バージョン
+### 言語
+- C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
@@ -112,7 +170,6 @@ int main() {
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 10 [mark verified]
 
-
 ## 実装例
 ```cpp
 struct for_each_impl {
@@ -142,3 +199,4 @@ inline constexpr for_each_impl for_each;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index 7095a7aeb..241ab8d8a 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -14,14 +14,29 @@ namespace std::ranges {
                iter_difference_t&amp;lt;I&amp;gt; n,
                Fun f,
                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  I for_each_n(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               iter_difference_t&amp;lt;I&amp;gt; n,
+               Fun f,
+               Proj proj = {}); // (2) C++26
 }
 ```
 * indirectly_unary_invocable[link /reference/iterator/indirectly_unary_invocable.md]
 * for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 範囲の先頭N個の要素に、指定された関数を適用する。
 
+- (1): 通常版
+- (2): 並列アルゴリズム版。実行ポリシーを指定する
+
 ## テンプレートパラメータ制約
 - `I`が[`input_iterator`](/reference/iterator/input_iterator.md)である
 - `Fun`は`I`を`Proj`で射影した値を受け取る[1引数の`invocable`](/reference/iterator/indirectly_unary_invocable.md)である
@@ -38,18 +53,22 @@ namespace std::ranges {
 このアルゴリズムはその他のアルゴリズムと違い、[`invoke`](/reference/functional/invoke.md)`(proj, *i)` が書き換え可能な参照であれば、関数 `f` の内部でその値を書き換えても構わない。
 
 ## 戻り値
-```cpp
-for_each_n_result {
-  .in = first + n,
-  .fun = std::move(f)
-}
-```
-* for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+- (1):
+    ```cpp
+    for_each_n_result {
+      .in = first + n,
+      .fun = std::move(f)
+    }
+    ```
+    * for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+
+- (2): `first + n`
 
 ## 備考
 - 関数 `f` に戻り値がある場合、それは単に無視される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -84,6 +103,33 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に先頭3要素を出力
+  std::ranges::for_each_n(std::execution::par, v.begin(), 3,
+                          [](int x) { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;; });
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::for_each_n[color ff0000]
+
+#### 出力例
+```
+1 2 3
+```
+
+## バージョン
+### 言語
+- C++20
+
 ### 処理系
 - [Clang](/implementation.md#clang): ??
 - [GCC](/implementation.md#gcc): 10.1.0 [mark verified]
@@ -113,3 +159,4 @@ inline constexpr for_each_n_impl for_each_n;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_generate.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate.md b/reference/algorithm/ranges_generate.md
index 45d70770d..0ccfffdd4 100644
--- a/reference/algorithm/ranges_generate.md
+++ b/reference/algorithm/ranges_generate.md
@@ -13,25 +13,50 @@ namespace std::ranges {
   constexpr O
     generate(O first,
              S last,
-             F gen); // (1) C++20
+             F gen);                  // (1) C++20
 
   template &amp;lt;class R,
             copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; output_range&amp;lt;R, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     generate(R&amp;amp;&amp;amp; r,
-             F gen); // (2) C++20
+             F gen);                  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  O generate(Ep&amp;amp;&amp;amp; exec,
+             O first,
+             S last,
+             F gen);                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    generate(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             F gen);                  // (4) C++26
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 出力の範囲へ関数の結果を書き込む。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -47,6 +72,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -71,6 +97,32 @@ int main() {
 1,2,4,8,16,32,64,128,256,512,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(10);
+
+  // 並列に全要素を99で埋める
+  std::ranges::generate(std::execution::par, v, [] { return 99; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::generate[color ff0000]
+
+#### 出力
+```
+99 99 99 99 99 99 99 99 99 99
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -83,3 +135,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_generate_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate_n.md b/reference/algorithm/ranges_generate_n.md
index 6f06cec13..56f5f2c9d 100644
--- a/reference/algorithm/ranges_generate_n.md
+++ b/reference/algorithm/ranges_generate_n.md
@@ -13,15 +13,29 @@ namespace std::ranges {
     generate_n(O first,
                iter_difference_t&amp;lt;O&amp;gt; n,
                F gen);                  // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  O generate_n(Ep&amp;amp;&amp;amp; exec,
+               O first,
+               iter_difference_t&amp;lt;O&amp;gt; n,
+               F gen);                  // (2) C++26
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 
 ## 概要
 出力の範囲へ関数の結果を `n` 個書き込む。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## 効果
 `n` が 1 以上の場合、`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
@@ -41,6 +55,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -59,6 +74,35 @@ int main() {
 1,2,4,8,16,32,64,128,256,512,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(5);
+
+  // 並列に値を生成して書き込む
+  std::atomic&amp;lt;int&amp;gt; counter{0};
+  std::ranges::generate_n(std::execution::par, v.begin(), 5,
+                          [&amp;amp;counter] { return counter++; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::generate_n[color ff0000]
+
+#### 出力例
+```
+0 1 2 3 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -71,3 +115,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_in_out_result -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_in_out_result.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_in_in_out_result.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_in_out_result.md b/reference/algorithm/ranges_in_in_out_result.md
index 4939125fe..095b4a90f 100644
--- a/reference/algorithm/ranges_in_in_out_result.md
+++ b/reference/algorithm/ranges_in_in_out_result.md
@@ -3,7 +3,7 @@
 * std::ranges[meta namespace]
 * class template[meta id-type]
 * cpp20[meta cpp]
-* binary_transform_result,merge_result,set_union_result,set_intersection_result,set_symmetric_difference_result[meta alias]
+* binary_transform_result,merge_result,set_union_result,set_intersection_result,set_symmetric_difference_result,reverse_copy_truncated_result,rotate_copy_truncated_result[meta alias]
 
 ```cpp
 namespace std::ranges {
@@ -50,6 +50,14 @@ namespace std::ranges {
   // (6)
   template&amp;lt;class I1, class I2, class O&amp;gt;
   using set_symmetric_difference_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  // (7) C++26
+  template&amp;lt;class I, class O&amp;gt;
+  using reverse_copy_truncated_result = in_in_out_result&amp;lt;I, I, O&amp;gt;;
+
+  // (8) C++26
+  template&amp;lt;class I, class O&amp;gt;
+  using rotate_copy_truncated_result = in_in_out_result&amp;lt;I, I, O&amp;gt;;
 }
 ```
 * no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
@@ -62,6 +70,8 @@ namespace std::ranges {
 * (4): [`ranges::set_union`](ranges_set_union.md)で使用するエイリアス
 * (5): [`ranges::set_intersection`](ranges_set_intersection.md)で使用するエイリアス
 * (6): [`ranges::set_symmetric_difference`](ranges_set_symmetric_difference.md)で使用するエイリアス
+* (7): [`ranges::reverse_copy`](ranges_reverse_copy.md)の並列アルゴリズム版で使用するエイリアス (C++26)
+* (8): [`ranges::rotate_copy`](ranges_rotate_copy.md)の並列アルゴリズム版で使用するエイリアス (C++26)
 
 この型は、関数が2つの入力用の範囲と出力用の範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
 
@@ -125,3 +135,5 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_includes.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_includes.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_includes.md b/reference/algorithm/ranges_includes.md
index 41e5babb6..403ec100f 100644
--- a/reference/algorithm/ranges_includes.md
+++ b/reference/algorithm/ranges_includes.md
@@ -39,16 +39,60 @@ namespace std::ranges {
              Comp comp = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    includes(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    includes(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 `[first2,last2)` が `empty` であるか、`[first2,last2)` の全ての要素が `[first1,last1)` に含まれている場合は `true`、そうでない場合は `false` を返す。
@@ -59,6 +103,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -84,6 +129,34 @@ true
 false
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6};
+  std::vector&amp;lt;int&amp;gt; c = {2, 4, 7};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にaがbの全要素を含むか判定する
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(std::execution::par, a, b) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(std::execution::par, a, c) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::includes[color ff0000]
+
+#### 出力
+```
+true
+false
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +169,4 @@ false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_inplace_merge.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_inplace_merge.md b/reference/algorithm/ranges_inplace_merge.md
index 58cfe9bb4..5d12106d2 100644
--- a/reference/algorithm/ranges_inplace_merge.md
+++ b/reference/algorithm/ranges_inplace_merge.md
@@ -47,17 +47,49 @@ namespace std::ranges {
                   iterator_t&amp;lt;R&amp;gt; middle,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I
+    inplace_merge(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  I middle,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    inplace_merge(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  iterator_t&amp;lt;R&amp;gt; middle,
+                  Comp comp = {},
+                  Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つの連続したソート済み範囲をマージする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` の範囲はそれぞれソートされていること。
@@ -83,6 +115,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -112,6 +145,34 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 2, 4, 6};
+
+  // 並列にインプレースマージ
+  // [1,3,5) と [2,4,6) をマージ
+  std::ranges::inplace_merge(std::execution::par,
+                             v, v.begin() + 3);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::inplace_merge[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6
+```
+
 ## 実装例
 - [`inplace_merge` を読んでみた](http://www.kmonos.net/wlog/115.html#_2300101215)
 
@@ -129,3 +190,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_heap.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap.md b/reference/algorithm/ranges_is_heap.md
index 35abb8e9f..394cfad5d 100644
--- a/reference/algorithm/ranges_is_heap.md
+++ b/reference/algorithm/ranges_is_heap.md
@@ -23,16 +23,44 @@ namespace std::ranges {
     is_heap(R&amp;amp;&amp;amp; r,
             Comp comp = {},
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    is_heap(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            Comp comp = {},
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    is_heap(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            Comp comp = {},
+            Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲がヒープ化されているか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -40,6 +68,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -68,6 +97,36 @@ before: is heap? false
  after: is heap? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::make_heap(v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+
+#### 出力
+```
+before: is heap? false
+ after: is heap? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -80,3 +139,4 @@ before: is heap? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap_until.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_heap_until.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap_until.md b/reference/algorithm/ranges_is_heap_until.md
index d96bc5c22..ae1148984 100644
--- a/reference/algorithm/ranges_is_heap_until.md
+++ b/reference/algorithm/ranges_is_heap_until.md
@@ -23,16 +23,44 @@ namespace std::ranges {
     is_heap_until(R&amp;amp;&amp;amp; r,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I is_heap_until(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_heap_until(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  Comp comp = {},
+                  Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -44,6 +72,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -66,12 +95,39 @@ int main()
 * std::ranges::is_heap_until[color ff0000]
 * std::ranges::make_heap[link ranges_make_heap.md]
 
-### 出力
+#### 出力
 ```
 before: is heap? false
  after: is heap? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {9, 5, 7, 3, 1, 2, 4};
+
+  // 並列にヒープ条件を満たさなくなる位置を検索
+  auto it = std::ranges::is_heap_until(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;heap part: &amp;#34;;
+  for (auto i = v.begin(); i != it; ++i) {
+    std::cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap_until[color ff0000]
+
+#### 出力
+```
+heap part: 9 5 7 3 1 2 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -84,3 +140,4 @@ before: is heap? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_partitioned.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_partitioned.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_partitioned.md b/reference/algorithm/ranges_is_partitioned.md
index ffff76a49..d620305c0 100644
--- a/reference/algorithm/ranges_is_partitioned.md
+++ b/reference/algorithm/ranges_is_partitioned.md
@@ -23,14 +23,40 @@ namespace std::ranges {
     is_partitioned(R&amp;amp;&amp;amp; r,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool is_partitioned(Ep&amp;amp;&amp;amp; exec,
+                      I first,
+                      S last,
+                      Pred pred,
+                      Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool is_partitioned(Ep&amp;amp;&amp;amp; exec,
+                      R&amp;amp;&amp;amp; r,
+                      Pred pred,
+                      Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -44,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -84,6 +111,33 @@ int main()
 partitioned
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 1, 3, 5};
+
+  auto pred = [](int x) { return x % 2 == 0; };
+
+  // 並列に偶数グループと奇数グループに分かれているか判定する
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;is partitioned? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_partitioned(std::execution::par, v, pred)
+            &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_partitioned[color ff0000]
+
+#### 出力
+```
+is partitioned? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +150,4 @@ partitioned
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_sorted.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted.md b/reference/algorithm/ranges_is_sorted.md
index b5bf9efb0..cedf3488a 100644
--- a/reference/algorithm/ranges_is_sorted.md
+++ b/reference/algorithm/ranges_is_sorted.md
@@ -23,16 +23,42 @@ namespace std::ranges {
     is_sorted(R&amp;amp;&amp;amp; r,
               Comp comp = {},
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool is_sorted(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool is_sorted(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 Comp comp = {},
+                 Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲がソート済みか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ### 戻り値
@@ -40,6 +66,7 @@ namespace std::ranges {
 - (2) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(r, comp, proj) == last`
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -66,6 +93,36 @@ before: is sorted? false
  after: is sorted? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_sorted(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::sort(v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_sorted(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_sorted[color ff0000]
+* std::ranges::sort[link ranges_sort.md]
+
+#### 出力
+```
+before: is sorted? false
+ after: is sorted? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -78,3 +135,4 @@ before: is sorted? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted_until.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_sorted_until.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted_until.md b/reference/algorithm/ranges_is_sorted_until.md
index d01cf16df..b92c0af1c 100644
--- a/reference/algorithm/ranges_is_sorted_until.md
+++ b/reference/algorithm/ranges_is_sorted_until.md
@@ -23,17 +23,44 @@ namespace std::ranges {
     is_sorted_until(R&amp;amp;&amp;amp; r,
                     Comp comp = {},
                     Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I is_sorted_until(Ep&amp;amp;&amp;amp; exec,
+                    I first,
+                    S last,
+                    Comp comp = {},
+                    Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_sorted_until(Ep&amp;amp;&amp;amp; exec,
+                    R&amp;amp;&amp;amp; r,
+                    Comp comp = {},
+                    Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 ソート済みか判定し、ソートされていない位置のイテレータを取得する
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 [`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
@@ -44,6 +71,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -72,6 +100,33 @@ before: is sorted? false
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 5, 4, 6};
+
+  // 並列にソート済み範囲の終端を取得する
+  auto it = std::ranges::is_sorted_until(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;sorted until: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;sorted range size: &amp;#34; &amp;lt;&amp;lt; (it - v.begin()) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_sorted_until[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力
+```
+sorted until: 4
+sorted range size: 4
+```
+
 ## 実装例
 ```cpp
 
@@ -115,3 +170,4 @@ inline constexpr is_sorted_until_impl is_sorted_until;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lexicographical_compare.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_lexicographical_compare.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lexicographical_compare.md b/reference/algorithm/ranges_lexicographical_compare.md
index 80fb24448..059fcca8d 100644
--- a/reference/algorithm/ranges_lexicographical_compare.md
+++ b/reference/algorithm/ranges_lexicographical_compare.md
@@ -40,16 +40,58 @@ namespace std::ranges {
                             Comp comp = {},
                             Proj1 proj1 = {},
                             Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool lexicographical_compare(Ep&amp;amp;&amp;amp; exec,
+                               I1 first1,
+                               S1 last1,
+                               I2 first2,
+                               S2 last2,
+                               Comp comp = {},
+                               Proj1 proj1 = {},
+                               Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool lexicographical_compare(Ep&amp;amp;&amp;amp; exec,
+                               R1&amp;amp;&amp;amp; r1,
+                               R2&amp;amp;&amp;amp; r2,
+                               Comp comp = {},
+                               Proj1 proj1 = {},
+                               Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 ```cpp
@@ -76,6 +118,7 @@ return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;string&amp;gt;
@@ -136,6 +179,36 @@ x less than y
 x less than y
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; b = {1, 2, 3, 4, 6};
+
+  // 並列に辞書式比較を行う
+  bool result = std::ranges::lexicographical_compare(
+    std::execution::par,
+    a,
+    b
+  );
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;a &amp;lt; b: &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::lexicographical_compare[color ff0000]
+
+#### 出力
+```
+a &amp;lt; b: true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -148,3 +221,4 @@ x less than y
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_max.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max.md b/reference/algorithm/ranges_max.md
index 32ca3a62f..8fa065d48 100644
--- a/reference/algorithm/ranges_max.md
+++ b/reference/algorithm/ranges_max.md
@@ -31,12 +31,25 @@ namespace std::ranges {
     max(R&amp;amp;&amp;amp; r,
         Comp comp = {},
         Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  range_value_t&amp;lt;R&amp;gt;
+    max(Ep&amp;amp;&amp;amp; exec,
+        R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最大値を取得する。
@@ -44,6 +57,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -53,6 +67,7 @@ namespace std::ranges {
 - 等価な要素が 2 つ以上あった場合には、最も左の要素を返す。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -90,6 +105,28 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`
 - `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`max`マクロが定義されなくなる。
 - `std::ranges::max()`を呼び出す際に、`(std::ranges::max)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::max()`関数が必ず使用される。
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最大値を取得
+  int result = std::ranges::max(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::max[color ff0000]
+
+#### 出力
+```
+9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -102,3 +139,4 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_max_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
index eebec0f04..88e4a3e42 100644
--- a/reference/algorithm/ranges_max_element.md
+++ b/reference/algorithm/ranges_max_element.md
@@ -23,17 +23,44 @@ namespace std::ranges {
     max_element(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I max_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    max_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 [`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -70,6 +98,30 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最大要素を検索する
+  auto it = std::ranges::max_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;max: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::max_element[color ff0000]
+
+#### 出力
+```
+max: 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -82,3 +134,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_merge.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index 739eace4e..83440d5a8 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -43,6 +43,50 @@ namespace std::ranges {
           Comp comp = {},
           Proj1 proj1 = {},
           Proj2 proj2 = {});  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  merge_result&amp;lt;I1, I2, O&amp;gt;
+    merge(Ep&amp;amp;&amp;amp; exec,
+          I1 first1,
+          S1 last1,
+          I2 first2,
+          S2 last2,
+          O result,
+          OutS result_last,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  merge_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;,
+    borrowed_iterator_t&amp;lt;OutR&amp;gt;
+  &amp;gt;
+    merge(Ep&amp;amp;&amp;amp; exec,
+          R1&amp;amp;&amp;amp; r1,
+          R2&amp;amp;&amp;amp; r2,
+          OutR&amp;amp;&amp;amp; result_r,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * merge_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲をマージして、出力イテレータへ出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -85,6 +135,7 @@ merge_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -122,6 +173,35 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 3, 5, 7};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6, 8};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列に2つのソート済み範囲をマージする
+  std::ranges::merge(std::execution::par, a, b, result);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::merge[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6 7 8
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -134,3 +214,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_min.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min.md b/reference/algorithm/ranges_min.md
index f3ec69f0d..49775810a 100644
--- a/reference/algorithm/ranges_min.md
+++ b/reference/algorithm/ranges_min.md
@@ -31,12 +31,25 @@ namespace std::ranges {
     min(R&amp;amp;&amp;amp; r,
         Comp comp = {},
         Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  range_value_t&amp;lt;R&amp;gt;
+    min(Ep&amp;amp;&amp;amp; exec,
+        R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値を取得する。
@@ -44,6 +57,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -54,6 +68,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -91,6 +106,28 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`
 - `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`min`マクロが定義されなくなる。
 - `std::ranges::min()`を呼び出す際に、`(std::ranges::min)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::min()`が必ず使用される。
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小値を取得
+  int result = std::ranges::min(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::min[color ff0000]
+
+#### 出力
+```
+1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -103,3 +140,4 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_min_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
index e7c039f0f..67b5dc891 100644
--- a/reference/algorithm/ranges_min_element.md
+++ b/reference/algorithm/ranges_min_element.md
@@ -23,11 +23,36 @@ namespace std::ranges {
     min_element(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I min_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    min_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +60,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -46,6 +73,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -73,6 +101,30 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小要素を検索する
+  auto it = std::ranges::min_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;min: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::min_element[color ff0000]
+
+#### 出力
+```
+min: 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -85,3 +137,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_minmax.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
index 2f678c217..22b63c906 100644
--- a/reference/algorithm/ranges_minmax.md
+++ b/reference/algorithm/ranges_minmax.md
@@ -31,6 +31,17 @@ namespace std::ranges {
     minmax(R&amp;amp;&amp;amp; r,
            Comp comp = {},
            Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           Comp comp = {},
+           Proj proj = {}); // (4) C++26
 }
 ```
 * minmax_result[link ranges_min_max_result.md]
@@ -38,6 +49,8 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
@@ -45,6 +58,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -63,6 +77,7 @@ minmax_result {
 - 範囲バージョンは高々`(3/2) * t.size()`回の述語適用。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -93,6 +108,28 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小値と最大値を取得
+  auto [min_val, max_val] = std::ranges::minmax(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; min_val &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; max_val &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::minmax[color ff0000]
+
+#### 出力
+```
+1, 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +142,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index a243db083..332cc08d7 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -23,12 +23,38 @@ namespace std::ranges {
     minmax_element(R&amp;amp;&amp;amp; r,
                    Comp comp = {},
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  minmax_element_result&amp;lt;I&amp;gt;
+    minmax_element(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   Comp comp = {},
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax_element(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   Comp comp = {},
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * minmax_element_result[link ranges_min_max_result.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -36,6 +62,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -53,6 +81,7 @@ minmax_element_result {
 `n` を範囲の要素数とする場合、[`max`](max.md)`(floor(3(n - 1) / 2), 0)` 回の述語適用を行う。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;cassert&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -77,6 +106,32 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小要素と最大要素を同時に検索する
+  auto [min_it, max_it] = std::ranges::minmax_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;min: &amp;#34; &amp;lt;&amp;lt; *min_it &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;max: &amp;#34; &amp;lt;&amp;lt; *max_it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::minmax_element[color ff0000]
+
+#### 出力
+```
+min: 1
+max: 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -89,3 +144,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_mismatch.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index e45983580..0d062d1d1 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -38,10 +38,51 @@ namespace std::ranges {
              Pred pred = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  mismatch_result&amp;lt;I1, I2&amp;gt;
+    mismatch(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  mismatch_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;
+  &amp;gt;
+    mismatch(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * mismatch_result[link ranges_in_in_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -49,6 +90,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -66,6 +109,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -107,7 +151,7 @@ int main() {
 * std::ranges::mismatch[color ff0000]
 * std::to_string[link /reference/string/to_string.md]
 
-### 出力
+#### 出力
 ```
 mismatch index: 2
 mismatch value: (3,4)
@@ -117,6 +161,35 @@ mismatch value: (end,2)
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {1, 2, 4, 4, 5};
+
+  // 並列に2つのシーケンスが異なる場所を探す
+  auto [it1, it2] = std::ranges::mismatch(std::execution::par, v1, v2);
+  if (it1 == v1.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;all match&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;mismatch at index: &amp;#34; &amp;lt;&amp;lt; std::distance(v1.begin(), it1) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;values: &amp;#34; &amp;lt;&amp;lt; *it1 &amp;lt;&amp;lt; &amp;#34; vs &amp;#34; &amp;lt;&amp;lt; *it2 &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::mismatch[color ff0000]
+
+#### 出力
+```
+mismatch at index: 2
+values: 3 vs 4
+```
+
 ## 実装例
 ```cpp
 struct mismatch_impl {
@@ -158,3 +231,4 @@ inline constexpr mismatch_impl mismatch;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_move.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move.md b/reference/algorithm/ranges_move.md
index 08ab3cf3c..f489ba666 100644
--- a/reference/algorithm/ranges_move.md
+++ b/reference/algorithm/ranges_move.md
@@ -13,26 +13,54 @@ namespace std::ranges {
   constexpr move_result&amp;lt;I, O&amp;gt;
     move(I first,
          S last,
-         O result); // (1) C++20
+         O result);           // (1) C++20
 
   template &amp;lt;input_range R,
             weakly_incrementable O&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     move(R&amp;amp;&amp;amp; r,
-         O result); // (2) C++20
+         O result);           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_movable&amp;lt;I, O&amp;gt;
+  move_result&amp;lt;I, O&amp;gt;
+    move(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         O result,
+         OutS result_last);   // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    move(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         OutR&amp;amp;&amp;amp; result_r);    // (4) C++26
 }
 ```
 * move_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_movable[link /reference/iterator/indirectly_movable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素をムーブする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -59,6 +87,7 @@ move_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -93,6 +122,34 @@ int main() {
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;baz&amp;#34;};
+  std::vector&amp;lt;std::string&amp;gt; dst(src.size());
+
+  // 並列にムーブする
+  std::ranges::move(std::execution::par, src, dst);
+
+  for (const auto&amp;amp; s : dst) {
+    std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::move[color ff0000]
+
+#### 出力
+```
+hello world foo bar baz
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +162,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_backward -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move_backward.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_move_backward.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move_backward.md b/reference/algorithm/ranges_move_backward.md
index 4e6ab8bb6..059f1c1bc 100644
--- a/reference/algorithm/ranges_move_backward.md
+++ b/reference/algorithm/ranges_move_backward.md
@@ -13,25 +13,51 @@ namespace std::ranges {
   constexpr move_backward_result&amp;lt;I1, I2&amp;gt;
     move_backward(I1 first,
                   S1 last,
-                  I2 result); // (1) C++20
+                  I2 result);           // (1) C++20
 
   template &amp;lt;bidirectional_range R,
             bidirectional_iterator I&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
   constexpr move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
     move_backward(R&amp;amp;&amp;amp; r,
-                  I result); // (2) C++20
+                  I result);            // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2&amp;gt;
+    requires indirectly_movable&amp;lt;I1, I2&amp;gt;
+  move_backward_result&amp;lt;I1, I2&amp;gt;
+    move_backward(Ep&amp;amp;&amp;amp; exec,
+                  I1 first,
+                  S1 last,
+                  I2 result);           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            random_access_iterator I&amp;gt;
+    requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+  move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+    move_backward(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  I result);            // (4) C++26
 }
 ```
 * move_backward_result[link ranges_in_out_result.md]
 * indirectly_movable[link /reference/iterator/indirectly_movable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素を後ろからムーブする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 `result` は `(first,last]` の範囲に含まれてはならない。
@@ -61,6 +87,7 @@ move_backward_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -104,6 +131,33 @@ int main() {
 2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 0, 0};
+
+  // 並列に先頭3要素を後方へムーブ
+  std::ranges::move_backward(std::execution::par,
+                             v.begin(), v.begin() + 3, v.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::move_backward[color ff0000]
+
+#### 出力
+```
+1 2 1 2 3
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +170,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_none_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_none_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_none_of.md b/reference/algorithm/ranges_none_of.md
index 9d3bc4f7a..1a3c07c17 100644
--- a/reference/algorithm/ranges_none_of.md
+++ b/reference/algorithm/ranges_none_of.md
@@ -23,14 +23,40 @@ namespace std::ranges {
     none_of(R&amp;amp;&amp;amp; r,
             Pred pred,
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool none_of(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               Pred pred,
+               Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool none_of(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               Pred pred,
+               Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の全ての要素が条件を満たさないかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -62,6 +88,7 @@ all_of(first, last, not_fn(pred));
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,12 +110,37 @@ int main() {
 ```
 * std::ranges::none_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 7, 9};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に全ての要素が偶数でないかを判定
+  bool result = std::ranges::none_of(std::execution::par, v,
+                                     [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::none_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct none_of_impl {
@@ -131,3 +183,4 @@ inline constexpr none_of_impl none_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_nth_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
index 46e6a0f6e..1ef170c40 100644
--- a/reference/algorithm/ranges_nth_element.md
+++ b/reference/algorithm/ranges_nth_element.md
@@ -27,11 +27,39 @@ namespace std::ranges {
                 iterator_t&amp;lt;R&amp;gt; nth,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I nth_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                I nth,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    nth_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; nth,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -39,6 +67,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
 
@@ -56,6 +86,7 @@ namespace std::ranges {
 平均で線形時間
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -88,6 +119,37 @@ int main()
 10
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {5, 10, 4, 7, 1, 9, 8, 6, 2};
+
+  // 並列に4番目に小さい値より小さい値を前に集める
+  std::ranges::nth_element(std::execution::par, v, v.begin() + 3);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;4th element: &amp;#34; &amp;lt;&amp;lt; v[3] &amp;lt;&amp;lt; std::endl;
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::nth_element[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力例
+```
+4th element: 5
+2 1 4 5 7 6 8 9 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -100,3 +162,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index e5e6cfcb8..fca20788b 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -27,11 +27,39 @@ namespace std::ranges {
                  iterator_t&amp;lt;R&amp;gt; middle,
                  Comp comp = {},
                  Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I partial_sort(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 I middle,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    partial_sort(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 iterator_t&amp;lt;R&amp;gt; middle,
+                 Comp comp = {},
+                 Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -39,6 +67,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
 
@@ -56,6 +86,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -81,6 +112,34 @@ int main()
 12435
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列に先頭3要素を並んだ状態にする
+  std::ranges::partial_sort(std::execution::par, v, v.begin() + 3);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力例
+```
+1 1 2 4 5 9 3 6 5 3 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -93,3 +152,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
index bb5a1dd34..6ba612c0a 100644
--- a/reference/algorithm/ranges_partial_sort_copy.md
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -42,6 +42,48 @@ namespace std::ranges {
                       Comp comp = {},
                       Proj1 proj1 = {},
                       Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+  partial_sort_copy_result&amp;lt;I1, I2&amp;gt;
+    partial_sort_copy(Ep&amp;amp;&amp;amp; exec,
+                      I1 first,
+                      S1 last,
+                      I2 result_first,
+                      S2 result_last,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;
+               Comp,
+               projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+             &amp;gt;
+  partial_sort_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    partial_sort_copy(Ep&amp;amp;&amp;amp; exec,
+                      R1&amp;amp;&amp;amp; r,
+                      R2&amp;amp;&amp;amp; result_r,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * partial_sort_copy_result[link ranges_in_out_result.md]
@@ -50,12 +92,18 @@ namespace std::ranges {
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を部分的にソートした結果を他の範囲にコピーする
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `N =` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` とする。
@@ -78,6 +126,7 @@ partial_sort_copy_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -104,6 +153,34 @@ int main()
 12
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 4, 1, 5, 9, 2, 6};
+  std::vector&amp;lt;int&amp;gt; dst(3);
+
+  // 並列に上位3個の要素をソートしてコピー
+  std::ranges::partial_sort_copy(std::execution::par,
+                                 src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort_copy[color ff0000]
+
+#### 出力
+```
+1 1 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +193,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partition.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition.md b/reference/algorithm/ranges_partition.md
index 6d73b817e..a87c9e0d1 100644
--- a/reference/algorithm/ranges_partition.md
+++ b/reference/algorithm/ranges_partition.md
@@ -24,15 +24,45 @@ namespace std::ranges {
     partition(R&amp;amp;&amp;amp; r,
               Pred pred,
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    partition(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    partition(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -54,6 +84,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -93,6 +124,41 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+
+  // 並列に偶数グループと奇数グループに分ける
+  auto boundary = std::ranges::partition(std::execution::par, v, [](int x) { return x % 2 == 0; });
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;even: &amp;#34;;
+  for (auto it = v.begin(); it != boundary.begin(); ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;odd: &amp;#34;;
+  for (int x : boundary) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partition[color ff0000]
+
+#### 出力例
+```
+even: 8 2 6 4
+odd: 5 3 7 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +171,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
index 26ec256e3..0cf6d1f51 100644
--- a/reference/algorithm/ranges_partition_copy.md
+++ b/reference/algorithm/ranges_partition_copy.md
@@ -33,12 +33,53 @@ namespace std::ranges {
                    O2 out_false,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O1,
+            sized_sentinel_for&amp;lt;O1&amp;gt; OutS1,
+            random_access_iterator O2,
+            sized_sentinel_for&amp;lt;O2&amp;gt; OutS2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O2&amp;gt;
+  partition_copy_result&amp;lt;I, O1, O2&amp;gt;
+    partition_copy(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   O1 out_true,
+                   OutS1 out_true_last,
+                   O2 out_false,
+                   OutS2 out_false_last,
+                   Pred pred,
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR1,
+            sized-random-access-range OutR2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR1&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR2&amp;gt;&amp;gt;
+  partition_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR1&amp;gt;, borrowed_iterator_t&amp;lt;OutR2&amp;gt;&amp;gt;
+    partition_copy(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   OutR1&amp;amp;&amp;amp; out_true,
+                   OutR2&amp;amp;&amp;amp; out_false,
+                   Pred pred,
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * partition_copy_result[link ranges_in_out_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -46,6 +87,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -64,6 +107,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -105,6 +149,45 @@ evens : 2,4,
 odds : 1,3,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+  std::vector&amp;lt;int&amp;gt; evens(8);
+  std::vector&amp;lt;int&amp;gt; odds(8);
+
+  // 並列に偶数と奇数に分類してコピー
+  auto [in_end, even_end, odd_end] =
+    std::ranges::partition_copy(std::execution::par, v,
+                                evens, odds,
+                                [](int x) { return x % 2 == 0; });
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;evens: &amp;#34;;
+  for (auto it = evens.begin(); it != even_end; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;odds: &amp;#34;;
+  for (auto it = odds.begin(); it != odd_end; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partition_copy[color ff0000]
+
+#### 出力
+```
+evens: 2 4 6 8
+odds: 1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -117,3 +200,4 @@ odds : 1,3,5,
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove.md b/reference/algorithm/ranges_remove.md
index 046703e18..0ce717b59 100644
--- a/reference/algorithm/ranges_remove.md
+++ b/reference/algorithm/ranges_remove.md
@@ -53,15 +53,55 @@ namespace std::ranges {
     remove(R&amp;amp;&amp;amp; r,
            const T&amp;amp; value,
            Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    remove(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           S last,
+           const T&amp;amp; value,
+           Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           const T&amp;amp; value,
+           Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された要素を取り除く。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -172,6 +212,34 @@ int main() {
 5,6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 2, 5, 2, 7};
+
+  // 並列に値2を除去する
+  auto result = std::ranges::remove(std::execution::par, v, 2);
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -186,3 +254,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy.md b/reference/algorithm/ranges_remove_copy.md
index 68e13f9ee..b241f71f8 100644
--- a/reference/algorithm/ranges_remove_copy.md
+++ b/reference/algorithm/ranges_remove_copy.md
@@ -71,18 +71,64 @@ namespace std::ranges {
                 O result,
                 const T&amp;amp; value,
                 Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  remove_copy_result&amp;lt;I, O&amp;gt;
+    remove_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                O result,
+                OutS result_last,
+                const T&amp;amp; value,
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  remove_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    remove_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                OutR&amp;amp;&amp;amp; result_r,
+                const T&amp;amp; value,
+                Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * remove_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された要素を除け、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なってはならない。
@@ -174,6 +220,33 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 2, 5, 2, 7};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に値2を除去してコピーする
+  auto result = std::ranges::remove_copy(std::execution::par, src, dst, 2);
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_copy[color ff0000]
+
+#### 出力
+```
+1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -188,3 +261,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove_copy_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy_if.md b/reference/algorithm/ranges_remove_copy_if.md
index 2f0c10842..369cf096e 100644
--- a/reference/algorithm/ranges_remove_copy_if.md
+++ b/reference/algorithm/ranges_remove_copy_if.md
@@ -29,18 +29,54 @@ namespace std::ranges {
                    O result,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  remove_copy_if_result&amp;lt;I, O&amp;gt;
+    remove_copy_if(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   O result,
+                   OutS result_last,
+                   Pred pred,
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  remove_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    remove_copy_if(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   OutR&amp;amp;&amp;amp; result_r,
+                   Pred pred,
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * remove_copy_if_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を除け、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なってはならない。
@@ -63,6 +99,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -84,6 +121,34 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に奇数を除去してコピーする
+  auto result = std::ranges::remove_copy_if(std::execution::par, src, dst,
+                                            [](int x) { return x % 2 != 0; });
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_copy_if[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +161,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_if.md b/reference/algorithm/ranges_remove_if.md
index 6ee0da6da..b6c23a265 100644
--- a/reference/algorithm/ranges_remove_if.md
+++ b/reference/algorithm/ranges_remove_if.md
@@ -24,9 +24,37 @@ namespace std::ranges {
     remove_if(R&amp;amp;&amp;amp; r,
               Pred pred,
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    remove_if(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove_if(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -34,6 +62,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -59,6 +89,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -98,6 +129,35 @@ size before: 5
 size after: 2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  // 並列に奇数を除去する
+  auto result = std::ranges::remove_if(std::execution::par, v,
+                                       [](int x) { return x % 2 != 0; });
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_if[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +170,4 @@ size after: 2
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace.md b/reference/algorithm/ranges_replace.md
index 9e208283a..26bc41e47 100644
--- a/reference/algorithm/ranges_replace.md
+++ b/reference/algorithm/ranges_replace.md
@@ -71,16 +71,59 @@ namespace std::ranges {
             const T1&amp;amp; old_value,
             const T2&amp;amp; new_value,
             Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  I replace(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (4) C++26
 }
 ```
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値と一致する要素を指定された値に置き換える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -168,6 +211,32 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 2, 5, 2, 7};
+
+  // 並列に値2を全て10に置き換える
+  std::ranges::replace(std::execution::par, v, 2, 10);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace[color ff0000]
+
+#### 出力
+```
+1 10 3 10 5 10 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -182,3 +251,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy.md b/reference/algorithm/ranges_replace_copy.md
index 6fe9ba293..03ffe9d92 100644
--- a/reference/algorithm/ranges_replace_copy.md
+++ b/reference/algorithm/ranges_replace_copy.md
@@ -24,7 +24,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (1) C++20
+                 Proj proj = {});                     // (1) C++20
   template &amp;lt;input_iterator I,
             sentinel_for&amp;lt;I&amp;gt; S,
             class O,
@@ -43,7 +43,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (1) C++26
+                 Proj proj = {});                     // (1) C++26
 
   template &amp;lt;input_range R,
             class T1,
@@ -62,7 +62,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (2) C++20
+                 Proj proj = {});                     // (2) C++20
   template &amp;lt;input_range R,
             class O,
             class Proj = identity,
@@ -80,18 +80,68 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (2) C++26
+                 Proj proj = {});                     // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  replace_copy_result&amp;lt;I, O&amp;gt;
+    replace_copy(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 O result,
+                 OutS result_last,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {});                     // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  replace_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    replace_copy(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 OutR&amp;amp;&amp;amp; result_r,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {});                     // (4) C++26
 }
 ```
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * replace_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
@@ -185,6 +235,34 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 2, 1, 2};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に1を10に置き換えてコピー
+  std::ranges::replace_copy(std::execution::par,
+                            src, dst, 1, 10);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_copy[color ff0000]
+
+#### 出力
+```
+3 10 2 10 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -199,3 +277,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace_copy_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy_if.md b/reference/algorithm/ranges_replace_copy_if.md
index ef97b244c..6dd2ba5c4 100644
--- a/reference/algorithm/ranges_replace_copy_if.md
+++ b/reference/algorithm/ranges_replace_copy_if.md
@@ -19,7 +19,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (1) C++20
+                    Proj proj = {});                  // (1) C++20
   template &amp;lt;input_iterator I,
             sentinel_for&amp;lt;I&amp;gt; S,
             class O,
@@ -35,7 +35,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (1) C++26
+                    Proj proj = {});                  // (1) C++26
 
   template &amp;lt;input_range R,
             class T,
@@ -48,7 +48,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (2) C++20
+                    Proj proj = {});                  // (2) C++20
   template &amp;lt;input_range R,
             class O,
             class T = iter_value_t&amp;lt;O&amp;gt;,
@@ -62,18 +62,58 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (2) C++26
+                    Proj proj = {});                  // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  replace_copy_if_result&amp;lt;I, O&amp;gt;
+    replace_copy_if(Ep&amp;amp;&amp;amp; exec,
+                    I first,
+                    S last,
+                    O result,
+                    OutS result_last,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {});                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  replace_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    replace_copy_if(Ep&amp;amp;&amp;amp; exec,
+                    R&amp;amp;&amp;amp; r,
+                    OutR&amp;amp;&amp;amp; result_r,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {});                  // (4) C++26
 }
 ```
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * replace_copy_if_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
@@ -172,6 +212,35 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 4, 1, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に奇数を0に置き換えてコピー
+  std::ranges::replace_copy_if(std::execution::par,
+                               src, dst,
+                               [](int x) { return x % 2 != 0; }, 0);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_copy_if[color ff0000]
+
+#### 出力
+```
+0 0 4 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -186,3 +255,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_if.md b/reference/algorithm/ranges_replace_if.md
index 21580be08..6d8cd8f0d 100644
--- a/reference/algorithm/ranges_replace_if.md
+++ b/reference/algorithm/ranges_replace_if.md
@@ -17,7 +17,7 @@ namespace std::ranges {
                S last,
                Pred pred,
                const T&amp;amp; new_value,
-               Proj proj = {}); // (1) C++20
+               Proj proj = {});           // (1) C++20
 
   template &amp;lt;input_range R,
             class T,
@@ -28,17 +28,50 @@ namespace std::ranges {
     replace_if(R&amp;amp;&amp;amp; r,
                Pred pred,
                const T&amp;amp; new_value,
-               Proj proj = {}); // (2) C++20
+               Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T&amp;amp;&amp;gt;
+  I replace_if(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {});           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace_if(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {});           // (4) C++26
 }
 ```
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を指定された値に置き換える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -64,6 +97,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -88,6 +122,33 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  // 並列に奇数を全て0に置き換える
+  std::ranges::replace_if(std::execution::par, v,
+                          [](int x) { return x % 2 != 0; }, 0);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_if[color ff0000]
+
+#### 出力
+```
+0 2 0 4 0 6 0 8 0 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -102,3 +163,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_reverse.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse.md b/reference/algorithm/ranges_reverse.md
index d144567a3..be480a16a 100644
--- a/reference/algorithm/ranges_reverse.md
+++ b/reference/algorithm/ranges_reverse.md
@@ -17,16 +17,37 @@ namespace std::ranges {
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     reverse(R&amp;amp;&amp;amp; r);  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  I reverse(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    reverse(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r);  // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 要素の並びを逆にする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -42,6 +63,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -62,6 +84,33 @@ esrever
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に要素の並びを逆にする
+  std::ranges::reverse(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::reverse[color ff0000]
+
+#### 出力
+```
+5 4 3 2 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -74,3 +123,4 @@ esrever
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_reverse_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse_copy.md b/reference/algorithm/ranges_reverse_copy.md
index c0370b15d..879d2d72e 100644
--- a/reference/algorithm/ranges_reverse_copy.md
+++ b/reference/algorithm/ranges_reverse_copy.md
@@ -21,18 +21,47 @@ namespace std::ranges {
   constexpr reverse_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     reverse_copy(R&amp;amp;&amp;amp; r,
                  O result); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  reverse_copy_truncated_result&amp;lt;I, O&amp;gt;
+    reverse_copy(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 O result,
+                 OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  reverse_copy_truncated_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    reverse_copy(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * reverse_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
+* reverse_copy_truncated_result[link ranges_in_in_out_result.md]
 
 ## 概要
 要素の並びを逆にし、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -44,7 +73,8 @@ namespace std::ranges {
 
 
 ## 戻り値
-`{ .in = last, .out = result + (last - first) }`
+- (1), (2): `{ .in = last, .out = result + (last - first) }`
+- (3), (4): 出力範囲が入力範囲より短い場合、出力範囲の末尾まで書き込み、`in1`と`in2`で入力範囲のどこまで処理されたかを示す。`in1`は常に`last`と等しく、`in2`は入力範囲内の停止点を指す。出力範囲が十分な場合は`in2 == first`となる
 
 
 ## 計算量
@@ -52,6 +82,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -66,11 +97,38 @@ int main() {
 ```
 * std::ranges::reverse_copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 esrever
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に逆順コピーする
+  auto result = std::ranges::reverse_copy(std::execution::par, src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::reverse_copy[color ff0000]
+
+#### 出力
+```
+5 4 3 2 1
+```
+
 
 ## バージョン
 ### 言語
@@ -84,3 +142,5 @@ esrever
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_rotate.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate.md b/reference/algorithm/ranges_rotate.md
index a72fe1ebb..23a4eb07d 100644
--- a/reference/algorithm/ranges_rotate.md
+++ b/reference/algorithm/ranges_rotate.md
@@ -18,15 +18,39 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     rotate(R&amp;amp;&amp;amp; r,
            iterator_t&amp;lt;R&amp;gt; middle); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    rotate(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           I middle,
+           S last);               // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    rotate(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           iterator_t&amp;lt;R&amp;gt; middle); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
@@ -131,6 +155,34 @@ swapping 0x1806043(1) &amp;lt;-&amp;gt; 0x1806045(5)
 234501
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に要素を回転させる (先頭から2つ目の要素が先頭に来る)
+  std::ranges::rotate(std::execution::par, v, v.begin() + 2);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力
+```
+3 4 5 1 2
+```
+
 ## 実装例
 - [std::rotate を読んでみた](http://www.kmonos.net/wlog/115.html#_0007101223)
 
@@ -146,3 +198,4 @@ swapping 0x1806043(1) &amp;lt;-&amp;gt; 0x1806045(5)
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_rotate_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate_copy.md b/reference/algorithm/ranges_rotate_copy.md
index 6e2aa01a1..67725ea13 100644
--- a/reference/algorithm/ranges_rotate_copy.md
+++ b/reference/algorithm/ranges_rotate_copy.md
@@ -23,17 +23,48 @@ namespace std::ranges {
     rotate_copy(R&amp;amp;&amp;amp; r,
                 iterator_t&amp;lt;R&amp;gt; middle,
                 O result); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  rotate_copy_truncated_result&amp;lt;I, O&amp;gt;
+    rotate_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                I middle,
+                S last,
+                O result,
+                OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  rotate_copy_truncated_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    rotate_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; middle,
+                OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * rotate_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
+* rotate_copy_truncated_result[link ranges_in_in_out_result.md]
 
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -45,7 +76,8 @@ namespace std::ranges {
 
 
 ## 戻り値
-回転前の先頭の要素を指すイテレータ`result + (last - first)`
+- (1), (2): `{ .in = last, .out = result + (last - first) }`
+- (3), (4): 出力範囲が入力範囲より短い場合、出力範囲の末尾まで書き込み、`in1`と`in2`で入力範囲のどこまで処理されたかを示す。`in1`は`[middle, last)`の範囲内の停止点、`in2`は`[first, middle)`の範囲内の停止点を指す。出力範囲が十分な場合は`in1 == last`かつ`in2 == middle`となる
 
 
 ## 計算量
@@ -53,6 +85,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -71,11 +104,39 @@ int main() {
 * std::ranges::rotate_copy[color ff0000]
 * str.begin()[link /reference/string/basic_string/begin.md]
 
-### 出力
+#### 出力
 ```
 tatero
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に回転コピーする（3番目の要素が先頭になるように）
+  auto result = std::ranges::rotate_copy(
+    std::execution::par, src, src.begin() + 2, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate_copy[color ff0000]
+
+#### 出力
+```
+3 4 5 1 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -88,3 +149,5 @@ tatero
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_search.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index 4ff7e480e..ef8d61005 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -35,14 +35,54 @@ namespace std::ranges {
            Pred pred = {},
            Proj1 proj1 = {},
            Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  subrange&amp;lt;I1&amp;gt;
+    search(Ep&amp;amp;&amp;amp; exec,
+           I1 first1,
+           S1 last1,
+           I2 first2,
+           S2 last2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_subrange_t&amp;lt;R1&amp;gt;
+    search(Ep&amp;amp;&amp;amp; exec,
+           R1&amp;amp;&amp;amp; r1,
+           R2&amp;amp;&amp;amp; r2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 あるシーケンスの中から、特定のサブシーケンスを探す
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 - (1) :
@@ -54,6 +94,7 @@ namespace std::ranges {
 最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,6 +124,33 @@ found: index==0
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 3, 4};
+  std::vector&amp;lt;int&amp;gt; pattern = {3, 4};
+
+  // 並列にサブシーケンスを検索する
+  auto sr = std::ranges::search(std::execution::par, v, pattern);
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::search[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct search_impl {
@@ -128,3 +196,4 @@ inline constexpr search_impl search;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_difference.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_difference.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_difference.md b/reference/algorithm/ranges_set_difference.md
index 3cf8ab2d2..30a8b7c9b 100644
--- a/reference/algorithm/ranges_set_difference.md
+++ b/reference/algorithm/ranges_set_difference.md
@@ -39,6 +39,46 @@ namespace std::ranges {
                    Comp comp = {},
                    Proj1 proj1 = {},
                    Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_difference_result&amp;lt;I1, O&amp;gt;
+    set_difference(Ep&amp;amp;&amp;amp; exec,
+                   I1 first1,
+                   S1 last1,
+                   I2 first2,
+                   S2 last2,
+                   O result,
+                   OutS result_last,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    set_difference(Ep&amp;amp;&amp;amp; exec,
+                   R1&amp;amp;&amp;amp; r1,
+                   R2&amp;amp;&amp;amp; r2,
+                   OutR&amp;amp;&amp;amp; result_r,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_difference_result[link ranges_in_out_result.md]
@@ -46,6 +86,10 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -53,6 +97,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
@@ -83,6 +129,7 @@ set_difference_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -115,6 +162,40 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; b = {2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; result(a.size());
+
+  // 並列にa - bの差集合を作る
+  auto ret = std::ranges::set_difference(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_difference[color ff0000]
+
+#### 出力
+```
+1 5 6
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -127,3 +208,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_intersection.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_intersection.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_intersection.md b/reference/algorithm/ranges_set_intersection.md
index 6ae748e66..f349845a7 100644
--- a/reference/algorithm/ranges_set_intersection.md
+++ b/reference/algorithm/ranges_set_intersection.md
@@ -43,6 +43,50 @@ namespace std::ranges {
                      Comp comp = {},
                      Proj1 proj1 = {},
                      Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_intersection_result&amp;lt;I1, I2, O&amp;gt;
+    set_intersection(Ep&amp;amp;&amp;amp; exec,
+                     I1 first1,
+                     S1 last1,
+                     I2 first2,
+                     S2 last2,
+                     O result,
+                     OutS result_last,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_intersection_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              borrowed_iterator_t&amp;lt;OutR&amp;gt;
+            &amp;gt;
+    set_intersection(Ep&amp;amp;&amp;amp; exec,
+                     R1&amp;amp;&amp;amp; r1,
+                     R2&amp;amp;&amp;amp; r2,
+                     OutR&amp;amp;&amp;amp; result_r,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_intersection_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の積集合を得る
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -89,6 +139,7 @@ set_intersection_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -119,6 +170,40 @@ int main()
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; result(std::min(a.size(), b.size()));
+
+  // 並列にaとbの積集合を作る
+  auto ret = std::ranges::set_intersection(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_intersection[color ff0000]
+
+#### 出力
+```
+2 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -131,3 +216,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_symmetric_difference.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_symmetric_difference.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_symmetric_difference.md b/reference/algorithm/ranges_set_symmetric_difference.md
index b2c8fa3ce..64836ea7e 100644
--- a/reference/algorithm/ranges_set_symmetric_difference.md
+++ b/reference/algorithm/ranges_set_symmetric_difference.md
@@ -43,6 +43,50 @@ namespace std::ranges {
                              Comp comp = {},
                              Proj1 proj1 = {},
                              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_symmetric_difference_result&amp;lt;I1, I2, O&amp;gt;
+    set_symmetric_difference(Ep&amp;amp;&amp;amp; exec,
+                             I1 first1,
+                             S1 last1,
+                             I2 first2,
+                             S2 last2,
+                             O result,
+                             OutS result_last,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_symmetric_difference_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              borrowed_iterator_t&amp;lt;OutR&amp;gt;
+            &amp;gt;
+    set_symmetric_difference(Ep&amp;amp;&amp;amp; exec,
+                             R1&amp;amp;&amp;amp; r1,
+                             R2&amp;amp;&amp;amp; r2,
+                             OutR&amp;amp;&amp;amp; result_r,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_symmetric_difference_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -91,6 +141,7 @@ set_symmetric_difference_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -116,7 +167,7 @@ int main()
 * end()[link /reference/set/set/end.md]
 * std::inserter[link /reference/iterator/inserter.md]
 
-### 出力
+#### 出力
 ```
 1
 5
@@ -125,6 +176,39 @@ int main()
 8
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6, 8};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列に対称差を求める
+  auto [in1, in2, out] = std::ranges::set_symmetric_difference(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_symmetric_difference[color ff0000]
+
+#### 出力
+```
+1 3 5 6 8
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -137,3 +221,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_union.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_union.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_union.md b/reference/algorithm/ranges_set_union.md
index e4f8a977f..e650cf490 100644
--- a/reference/algorithm/ranges_set_union.md
+++ b/reference/algorithm/ranges_set_union.md
@@ -45,6 +45,52 @@ namespace std::ranges {
               Comp comp = {},
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_union_result&amp;lt;I1, I2, O&amp;gt;
+    set_union(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              OutS result_last,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;
+               iterator_t&amp;lt;R1&amp;gt;,
+               iterator_t&amp;lt;R2&amp;gt;,
+               iterator_t&amp;lt;OutR&amp;gt;,
+               Comp,
+               Proj1,
+               Proj2&amp;gt;
+  set_union_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    set_union(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              OutR&amp;amp;&amp;amp; result_r,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_union_result[link ranges_in_in_out_result.md]
@@ -52,12 +98,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の和集合を得る
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
@@ -83,6 +135,7 @@ set_union_result {
 最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回の比較を行う
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -121,6 +174,40 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列にaとbの和集合を作る
+  auto ret = std::ranges::set_union(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_union[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -133,3 +220,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_shift_left.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_left.md b/reference/algorithm/ranges_shift_left.md
index 73310893b..712f3cdbc 100644
--- a/reference/algorithm/ranges_shift_left.md
+++ b/reference/algorithm/ranges_shift_left.md
@@ -18,15 +18,39 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     shift_left(R&amp;amp;&amp;amp; r,
                range_difference_t&amp;lt;R&amp;gt; n); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    shift_left(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               iter_difference_t&amp;lt;I&amp;gt; n);  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_left(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               range_difference_t&amp;lt;R&amp;gt; n); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の要素をn個だけ左にシフトさせる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
@@ -62,6 +86,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -86,6 +111,32 @@ int main()
 3,4,5,4,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に2つ左シフト
+  auto result = std::ranges::shift_left(std::execution::par, v, 2);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::shift_left[color ff0000]
+
+#### 出力
+```
+3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -98,3 +149,4 @@ int main()
 
 ## 参照
 - [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_shift_right.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_right.md b/reference/algorithm/ranges_shift_right.md
index 1d90e77d2..ca8d29d5d 100644
--- a/reference/algorithm/ranges_shift_right.md
+++ b/reference/algorithm/ranges_shift_right.md
@@ -18,9 +18,31 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     shift_right(R&amp;amp;&amp;amp; r,
                 range_difference_t&amp;lt;R&amp;gt; n); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    shift_right(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                iter_difference_t&amp;lt;I&amp;gt; n); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_right(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                range_difference_t&amp;lt;R&amp;gt; n); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -28,6 +50,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
@@ -63,6 +87,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -87,6 +112,32 @@ int main()
 1,2,1,2,3,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に2つ右シフト
+  auto result = std::ranges::shift_right(std::execution::par, v, 2);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::shift_right[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -99,3 +150,4 @@ int main()
 
 ## 参照
 - [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_sort.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort.md b/reference/algorithm/ranges_sort.md
index 95bb2f901..3fd99752c 100644
--- a/reference/algorithm/ranges_sort.md
+++ b/reference/algorithm/ranges_sort.md
@@ -25,17 +25,45 @@ namespace std::ranges {
     sort(R&amp;amp;&amp;amp; r,
          Comp comp = {},
          Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I sort(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         Comp comp = {},
+         Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    sort(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         Comp comp = {},
+         Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を並べ替える
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
@@ -164,6 +192,33 @@ Carol
 Bob
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列ソート
+  std::ranges::sort(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::sort[color ff0000]
+
+#### 出力
+```
+1 1 2 3 3 4 5 5 5 6 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -176,3 +231,4 @@ Bob
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_partition.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_stable_partition.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_partition.md b/reference/algorithm/ranges_stable_partition.md
index 872f5f7cc..e425a0e81 100644
--- a/reference/algorithm/ranges_stable_partition.md
+++ b/reference/algorithm/ranges_stable_partition.md
@@ -43,9 +43,37 @@ namespace std::ranges {
     stable_partition(R&amp;amp;&amp;amp; r,
                      Pred pred,
                      Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    stable_partition(Ep&amp;amp;&amp;amp; exec,
+                     I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    stable_partition(Ep&amp;amp;&amp;amp; exec,
+                     R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -53,6 +81,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -74,6 +104,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -102,6 +133,33 @@ int main()
 5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+
+  // 並列に相対順序を保ちながら偶数グループと奇数グループに分ける
+  std::ranges::stable_partition(std::execution::par, v, [](int x) { return x % 2 == 0; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::stable_partition[color ff0000]
+
+#### 出力
+```
+2 4 6 8 1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +174,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_sort.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_stable_sort.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_sort.md b/reference/algorithm/ranges_stable_sort.md
index 8497fd89e..94f35b9ca 100644
--- a/reference/algorithm/ranges_stable_sort.md
+++ b/reference/algorithm/ranges_stable_sort.md
@@ -43,17 +43,45 @@ namespace std::ranges {
     stable_sort(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I stable_sort(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    stable_sort(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を安定ソートで並べ替える
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
@@ -72,6 +100,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -97,6 +126,33 @@ int main()
 12345
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列に安定ソートする
+  std::ranges::stable_sort(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::stable_sort[color ff0000]
+
+#### 出力
+```
+1 1 2 3 3 4 5 5 5 6 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -111,3 +167,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>starts_with -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_starts_with.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_starts_with.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_starts_with.md b/reference/algorithm/ranges_starts_with.md
index a3e605434..d7ee0b1c0 100644
--- a/reference/algorithm/ranges_starts_with.md
+++ b/reference/algorithm/ranges_starts_with.md
@@ -35,8 +35,46 @@ namespace std::ranges {
                 Pred pred = {},
                 Proj1 proj1 = {},
                 Proj2 proj2 = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool
+    starts_with(Ep&amp;amp;&amp;amp; exec,
+                I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool
+    starts_with(Ep&amp;amp;&amp;amp; exec,
+                R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -44,6 +82,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 
@@ -54,6 +94,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -70,13 +111,38 @@ int main() {
 ```
 * std::ranges::starts_with[color ff0000]
 
-### 出力
+#### 出力
 ```
 1
 0
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; prefix = {1, 2, 3};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に先頭が一致するかを判定
+  bool result = std::ranges::starts_with(std::execution::par, v, prefix);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::starts_with[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct starts_with_impl {
@@ -114,3 +180,4 @@ inline constexpr starts_with_impl starts_with;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap_ranges -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_swap_ranges.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_swap_ranges.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_swap_ranges.md b/reference/algorithm/ranges_swap_ranges.md
index eca99ff9a..d851f7e21 100644
--- a/reference/algorithm/ranges_swap_ranges.md
+++ b/reference/algorithm/ranges_swap_ranges.md
@@ -15,7 +15,7 @@ namespace std::ranges {
     swap_ranges(I1 first1,
                 S1 last1,
                 I2 first2,
-                S2 last2); // (1) C++20
+                S2 last2);                  // (1) C++20
 
   template &amp;lt;input_range R1,
             input_range R2&amp;gt;
@@ -24,17 +24,47 @@ namespace std::ranges {
               borrowed_iterator_t&amp;lt;R1&amp;gt;,
               borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
     swap_ranges(R1&amp;amp;&amp;amp; r1,
-                R2&amp;amp;&amp;amp; r2); // (2) C++20
+                R2&amp;amp;&amp;amp; r2);                   // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2&amp;gt;
+    requires indirectly_swappable&amp;lt;I1, I2&amp;gt;
+  swap_ranges_result&amp;lt;I1, I2&amp;gt;
+    swap_ranges(Ep&amp;amp;&amp;amp; exec,
+                I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2);                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2&amp;gt;
+    requires indirectly_swappable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+  swap_ranges_result&amp;lt;
+            borrowed_iterator_t&amp;lt;R1&amp;gt;,
+            borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    swap_ranges(Ep&amp;amp;&amp;amp; exec,
+                R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2);                   // (4) C++26
 }
 ```
 * swap_ranges_result[link ranges_in_in_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された2つの範囲同士を swap する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -63,6 +93,7 @@ swap_ranges_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -93,6 +124,41 @@ v1: 5,2,4,
 v2: 3,1,2,1,3,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {6, 7, 8, 9, 10};
+
+  // 並列に2つの範囲をswapする
+  std::ranges::swap_ranges(std::execution::par, v1, v2);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;v1: &amp;#34;;
+  for (int x : v1) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;v2: &amp;#34;;
+  for (int x : v2) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::swap_ranges[color ff0000]
+
+#### 出力
+```
+v1: 6 7 8 9 10
+v2: 1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +171,4 @@ v2: 3,1,2,1,3,
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_transform.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_transform.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_transform.md b/reference/algorithm/ranges_transform.md
index 6650810ac..dabb5817b 100644
--- a/reference/algorithm/ranges_transform.md
+++ b/reference/algorithm/ranges_transform.md
@@ -80,6 +80,93 @@ namespace std::ranges {
               F binary_op,
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (4) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I, Proj&amp;gt;&amp;gt;
+             &amp;gt;
+  unary_transform_result&amp;lt;I, O&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              I first1,
+              S last1,
+              O result,
+              OutS result_last,
+              F op,
+              Proj proj = {}); // (5) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               iterator_t&amp;lt;OutR&amp;gt;,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+             &amp;gt;
+  unary_transform_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              OutR&amp;amp;&amp;amp; result_r,
+              F op,
+              Proj proj = {}); // (6) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  binary_transform_result&amp;lt;I1, I2, O&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              OutS result_last,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (7) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               iterator_t&amp;lt;OutR&amp;gt;,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  binary_transform_result&amp;lt;
+            borrowed_iterator_t&amp;lt;R1&amp;gt;,
+            borrowed_iterator_t&amp;lt;R2&amp;gt;,
+            borrowed_iterator_t&amp;lt;OutR&amp;gt;
+          &amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              OutR&amp;amp;&amp;amp; result_r,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (8) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -88,6 +175,10 @@ namespace std::ranges {
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 * unary_transform_result[link ranges_in_out_result.md]
 * binary_transform_result[link ranges_in_in_out_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -95,6 +186,8 @@ namespace std::ranges {
 
 - (1), (2): 1つの範囲の要素に関数を適用し、結果を出力イテレータに出力する
 - (3), (4): 2つの範囲の要素を1つずつ取り出して関数を適用し、結果を出力イテレータに出力する
+- (5), (6): (1), (2)の並列アルゴリズム版。実行ポリシーを指定する
+- (7), (8): (3), (4)の並列アルゴリズム版。実行ポリシーを指定する
 
 - (1), (3): イテレータ範囲を指定する
 - (2), (4): Rangeを直接指定する
@@ -127,7 +220,8 @@ namespace std::ranges {
 - (3), (4) : `result` は `first1` や `first2` と同じであっても構わない。
 
 
-## (1)の例
+## 例
+### (1)の例
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -158,7 +252,7 @@ int main() {
 ```
 
 
-## (2)の例
+### (2)の例
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -188,6 +282,33 @@ b
 cccc
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; result(v.size());
+
+  // 並列に全ての要素を2乗する
+  std::ranges::transform(std::execution::par, v, result, [](int x) { return x * x; });
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::transform[color ff0000]
+
+#### 出力
+```
+1 4 9 16 25
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -200,6 +321,7 @@ cccc
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
 
 ## 関連項目
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_unique.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique.md b/reference/algorithm/ranges_unique.md
index 31f6880e6..04d030671 100644
--- a/reference/algorithm/ranges_unique.md
+++ b/reference/algorithm/ranges_unique.md
@@ -24,10 +24,38 @@ namespace std::ranges {
     unique(R&amp;amp;&amp;amp; r,
            C comp = {},
            Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    unique(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           S last,
+           C comp = {},
+           Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    unique(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           C comp = {},
+           Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
 * indirect_equivalence_relation[link /reference/iterator/indirect_equivalence_relation.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +63,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
 
@@ -59,6 +89,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -118,6 +149,34 @@ unsorted unique : 2,5,3,1,2,4,2,1,4,3
 sorted unique : 1,2,3,4,5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 1, 2, 3, 3, 3, 4, 4, 5};
+
+  // 並列に隣り合った重複要素を除去する
+  auto result = std::ranges::unique(std::execution::par, v);
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::unique[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -130,3 +189,4 @@ sorted unique : 1,2,3,4,5
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_unique_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique_copy.md b/reference/algorithm/ranges_unique_copy.md
index eb7d53793..30c2fbe5e 100644
--- a/reference/algorithm/ranges_unique_copy.md
+++ b/reference/algorithm/ranges_unique_copy.md
@@ -37,6 +37,36 @@ namespace std::ranges {
                 O result,
                 C comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  unique_copy_result&amp;lt;I, O&amp;gt;
+    unique_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                O result,
+                OutS result_last,
+                C comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  unique_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    unique_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                OutR&amp;amp;&amp;amp; result_r,
+                C comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -45,12 +75,18 @@ namespace std::ranges {
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
 * unique_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なっていてはならない
@@ -73,6 +109,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -129,6 +166,33 @@ unsorted unique : 2,5,3,1,2,4,2,1,4,3
 sorted unique : 1,2,3,4,5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 1, 2, 3, 3, 3, 4, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に隣り合った重複要素を除去してコピーする
+  auto result = std::ranges::unique_copy(std::execution::par, src, dst);
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::unique_copy[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -141,3 +205,4 @@ sorted unique : 1,2,3,4,5
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/execution.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/execution.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;execution&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;execution&lt;/span&gt;&lt;span class=&#34;cpp cpp17&#34; title=&#34;C++17で追加&#34;&gt;(C++17)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;execution&amp;gt;&lt;/code&gt;ヘッダでは、アルゴリズムの並列実行を許可するための実行ポリシー、汎用的な非同期実行フレームワークとしての実行制御ライブラリを定義する。&lt;/p&gt;
&lt;h2&gt;実行ポリシー(C++17)&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;execution&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行ポリシー用の名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/is_execution_policy.html&#34;&gt;is_execution_policy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が実行ポリシーかを判定する (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution-policy.html&#34;&gt;execution-policy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が実行ポリシーであることを表す (説明専用concept)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;実行制御ライブラリ(C++26)&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;execution&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行制御ライブラリの名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;this_thread&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行制御ライブラリ／Senderコンシューマの名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++26 実行制御ライブラリ&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html&#34; target=&#34;_blank&#34;&gt;P0024R2 The Parallelism TS Should be Standardized&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html&#34; target=&#34;_blank&#34;&gt;P2300R10 &lt;code&gt;std::execution&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html&#34; target=&#34;_blank&#34;&gt;P3179R9 C++ parallel range algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution-policy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution-policy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/execution/execution-policy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution-policy.md b/reference/execution/execution-policy.md
new file mode 100644
index 000000000..635cbc8f0
--- /dev/null
+++ b/reference/execution/execution-policy.md
@@ -0,0 +1,31 @@
+# execution-policy
+* execution[meta header]
+* concept[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T&amp;gt;
+  concept execution-policy = is_execution_policy_v&amp;lt;remove_cvref_t&amp;lt;T&amp;gt;&amp;gt;;
+}
+```
+* is_execution_policy_v[link is_execution_policy.md]
+* remove_cvref_t[link /reference/type_traits/remove_cvref.md]
+
+## 概要
+`execution-policy`は、型`T`が実行ポリシー型であることを表す説明専用のコンセプトである。
+
+このコンセプトは、並列Rangeアルゴリズムのテンプレートパラメータ制約として使用される。
+
+このコンセプトに合致する型は、以下のページを参照：
+
+- [実行ポリシー](execution/execution_policy.md)
+
+
+## バージョン
+### 言語
+- C++26
+
+## 参照
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_destroy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy.md b/reference/memory/ranges_destroy.md
index 075fcc299..19d0f925d 100644
--- a/reference/memory/ranges_destroy.md
+++ b/reference/memory/ranges_destroy.md
@@ -13,6 +13,17 @@ namespace std::ranges {
   template &amp;lt;no-throw-input-range R&amp;gt;
     requires destructible&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; destroy(R&amp;amp;&amp;amp; r) noexcept; // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I destroy(Ep&amp;amp;&amp;amp; exec, I first, S last) noexcept;           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires destructible&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt; destroy(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r) noexcept; // (4) C++26
 }
 ```
 * no-throw-input-iterator[link no-throw-input-iterator.md]
@@ -20,6 +31,10 @@ namespace std::ranges {
 * destructible[link /reference/concepts/destructible.md]
 * no-throw-input-range[link no-throw-input-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 デストラクタを呼び出す。
@@ -28,6 +43,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -52,6 +69,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -94,6 +112,35 @@ int main()
 0
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* p = alloc.allocate(3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::construct_at(p + i, &amp;#34;hello&amp;#34;);
+  }
+
+  // 並列に破棄
+  std::ranges::destroy(std::execution::par, p, p + 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::destroy[color ff0000]
+
+#### 出力
+```
+done
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -109,3 +156,4 @@ int main()
 
 ## 参照
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_destroy_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy_n.md b/reference/memory/ranges_destroy_n.md
index 258acf0e1..3d6da8eae 100644
--- a/reference/memory/ranges_destroy_n.md
+++ b/reference/memory/ranges_destroy_n.md
@@ -9,16 +9,26 @@ namespace std::ranges {
   template &amp;lt;no-throw-input-iterator I&amp;gt;
     requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
   constexpr I destroy_n(I first, iter_difference_t&amp;lt;I&amp;gt; n) noexcept; // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I destroy_n(Ep&amp;amp;&amp;amp; exec, I first, iter_difference_t&amp;lt;I&amp;gt; n) noexcept; // (2) C++26
 }
 ```
 * no-throw-input-iterator[link no-throw-input-iterator.md]
 * destructible[link /reference/concepts/destructible.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 イテレータ範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトを破棄するために使用する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -38,6 +48,7 @@ return destroy(counted_iterator(first, n), default_sentinel).base();
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -80,6 +91,35 @@ int main()
 0
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* p = alloc.allocate(3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::construct_at(p + i, &amp;#34;hello&amp;#34;);
+  }
+
+  // 並列にn個破棄
+  std::ranges::destroy_n(std::execution::par, p, 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::destroy_n[color ff0000]
+
+#### 出力
+```
+done
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -95,3 +135,4 @@ int main()
 
 ## 参照
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy.md b/reference/memory/ranges_uninitialized_copy.md
index 7e76fade9..35100d93d 100644
--- a/reference/memory/ranges_uninitialized_copy.md
+++ b/reference/memory/ranges_uninitialized_copy.md
@@ -42,6 +42,29 @@ namespace std::ranges {
   &amp;gt;
     uninitialized_copy(IR&amp;amp;&amp;amp; in_range,
                        OR&amp;amp;&amp;amp; out_range); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, sized_sentinel_for&amp;lt;I&amp;gt; S1,
+            random_access_iterator O, sized_sentinel_for&amp;lt;O&amp;gt; S2&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_copy_result&amp;lt;I, O&amp;gt;
+    uninitialized_copy(Ep&amp;amp;&amp;amp; exec,
+                       I ifirst,
+                       S1 ilast,
+                       O ofirst,
+                       S2 olast);       // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range IR,
+            sized-random-access-range OR&amp;gt;
+  requires constructible_from&amp;lt;range_value_t&amp;lt;OR&amp;gt;, range_reference_t&amp;lt;IR&amp;gt;&amp;gt;
+  uninitialized_copy_result&amp;lt;
+    borrowed_iterator_t&amp;lt;IR&amp;gt;,
+    borrowed_iterator_t&amp;lt;OR&amp;gt;
+  &amp;gt;
+    uninitialized_copy(Ep&amp;amp;&amp;amp; exec,
+                       IR&amp;amp;&amp;amp; in_range,
+                       OR&amp;amp;&amp;amp; out_range); // (4) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -51,12 +74,18 @@ namespace std::ranges {
 * iter_reference_t[link /reference/iterator/iter_reference_t.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
-未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
+未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してコピー出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -105,6 +134,7 @@ return {std::move(ifirst), ofirst};
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -152,6 +182,39 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3};
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* dst = alloc.allocate(3);
+
+  // 並列に未初期化領域へコピー
+  std::ranges::uninitialized_copy(
+    std::execution::par, src, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_copy[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -169,3 +232,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_copy_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy_n.md b/reference/memory/ranges_uninitialized_copy_n.md
index fb409e56e..52380f451 100644
--- a/reference/memory/ranges_uninitialized_copy_n.md
+++ b/reference/memory/ranges_uninitialized_copy_n.md
@@ -31,6 +31,20 @@ namespace std::ranges {
       O ofirst,
       S olast
     );                               // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_copy_n_result&amp;lt;I, O&amp;gt;
+    uninitialized_copy_n(
+      Ep&amp;amp;&amp;amp; exec,
+      I ifirst,
+      iter_difference_t&amp;lt;I&amp;gt; n,
+      O ofirst,
+      S olast
+    );                               // (2) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -38,11 +52,15 @@ namespace std::ranges {
 * no-throw-sentinel[link no-throw-sentinel.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
 * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してコピー出力する。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +95,7 @@ return {std::move(t.in).base(), t.out};
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -123,6 +142,39 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* dst = alloc.allocate(3);
+
+  // 並列に3要素を未初期化領域へコピー
+  std::ranges::uninitialized_copy_n(
+    std::execution::par, src.begin(), 3, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_copy_n[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -140,3 +192,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_default_construct.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct.md b/reference/memory/ranges_uninitialized_default_construct.md
index 32812ee0c..9e0669a5e 100644
--- a/reference/memory/ranges_uninitialized_default_construct.md
+++ b/reference/memory/ranges_uninitialized_default_construct.md
@@ -23,18 +23,38 @@ namespace std::ranges {
     requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_default_construct(R&amp;amp;&amp;amp; r);           // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_default_construct(Ep&amp;amp;&amp;amp; exec,
+                                    I first, S last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_default_construct(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r); // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素をデフォルト構築する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +97,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -124,6 +145,32 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にデフォルト構築
+  std::ranges::uninitialized_default_construct(
+    std::execution::par, p, p + 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::uninitialized_default_construct[color ff0000]
+
+#### 出力
+```
+done
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -142,3 +189,4 @@ int main()
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
 - [P3369R0 `constexpr` for `uninitialized_default_construct`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
     - 上記2文書で、C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_default_construct_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct_n.md b/reference/memory/ranges_uninitialized_default_construct_n.md
index 6e9cd283b..f9ff6fdbc 100644
--- a/reference/memory/ranges_uninitialized_default_construct_n.md
+++ b/reference/memory/ranges_uninitialized_default_construct_n.md
@@ -16,13 +16,26 @@ namespace std::ranges {
   constexpr I
     uninitialized_default_construct_n(I first,
                                       iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_default_construct_n(Ep&amp;amp;&amp;amp; exec,
+                                      I first,
+                                      iter_difference_t&amp;lt;I&amp;gt; n); // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) の各要素をデフォルト構築する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -46,6 +59,7 @@ return uninitialized_default_construct(counted_iterator(first, n),
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -92,6 +106,32 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個デフォルト構築
+  std::ranges::uninitialized_default_construct_n(
+    std::execution::par, p, 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::uninitialized_default_construct_n[color ff0000]
+
+#### 出力
+```
+done
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +150,4 @@ int main()
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
 - [P3369R0 `constexpr` for `uninitialized_default_construct`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
     - 上記2文書で、C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_fill.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill.md b/reference/memory/ranges_uninitialized_fill.md
index 735aa3dfa..4e2cd51e1 100644
--- a/reference/memory/ranges_uninitialized_fill.md
+++ b/reference/memory/ranges_uninitialized_fill.md
@@ -15,7 +15,8 @@ namespace std::ranges {
             no-throw-sentinel&amp;lt;I&amp;gt; S,
             class T&amp;gt;
     requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
-  I uninitialized_fill(I first, S last, const T&amp;amp; x); // (1) C++26
+  constexpr I
+    uninitialized_fill(I first, S last, const T&amp;amp; x); // (1) C++26
 
   template &amp;lt;no-throw-forward-range R,
             class T&amp;gt;
@@ -27,6 +28,22 @@ namespace std::ranges {
     requires constructible_from&amp;lt;range_value_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_fill(R&amp;amp;&amp;amp; r, const T&amp;amp; x);           // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T&amp;gt;
+    requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
+  I uninitialized_fill(Ep&amp;amp;&amp;amp; exec,
+                       I first, S last, const T&amp;amp; x); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T&amp;gt;
+    requires constructible_from&amp;lt;range_value_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_fill(Ep&amp;amp;&amp;amp; exec,
+                       R&amp;amp;&amp;amp; r, const T&amp;amp; x);           // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
@@ -34,12 +51,18 @@ namespace std::ranges {
 * constructible_from[link /reference/concepts/constructible_from.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) を、指定された値で配置`new`で初期化する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -78,6 +101,7 @@ return first;
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -121,6 +145,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列に未初期化領域を42で埋める
+  std::ranges::uninitialized_fill(
+    std::execution::par, p, p + 3, 42);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_fill[color ff0000]
+
+#### 出力
+```
+42 42 42
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -138,3 +192,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_fill_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill_n.md b/reference/memory/ranges_uninitialized_fill_n.md
index 5c0377772..c90ee2a52 100644
--- a/reference/memory/ranges_uninitialized_fill_n.md
+++ b/reference/memory/ranges_uninitialized_fill_n.md
@@ -18,14 +18,28 @@ namespace std::ranges {
     uninitialized_fill_n(I first,
                          iter_difference_t&amp;lt;I&amp;gt; n,
                          const T&amp;amp; x);            // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, class T&amp;gt;
+    requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
+  I
+    uninitialized_fill_n(Ep&amp;amp;&amp;amp; exec,
+                         I first,
+                         iter_difference_t&amp;lt;I&amp;gt; n,
+                         const T&amp;amp; x);            // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) を、指定された値で配置`new`で初期化する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -48,6 +62,7 @@ return uninitialized_fill(counted_iterator(first, n), default_sentinel, x).base(
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -90,6 +105,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個の未初期化領域を99で埋める
+  std::ranges::uninitialized_fill_n(
+    std::execution::par, p, 3, 99);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_fill_n[color ff0000]
+
+#### 出力
+```
+99 99 99
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -107,3 +152,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_move.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move.md b/reference/memory/ranges_uninitialized_move.md
index 2fca1ad0f..2faf9699d 100644
--- a/reference/memory/ranges_uninitialized_move.md
+++ b/reference/memory/ranges_uninitialized_move.md
@@ -34,6 +34,26 @@ namespace std::ranges {
     borrowed_iterator_t&amp;lt;OR&amp;gt;
   &amp;gt;
     uninitialized_move(IR&amp;amp;&amp;amp; in_range, OR&amp;amp;&amp;amp; out_range);          // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, sized_sentinel_for&amp;lt;I&amp;gt; S1,
+            random_access_iterator O, sized_sentinel_for&amp;lt;O&amp;gt; S2&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_rvalue_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_move_result&amp;lt;I, O&amp;gt;
+    uninitialized_move(Ep&amp;amp;&amp;amp; exec,
+                       I ifirst, S1 ilast,
+                       O ofirst, S2 olast);                     // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range IR,
+            sized-random-access-range OR&amp;gt;
+  requires constructible_from&amp;lt;range_value_t&amp;lt;OR&amp;gt;, range_rvalue_reference_t&amp;lt;IR&amp;gt;&amp;gt;
+  uninitialized_move_result&amp;lt;
+    borrowed_iterator_t&amp;lt;IR&amp;gt;,
+    borrowed_iterator_t&amp;lt;OR&amp;gt;
+  &amp;gt;
+    uninitialized_move(Ep&amp;amp;&amp;amp; exec,
+                       IR&amp;amp;&amp;amp; in_range, OR&amp;amp;&amp;amp; out_range);          // (4) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -42,12 +62,18 @@ namespace std::ranges {
 * constructible_from[link /reference/concepts/constructible_from.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -97,6 +123,7 @@ return {std::move(ifirst), ofirst};
 またその場合、`[ifirst, ilast)`内の一部のオブジェクトは有効だが未規定な状態として残される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -144,6 +171,40 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;test&amp;#34;};
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* dst = alloc.allocate(3);
+
+  // 並列に未初期化領域へムーブ
+  std::ranges::uninitialized_move(
+    std::execution::par, src, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_move[color ff0000]
+
+#### 出力
+```
+hello world test
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -161,3 +222,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_move_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move_n.md b/reference/memory/ranges_uninitialized_move_n.md
index 044b99e9f..945884f49 100644
--- a/reference/memory/ranges_uninitialized_move_n.md
+++ b/reference/memory/ranges_uninitialized_move_n.md
@@ -31,17 +31,35 @@ namespace std::ranges {
       O ofirst,
       S olast
     );                               // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_rvalue_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_move_n_result&amp;lt;I, O&amp;gt;
+    uninitialized_move_n(
+      Ep&amp;amp;&amp;amp; exec,
+      I ifirst,
+      iter_difference_t&amp;lt;I&amp;gt; n,
+      O ofirst,
+      S olast
+    );                               // (2) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してムーブ出力する。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +95,7 @@ return {std::move(t.in).base(), t.out};
 またその場合、`[ifirst, ifirst + n)`内の一部のオブジェクトは有効だが未規定な状態として残される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -123,6 +142,40 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;test&amp;#34;};
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* dst = alloc.allocate(3);
+
+  // 並列に3要素を未初期化領域へムーブ
+  std::ranges::uninitialized_move_n(
+    std::execution::par, src.begin(), 3, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_move_n[color ff0000]
+
+#### 出力
+```
+hello world test
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -140,3 +193,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_value_construct.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct.md b/reference/memory/ranges_uninitialized_value_construct.md
index 2e1d24423..587a6be87 100644
--- a/reference/memory/ranges_uninitialized_value_construct.md
+++ b/reference/memory/ranges_uninitialized_value_construct.md
@@ -23,18 +23,38 @@ namespace std::ranges {
     requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_value_construct(R&amp;amp;&amp;amp; r);            // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_value_construct(Ep&amp;amp;&amp;amp; exec,
+                                  I first, S last);  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_value_construct(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r); // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素を値構築する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -73,6 +93,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -120,6 +141,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列に値初期化
+  std::ranges::uninitialized_value_construct(
+    std::execution::par, p, p + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_value_construct[color ff0000]
+
+#### 出力
+```
+0 0 0
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -137,3 +188,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_value_construct_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct_n.md b/reference/memory/ranges_uninitialized_value_construct_n.md
index be0805925..03103a277 100644
--- a/reference/memory/ranges_uninitialized_value_construct_n.md
+++ b/reference/memory/ranges_uninitialized_value_construct_n.md
@@ -16,13 +16,26 @@ namespace std::ranges {
   constexpr I
     uninitialized_value_construct_n(I first,
                                     iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_value_construct_n(Ep&amp;amp;&amp;amp; exec,
+                                    I first,
+                                    iter_difference_t&amp;lt;I&amp;gt; n); // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) の各要素を値構築する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -47,6 +60,7 @@ return uninitialized_value_construct(counted_iterator(first, n),
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -93,6 +107,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個値初期化
+  std::ranges::uninitialized_value_construct_n(
+    std::execution::par, p, 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_value_construct_n[color ff0000]
+
+#### 出力
+```
+0 0 0
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +154,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/ranges.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/ranges.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges.md b/reference/ranges.md
index 6956f1b61..395b20031 100644
--- a/reference/ranges.md
+++ b/reference/ranges.md
@@ -91,6 +91,7 @@ C++20では関数によるカスタマイゼーションポイントの問題点
 | [`common_range`](ranges/common_range.md)               | イテレータと番兵の型が等しいRange (concept)                 | C++20          |
 | [`viewable_range`](ranges/viewable_range.md)           | ビューに変換できるRange (concept)                           | C++20          |
 | [`constant_range`](ranges/constant_range.md)           | 要素が定数なRange (concept)                           | C++23          |
+| [`sized-random-access-range`](ranges/sized-random-access-range.md) | サイズ付きランダムアクセスRange (説明専用concept) | C++26          |
 
 ## カスタマイゼーションポイント
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sized-random-access-range -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/ranges/sized-random-access-range.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/ranges/sized-random-access-range.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/sized-random-access-range.md b/reference/ranges/sized-random-access-range.md
new file mode 100644
index 000000000..c6b5e78a6
--- /dev/null
+++ b/reference/ranges/sized-random-access-range.md
@@ -0,0 +1,27 @@
+# sized-random-access-range
+* ranges[meta header]
+* concept[meta id-type]
+* std::ranges[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class R&amp;gt;
+  concept sized-random-access-range =
+    random_access_range&amp;lt;R&amp;gt; &amp;amp;&amp;amp; sized_range&amp;lt;R&amp;gt;;
+}
+```
+* random_access_range[link random_access_range.md]
+* sized_range[link sized_range.md]
+
+## 概要
+`sized-random-access-range`は、範囲`R`が[`random_access_range`](random_access_range.md)かつ[`sized_range`](sized_range.md)であることを表す説明専用のコンセプトである。
+
+このコンセプトは、並列Rangeアルゴリズムのテンプレートパラメータ制約として使用される。並列アルゴリズムでは、範囲のサイズが既知であり、かつランダムアクセスが可能である必要がある。
+
+## バージョン
+### 言語
+- C++26
+
+## 参照
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- fix link</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait.html"/>
      <id>fb7390f3b3db3edb315cf55792e6c79a35b001ee:reference/condition_variable/condition_variable_any/wait.md</id>
      <updated>2026-02-03T20:11:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait.md b/reference/condition_variable/condition_variable_any/wait.md
index 32a396579..00b11ff36 100644
--- a/reference/condition_variable/condition_variable_any/wait.md
+++ b/reference/condition_variable/condition_variable_any/wait.md
@@ -57,7 +57,7 @@ while (!stoken.stop_requested()) {
 }
 return pred();
 ```
-* stop_requested()[link /reference/stop_token/stop_source/stop_requested.md]
+* stop_requested()[link /reference/stop_token/stop_token/stop_requested.md]
 
 
 ## 事後条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_until -- fix link</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait_until.html"/>
      <id>fb7390f3b3db3edb315cf55792e6c79a35b001ee:reference/condition_variable/condition_variable_any/wait_until.md</id>
      <updated>2026-02-03T20:11:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait_until.md b/reference/condition_variable/condition_variable_any/wait_until.md
index b319626c9..50d998e08 100644
--- a/reference/condition_variable/condition_variable_any/wait_until.md
+++ b/reference/condition_variable/condition_variable_any/wait_until.md
@@ -70,7 +70,7 @@ while (!stoken.stop_requested()) {
 }
 return pred();
 ```
-* stop_requested()[link /reference/stop_token/stop_source/stop_requested.md]
+* stop_requested()[link /reference/stop_token/stop_token/stop_requested.md]
 * cv_status::timeout[link /reference/condition_variable/cv_status.md]
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++26 -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/lang/cpp26.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:lang/cpp26.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++26&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++26とは、2026年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中のためC++2cと呼ばれることがある。「(2020年代の3つ目のバージョンが) 202c年にリリースされる」という伏せ字として「c」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/static_storage_for_braced_initializers.html&#34;&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;の配列を静的記憶域に配置する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::vector v = {1, 2, 3};&lt;/code&gt;のような初期化で初期化子リストを静的記憶域に配置することで無駄なコピーをなくす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/nice_placeholder_with_no_name.html&#34;&gt;宣言のみで使用しない変数の名前として&lt;code&gt;_&lt;/code&gt;をサポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数名&lt;code&gt;_&lt;/code&gt;は暗黙で&lt;code&gt;[[maybe_unused]]&lt;/code&gt;が指定される&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/deleting_a_pointer_to_an_incomplete_type_should_be_ill-formed.html&#34;&gt;不完全型へのポインタに対する&lt;code&gt;delete&lt;/code&gt;を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;未定義動作を引き起こす操作をコンパイルエラーとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/disallow_binding_a_returned_glvalue_to_a_temporary.html&#34;&gt;返却された左辺値から暗黙変換された一時オブジェクトが参照に束縛されることを禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;寿命切れの変数によって引き起こされるバグを防止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/clarifying_rules_for_brace_elision_in_aggregate_initialization.html&#34;&gt;要素数不明の配列を集成体初期化する規則を明確化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;配列要素の集成体初期化で&lt;code&gt;{}&lt;/code&gt;が省略された場合の矛盾していた規定を修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/erroneous_behavior_for_uninitialized_reads.html&#34;&gt;未初期化変数の読み取りをエラー性動作とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化されていない自動変数の読み取りの安全性を規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/structured_bindings_can_introduce_a_pack.html&#34;&gt;構造化束縛でパックを導入できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;タプルを分解する際に複数の変数をパックとして宣言できるようにする。&lt;code&gt;auto [a, ...xs] = f();&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/making_non-encodable_string_literals_ill-formed.html&#34;&gt;文字列リテラルの文字エンコーディング失敗を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルのエンコーディング時に文字表現が失われる場合にコンパイルエラーにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/unevaluated_strings.md.nolink&#34;&gt;コンパイル時にのみ使用される文字列の扱いを明確化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static_assert&lt;/code&gt;や&lt;code&gt;[[deprecated]]&lt;/code&gt;などで使用されるコンパイル時の文字列について、文字コードの指定を禁止し、実行時エンコーディングが行われないことを規定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;分岐・ループ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/structured_binding_declaration_as_a_condition.html&#34;&gt;条件式での構造化束縛の使用を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;式全体を&lt;code&gt;bool&lt;/code&gt;値に変換できる場合に条件式で構造化束縛を使用できることとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/trivial_infinite_loops_are_not_undefined_behavior.html&#34;&gt;空の無限ループは未定義動作ではないと規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;並行プログラムの進行保証などを考慮して空の無限ループを未定義動作ではないものとする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/delete_reason.html&#34;&gt;関数宣言を削除する理由を指定できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;f() = delete(&#34;reason&#34;);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/contracts.html&#34;&gt;契約プログラミングをサポートする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の事前条件、事後条件、不変条件を記述できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/trivial_unions.md.nolink&#34;&gt;共用体をトリビアルに未初期化できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;での&lt;code&gt;union U { T storage[N]; };&lt;/code&gt;を許可し、未初期化にできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;属性&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/on_the_ignorability_of_standard_attributes.html&#34;&gt;属性の無視性を見直し&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構文として適格な属性のみを無視できるようにし、そうでない属性の使用を&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/attributes_for_structured_bindings.html&#34;&gt;構造化束縛への属性を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto [a, b [[maybe_unused]], c] = f();&lt;/code&gt;のように構造化束縛の要素に対して属性を付加できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/pack_indexing.html&#34;&gt;パラメータパックへのインデックスアクセスを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;可変引数テンプレートのパラメータパックに添字アクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/ordering_of_constraints_involving_fold_expressions.md.nolink&#34;&gt;制約式内での畳み込み式の順序付け&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;畳み込み式では全体ではなく個別の制約を原子制約式として扱う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/variadic_friends.html&#34;&gt;可変引数テンプレートで&lt;code&gt;friend&lt;/code&gt;宣言をできるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートの可変引数テンプレートでまとめて&lt;code&gt;friend&lt;/code&gt;宣言できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/concept_and_variable-template_template-parameters.md.nolink&#34;&gt;コンセプトと変数テンプレートにテンプレートテンプレートパラメータのサポートを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレート引数をあとで指定するテンプレートテンプレートパラメータを、コンセプトと変数テンプレートでも使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/reflection.md.nolink&#34;&gt;静的リフレクション&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リフレクション演算子&lt;code&gt;^^&lt;/code&gt;と&lt;code&gt;std::meta::info&lt;/code&gt;型によりコンパイル時にさまざまな情報を取得できる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/expansion_statements.md.nolink&#34;&gt;コンパイル時のタプルやリストを展開処理する&lt;code&gt;template for&lt;/code&gt;文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラス・タプル・Range・パラメータパックなどを展開してすべての要素をコンパイル時の処理する&lt;code&gt;template for&lt;/code&gt;文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_cast_from_voidptr.html&#34;&gt;定数式での&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型消去のために&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/user-generated_static_assert_messages.html&#34;&gt;&lt;code&gt;static_assert&lt;/code&gt;の診断メッセージにユーザーが生成した文字列の指定を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;な&lt;code&gt;S.size()&lt;/code&gt;と&lt;code&gt;S.data()&lt;/code&gt;メンバ関数をもつオブジェクトをコンパイル時文字列として指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_placement_new.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;配置&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式の文脈での配置&lt;code&gt;new&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_structured_bindings_and_references_to_constexpr_variables.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;構造化束縛の許可と、&lt;code&gt;constexpr&lt;/code&gt;参照の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式に対する構造化束縛を許可し、関連して&lt;code&gt;constexpr&lt;/code&gt;参照の制限を緩和して自動変数も参照できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/allowing_exception_throwing_in_constant-evaluation.html&#34;&gt;定数評価での例外送出を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式の文脈での例外の送出と捕捉を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_virtual_inheritance.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;仮想継承を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式の文脈での仮想継承を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/embed.html&#34;&gt;ファイルを読み込む&lt;code&gt;#embed&lt;/code&gt;命令を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;バイナリファイルをインクルードするメカニズム。&lt;code&gt;#include&lt;/code&gt;とちがって読み出しサイズなどの柔軟な指定ができる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/preprocessing_is_never_undefined.md.nolink&#34;&gt;プリプロセッサ仕様での「未定義動作」を不適格 (診断不要) に変更&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサとレキサーの文脈での「未定義動作」用語を&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt; (診断不要) に変更&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ソースコード&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/add_atsign_dollar_graveaccent_to_the_basic_character_set.html&#34;&gt;基本文字集合に@、$、`を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C言語との互換性のためにこれらの文字を基本文字集合に追加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/module_declarations_shouldnt_be_macros.html&#34;&gt;モジュール宣言でのモジュール名のマクロ展開を禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;export module MACRO_NAME;&lt;/code&gt;を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/allow_attaching_main_to_the_global_module.md.nolink&#34;&gt;&lt;code&gt;main&lt;/code&gt;関数をグローバルモジュールに含められるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;main&lt;/code&gt;関数に&lt;code&gt;extern &#34;C++&#34;&lt;/code&gt;を指定できるようにすることで名前付きモジュールに含められるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/allow_line_before_module_declarations.md.nolink&#34;&gt;モジュール宣言より前での&lt;code&gt;#line&lt;/code&gt;ディレクティブの使用を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;モジュール宣言より前での&lt;code&gt;#line&lt;/code&gt;ディレクティブの使用を禁止していたのは過度な制限だった&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/the_oxford_variadic_comma.html&#34;&gt;先行するカンマのない省略記号を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void f(int, ...);&lt;/code&gt;はOK。&lt;code&gt;void f(int...);&lt;/code&gt;は非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/remove_deprecated_array_comparisons.html&#34;&gt;非推奨だった組み込み配列の比較を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++20で非推奨となっていた配列比較を削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/remove_deprecated_arithmetic_conversion_on_enumerations.html&#34;&gt;非推奨となっていた列挙型の算術変換を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++20から非推奨となっていた列挙値への算術演算で算術型に暗黙変換される仕様を削除&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字列エンコーディングを識別するライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/text_encoding.md.nolink&#34;&gt;&amp;lt;text_encoding&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;要素のメモリ位置が安定するシーケンスコンテナのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/hive.md.nolink&#34;&gt;&amp;lt;hive&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理におけるデータの参照・更新を行うRCU (Read Copy Update) のライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/rcu.html&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理において参照中のデータが更新されないよう保護するハザードポインタのライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;データ並列ライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/simd.md.nolink&#34;&gt;&amp;lt;simd&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;デバッグサポートのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/debugging.html&#34;&gt;&amp;lt;debugging&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;線形代数ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/linalg.html&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コンパイル時に容量を固定する可変長配列クラスのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/inplace_vector.md.nolink&#34;&gt;&amp;lt;inplace_vector&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;C23の互換ライブラリとして、ビット操作ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/stdbit.h.md.nolink&#34;&gt;&amp;lt;stdbit.h&amp;gt;&lt;/a&gt;&lt;/code&gt;と、検査付き整数演算ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/stdckdint.h.md.nolink&#34;&gt;&amp;lt;stdckdint.h&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。&lt;code&gt;&amp;lt;cstd…&amp;gt;&lt;/code&gt;形式のライブラリは追加されない&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;全体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;標準ライブラリに付加された、戻り値を無視した際に警告を出力する&lt;a href=&#34;cpp17/nodiscard.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性&lt;/a&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/vector/vector.html&#34;&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/a&gt;&lt;/code&gt;のプロキシ操作として、&lt;code&gt;const&lt;/code&gt;修飾付きの代入と&lt;code&gt;swap()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;から部分ビューを取り出す&lt;code&gt;&lt;a href=&#34;../reference/mdspan/submdspan.html&#34;&gt;std::submdspan()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;に、インデックスを指定して要素を取り出す&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;に対する&lt;code&gt;&lt;a href=&#34;../reference/mdspan/extents.html&#34;&gt;std::dextents&lt;/a&gt;&lt;/code&gt;指定の冗長さを解決する&lt;code&gt;&lt;a href=&#34;../reference/mdspan/extents.html&#34;&gt;std::dims&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;のレイアウトとして、&lt;code&gt;&lt;a href=&#34;../reference/mdspan/layout_left_padded.html&#34;&gt;std::layout_left_padded&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/mdspan/layout_right_padded.html&#34;&gt;std::layout_right_padded&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素アクセスにアライメント保証を与える&lt;code&gt;&lt;a href=&#34;../reference/mdspan/aligned_accessor.html&#34;&gt;std::aligned_accessor&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/span/span.html&#34;&gt;std::span&lt;/a&gt;&lt;/code&gt;に、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;をとるコンストラクタ&lt;/li&gt;
&lt;li&gt;インデックスアクセスのための&lt;code&gt;&lt;a href=&#34;../reference/span/span/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;連想コンテナの以下のメンバ関数に、一時オブジェクトが生成されるコストを抑える拡張を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map.html&#34;&gt;std::map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/set.html&#34;&gt;std::set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_multimap.html&#34;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_multimap/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_multiset.html&#34;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_multiset/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/span/span.html&#34;&gt;std::span&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;の推論補助を改善&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/concat_view.html&#34;&gt;std::views::concat&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/cache_latest.md.nolink&#34;&gt;std::views::cache_latest&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/to_input_view.html&#34;&gt;std::views::to_input&lt;/a&gt;&lt;/code&gt;を追加。これはパフォーマンス向上のために、Rangeを入力Rangeかつ非&lt;code&gt;&lt;a href=&#34;../reference/ranges/common_range.html&#34;&gt;common_range&lt;/a&gt;&lt;/code&gt; (イテレータと番兵の型を別する) に変換する&lt;/li&gt;
&lt;li&gt;Range関係の、償却定数時間での要素追加を行う機能を追加&lt;ul&gt;
&lt;li&gt;各viewクラスに&lt;code&gt;reserve_hint()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/reserve_hint.md.nolink&#34;&gt;std::ranges::reserve_hint()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/approximately_sized_range.md.nolink&#34;&gt;std::ranges::approximately_sized_range&lt;/a&gt;&lt;/code&gt;コンセプトを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;インデックス列を生成する&lt;code&gt;&lt;a href=&#34;../reference/ranges/indices.md.nolink&#34;&gt;std::views::indices&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;連続イテレータのコンセプト&lt;code&gt;&lt;a href=&#34;../reference/iterator/contiguous_iterator.html&#34;&gt;contiguous_iterator&lt;/a&gt;&lt;/code&gt;に、ポインタに変換できることを要件として追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;クラスを以下のように変更&lt;ul&gt;
&lt;li&gt;独自に定義されていた&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list/begin_free.html&#34;&gt;std::begin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list/end_free.html&#34;&gt;std::end()&lt;/a&gt;&lt;/code&gt;のオーバーロードを削除 (&lt;code&gt;std::cbegin()&lt;/code&gt;や&lt;code&gt;std::rend()&lt;/code&gt;のようなオーバーロードがなかったため、ほかとの不整合があった)&lt;/li&gt;
&lt;li&gt;メンバ関数&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list/data.html&#34;&gt;data()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;メンバ関数&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list/empty.html&#34;&gt;empty()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/valarray/valarray.html&#34;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;クラスを以下のように変更&lt;ul&gt;
&lt;li&gt;独自に定義されていた&lt;code&gt;&lt;a href=&#34;../reference/valarray/valarray/begin_free.html&#34;&gt;std::begin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/valarray/valarray/end_free.html&#34;&gt;std::end()&lt;/a&gt;&lt;/code&gt;のオーバーロードを削除 (&lt;code&gt;std::cbegin()&lt;/code&gt;や&lt;code&gt;std::rend()&lt;/code&gt;のようなオーバーロードがなかったため、ほかとの不整合があった)&lt;/li&gt;
&lt;li&gt;メンバ型&lt;code&gt;iterator&lt;/code&gt; / &lt;code&gt;const_iterator&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;メンバ関数&lt;code&gt;&lt;a href=&#34;../reference/valarray/valarray/begin.html&#34;&gt;begin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/valarray/valarray/end.html&#34;&gt;end()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;イテレータインタフェースの非メンバ関数&lt;code&gt;&lt;a href=&#34;../reference/iterator/begin.html&#34;&gt;std::begin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/end.html&#34;&gt;std::end()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/cbegin.html&#34;&gt;std::cbegin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/cend.html&#34;&gt;std::cend()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/rbegin.html&#34;&gt;std::rbegin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/rend.html&#34;&gt;std::rend()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/crbegin.html&#34;&gt;std::crbegin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/crend.html&#34;&gt;std::crend()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/size.html&#34;&gt;std::size()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/ssize.html&#34;&gt;std::ssize()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/empty.html&#34;&gt;std::empty()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/iterator/data.html&#34;&gt;std::data()&lt;/a&gt;&lt;/code&gt;を以下のように変更&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;型に対するオーバーロードを削除 (専用のオーバーロードを用意しなくても汎用オーバーロードが使用できるようになった)&lt;/li&gt;
&lt;li&gt;条件付き&lt;code&gt;noexcept&lt;/code&gt;指定を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rangeインタフェースの非メンバ関数&lt;code&gt;&lt;a href=&#34;../reference/ranges/begin.html&#34;&gt;std::ranges::begin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/end.html&#34;&gt;std::ranges::end()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/cbegin.html&#34;&gt;std::ranges::cbegin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/cend.html&#34;&gt;std::ranges::cend()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/rbegin.html&#34;&gt;std::ranges::rbegin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/rend.html&#34;&gt;std::ranges::rend()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/crbegin.html&#34;&gt;std::ranges::crbegin()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/crend.html&#34;&gt;std::ranges::crend()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/size.html&#34;&gt;std::ranges::size()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/ssize.html&#34;&gt;std::ranges::ssize()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/empty.html&#34;&gt;std::ranges::empty()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/ranges/data.html&#34;&gt;std::ranges::data()&lt;/a&gt;&lt;/code&gt;を以下のように変更&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;型に対するオーバーロードを削除 (専用のオーバーロードを用意しなくても汎用オーバーロードが使用できるようになった)&lt;/li&gt;
&lt;li&gt;条件付き&lt;code&gt;noexcept&lt;/code&gt;指定を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以下のコンテナを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/deque/deque.html&#34;&gt;std::deque&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map.html&#34;&gt;std::map&lt;/a&gt;&lt;/code&gt; (ただし&lt;code&gt;&lt;a href=&#34;../reference/node_handle/node_handle.html&#34;&gt;node_handle&lt;/a&gt;::&lt;a href=&#34;../reference/node_handle/node_handle/key.html&#34;&gt;key()&lt;/a&gt;&lt;/code&gt;を使用すると未定義動作)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/multimap.html&#34;&gt;std::multimap&lt;/a&gt;&lt;/code&gt; (ただし&lt;code&gt;&lt;a href=&#34;../reference/node_handle/node_handle.html&#34;&gt;node_handle&lt;/a&gt;::&lt;a href=&#34;../reference/node_handle/node_handle/key.html&#34;&gt;key()&lt;/a&gt;&lt;/code&gt;を使用すると未定義動作)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/set.html&#34;&gt;std::set&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/multiset.html&#34;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; (ハッシュ関数のカスタム化が必要) (ただし&lt;code&gt;&lt;a href=&#34;../reference/node_handle/node_handle.html&#34;&gt;node_handle&lt;/a&gt;::&lt;a href=&#34;../reference/node_handle/node_handle/key.html&#34;&gt;key()&lt;/a&gt;&lt;/code&gt;を使用すると未定義動作)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_multimap.html&#34;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; (ハッシュ関数のカスタム化が必要) (ただし&lt;code&gt;&lt;a href=&#34;../reference/node_handle/node_handle.html&#34;&gt;node_handle&lt;/a&gt;::&lt;a href=&#34;../reference/node_handle/node_handle/key.html&#34;&gt;key()&lt;/a&gt;&lt;/code&gt;を使用すると未定義動作)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; (ハッシュ関数のカスタム化が必要)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_multiset.html&#34;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; (ハッシュ関数のカスタム化が必要)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/flat_map/flat_map.html&#34;&gt;std::flat_map&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/flat_map/flat_multimap.html&#34;&gt;std::flat_multimap&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/flat_set/flat_set.html&#34;&gt;std::flat_set&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/flat_set/flat_multiset.html&#34;&gt;std::flat_multiset&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/queue/queue.html&#34;&gt;std::queue&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/queue/priority_queue.html&#34;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stack/stack.html&#34;&gt;std::stack&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;のアルゴリズムを並列実行に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のアルゴリズムを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/stable_sort.html&#34;&gt;std::stable_sort()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_stable_sort.html&#34;&gt;std::ranges::stable_sort()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/stable_partition.html&#34;&gt;std::stable_partition()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_stable_partition.html&#34;&gt;std::ranges::stable_partition()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/inplace_merge.html&#34;&gt;std::inplace_merge()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_inplace_merge.html&#34;&gt;std::ranges::inplace_merge()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のアルゴリズムを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_default_construct.html&#34;&gt;std::uninitialized_default_construct()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_default_construct.html&#34;&gt;std::ranges::uninitialized_default_construct()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_default_construct_n.html&#34;&gt;std::uninitialized_default_construct_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_default_construct_n.html&#34;&gt;std::ranges::uninitialized_default_construct_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_value_construct.html&#34;&gt;std::uninitialized_value_construct()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_value_construct.html&#34;&gt;std::ranges::uninitialized_value_construct()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_value_construct_n.html&#34;&gt;std::uninitialized_value_construct_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_value_construct_n.html&#34;&gt;std::ranges::uninitialized_value_construct_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_copy.html&#34;&gt;std::uninitialized_copy()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_copy.html&#34;&gt;std::ranges::uninitialized_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_copy_n.html&#34;&gt;std::uninitialized_copy_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_copy_n.html&#34;&gt;std::ranges::uninitialized_copy_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_move.html&#34;&gt;std::uninitialized_move()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_move.html&#34;&gt;std::ranges::uninitialized_move()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_move_n.html&#34;&gt;std::uninitialized_move_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_move_n.html&#34;&gt;std::ranges::uninitialized_move_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_fill.html&#34;&gt;std::uninitialized_fill()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_fill.html&#34;&gt;std::ranges::uninitialized_fill()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_fill_n.html&#34;&gt;std::uninitialized_fill_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_fill_n.html&#34;&gt;std::ranges::uninitialized_fill_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rangeアルゴリズムが完全型を要求しないようにするため、&lt;code&gt;&lt;a href=&#34;../reference/iterator/projected.html&#34;&gt;std::projected&lt;/a&gt;&lt;/code&gt;の制約を緩和&lt;/li&gt;
&lt;li&gt;以下のアルゴリズムに、値を波カッコ初期化で渡せるよう制約を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/deque/deque.html&#34;&gt;std::deque&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/deque/deque/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/list/list/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/vector/vector/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/find.html&#34;&gt;std::find()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_find.html&#34;&gt;std::ranges::find()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_find_last.html&#34;&gt;std::ranges::find_last()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/count.html&#34;&gt;std::count()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_count.html&#34;&gt;std::ranges::count()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/search_n.html&#34;&gt;std::search_n()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_search_n.html&#34;&gt;std::ranges::search_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace.html&#34;&gt;std::replace()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace.html&#34;&gt;std::ranges::replace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_if.html&#34;&gt;std::replace_if()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_if.html&#34;&gt;std::ranges::replace_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy.html&#34;&gt;std::ranges::replace_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy_if.html&#34;&gt;std::replace_copy_if()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy_if.html&#34;&gt;std::ranges::replace_copy_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/fill.html&#34;&gt;std::fill()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fill.html&#34;&gt;std::ranges::fill()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/fill_n.html&#34;&gt;std::fill_n()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fill_n.html&#34;&gt;std::ranges::fill_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/remove.html&#34;&gt;std::remove()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_remove.html&#34;&gt;std::ranges::remove()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/remove_copy.html&#34;&gt;std::remove_copy()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_remove_copy.html&#34;&gt;std::ranges::remove_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/lower_bound.html&#34;&gt;std::lower_bound()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_lower_bound.html&#34;&gt;std::ranges::lower_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/upper_bound.html&#34;&gt;std::upper_bound()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_upper_bound.html&#34;&gt;std::ranges::upper_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/equal_range.html&#34;&gt;std::equal_range()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_equal_range.html&#34;&gt;std::ranges::equal_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/binary_search.html&#34;&gt;std::binary_search()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_binary_search.html&#34;&gt;std::ranges::binary_search()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fold_left.html&#34;&gt;std::ranges::fold_left()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fold_right.html&#34;&gt;std::ranges::fold_right()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_contains.html&#34;&gt;std::ranges::contains()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有権を保持しない&lt;code&gt;&lt;a href=&#34;../reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/functional/function_ref.html&#34;&gt;std::function_ref&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/move_only_function.html&#34;&gt;std::move_only_function&lt;/a&gt;&lt;/code&gt;のコピー可能版として、&lt;code&gt;&lt;a href=&#34;../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/functional/copyable_function.html&#34;&gt;std::copyable_function&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/functional/bind_back.html&#34;&gt;std::bind_back()&lt;/a&gt;&lt;/code&gt;に、非型テンプレート引数として関数を指定するオーバーロードを追加&lt;ul&gt;
&lt;li&gt;関連して、非型テンプレート引数の関数オブジェクトを反転させられるよう、&lt;code&gt;&lt;a href=&#34;../reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;に非型テンプレート引数版のオーバーロードを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;に、比較演算子&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper/op_equal.html&#34;&gt;==&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper/op_compare_3way.html&#34;&gt;&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/charconv.html&#34;&gt;&amp;lt;charconv&amp;gt;&lt;/a&gt;&lt;/code&gt;の変換結果&lt;code&gt;&lt;a href=&#34;../reference/charconv/to_chars_result.html&#34;&gt;std::to_chars_result&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/charconv/from_chars_result.html&#34;&gt;std::from_chars_result&lt;/a&gt;&lt;/code&gt;に、変換が正しく完了したかを判定する&lt;code&gt;operator bool&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;の仕様が&lt;code&gt;std::sprintf()&lt;/code&gt;で説明されていたが、&lt;code&gt;&lt;a href=&#34;../reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;で定義するよう仕様を変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_istringstream.html&#34;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;および&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_ostringstream.html&#34;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;のコンストラクタおよび&lt;code&gt;str()&lt;/code&gt;メンバ関数に、&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;に、以下の改善を導入&lt;ul&gt;
&lt;li&gt;ポインタ出力のサポートを追加&lt;/li&gt;
&lt;li&gt;幅と精度を動的に指定した場合でも型の検証がコンパイル時に行われるよう仕様を見直し&lt;/li&gt;
&lt;li&gt;コンパイル時の書式文字列だけでなく、実行時の書式文字列を渡せるよう仕様修正&lt;/li&gt;
&lt;li&gt;非ロケール版を&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/string/to_wstring.html&#34;&gt;std::to_wstring()&lt;/a&gt;&lt;/code&gt;の整数オーバーロードが&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、部分文字列を&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;として取得するメンバ関数&lt;code&gt;subview()&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;として連結させる&lt;code&gt;operator+&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイル&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ファイルのネイティブハンドルを取得できるよう、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_filebuf.html&#34;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_ifstream.html&#34;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_ofstream.html&#34;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_fstream.html&#34;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;クラスに、以下のメンバを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;native_handle_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native_handle()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path.html&#34;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt;クラスに、文字列フォーマットのサポートを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path.html&#34;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt;クラスに、出力用の文字列を取得するための、以下のメンバ関数を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path/display_string.md.nolink&#34;&gt;display_string()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path/system_encoded_string.md.nolink&#34;&gt;system_encoded_string()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path/generic_display_string.md.nolink&#34;&gt;generic_display_string()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path/generic_system_encoded_string.md.nolink&#34;&gt;generic_system_encoded_string()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/print.html&#34;&gt;std::print()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;に、ロックを取得せず高速に書き出す最適化を許可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;に、改行のみを出力するオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/print.html&#34;&gt;std::print()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;をより高速にできる最適化が可能か判定する&lt;code&gt;&lt;a href=&#34;../reference/format/enable_nonlocking_formatter_optimization.html&#34;&gt;std::enable_nonlocking_formatter_optimization&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/istream/basic_istream.html&#34;&gt;std::basic_istream&lt;/a&gt;::&lt;a href=&#34;../reference/istream/basic_istream/ignore.html&#34;&gt;ignore()&lt;/a&gt;&lt;/code&gt;メンバ関数に、区切り文字として&lt;code&gt;char&lt;/code&gt;型をとるオーバーロードを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列・非同期処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に汎用的な非同期実行を管理するフレームワークを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;オブジェクトに対する2つの値の最大値・最小値を取得する関数として、以下を追加&lt;ul&gt;
&lt;li&gt;メンバ関数&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_max.html&#34;&gt;fetch_max()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_min.html&#34;&gt;fetch_min()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_fmaximum.html&#34;&gt;fetch_fmaximum()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_fminimum.html&#34;&gt;fetch_fminimum()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_fmaximum_num.html&#34;&gt;fetch_fmaximum_num()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_fminimum_num.html&#34;&gt;fetch_fminimum_num()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非メンバ関数として&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_max.html&#34;&gt;std::atomic_fetch_max()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_max_explicit.html&#34;&gt;std::atomic_fetch_max_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_min.html&#34;&gt;std::atomic_fetch_min()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_min_explicit.html&#34;&gt;std::atomic_fetch_min_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;クラスに、現在の値を読み込まず (fetchせず) に加算などをする高速な縮約用の操作として、以下を追加&lt;ul&gt;
&lt;li&gt;メンバ関数&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_add.html&#34;&gt;store_add()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_sub.html&#34;&gt;store_sub()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_and.html&#34;&gt;store_and()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_or.html&#34;&gt;store_or()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_xor.html&#34;&gt;store_xor()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_max.html&#34;&gt;store_max()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_min.html&#34;&gt;store_min()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_fmaximum.html&#34;&gt;store_fmaximum()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_fminimum.html&#34;&gt;store_fminimum()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_fmaximum_num.html&#34;&gt;store_fmaximum_num()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/store_fminimum_num.html&#34;&gt;store_fminimum_num()&lt;/a&gt;&lt;/code&gt; (浮動小数点数用)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非メンバ関数&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_add.html&#34;&gt;std::atomic_store_add()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_add_explicit.html&#34;&gt;std::atomic_store_add_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_sub.html&#34;&gt;std::atomic_store_sub()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_sub_explicit.html&#34;&gt;std::atomic_store_sub_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_and.html&#34;&gt;std::atomic_store_and()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_and_explicit.html&#34;&gt;std::atomic_store_and_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_or.html&#34;&gt;std::atomic_store_or()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_or_explicit.html&#34;&gt;std::atomic_store_or_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_xor.html&#34;&gt;std::atomic_store_xor()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_xor_explicit.html&#34;&gt;std::atomic_store_xor_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_max.html&#34;&gt;std::atomic_store_max()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_max_explicit.html&#34;&gt;std::atomic_store_max_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_min.html&#34;&gt;std::atomic_store_min()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_store_min_explicit.html&#34;&gt;std::atomic_store_min_explicit()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;クラスに、参照するオブジェクトのアドレスを取得する&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref/address.html&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスのテンプレートパラメータとしてCV修飾された型を禁止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;クラスのテンプレートパラメータとして、CV修飾された型を受け取れるようにした (内部でCV修飾が外される)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic.html&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリのアトミック操作を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ・メモリ関連&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;動的確保したオブジェクトに値の意味論をもたせてディープコピーさせるユーティリティクラスとして、&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/memory/indirect.md.nolink&#34;&gt;std::indirect&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/memory/polymorphic.md.nolink&#34;&gt;std::polymorphic&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;を非順序連想コンテナのキーとして使用できるよう、&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に所有権ベースのハッシュ値を取得する関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/memory/owner_hash.md.nolink&#34;&gt;std::owner_hash&lt;/a&gt;&lt;/code&gt;、および所有権ベースの等値比較を行う関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/memory/owner_equal.md.nolink&#34;&gt;std::owner_equal&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;関連して、&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;クラスのメンバ関数として、&lt;code&gt;owner_hash()&lt;/code&gt;と&lt;code&gt;owner_equal()&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスとその関連機能を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;日付・時間&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のクラスに、ハッシュ値サポートとして&lt;code&gt;&lt;a href=&#34;../reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;の特殊化を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/time_point.html&#34;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/day.html&#34;&gt;std::chrono::day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month.html&#34;&gt;std::chrono::month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year.html&#34;&gt;std::chrono::year&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday.html&#34;&gt;std::chrono::weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday_indexed.html&#34;&gt;std::chrono::weekday_indexed&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday_last.html&#34;&gt;std::chrono::weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_day.html&#34;&gt;std::chrono::month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_day_last.html&#34;&gt;std::chrono::month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_weekday.html&#34;&gt;std::chrono::month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_weekday_last.html&#34;&gt;std::chrono::month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month.html&#34;&gt;std::chrono::year_month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_day.html&#34;&gt;std::chrono::year_month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_day_last.html&#34;&gt;std::chrono::year_month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_weekday.html&#34;&gt;std::chrono::year_month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_weekday_last.html&#34;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/zoned_time.html&#34;&gt;std::chrono::zoned_time&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/leap_second.html&#34;&gt;std::chrono::leap_second&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数値&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;に、浮動小数点数の最大値・最小値を求める以下の関数を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/fmaximum.html&#34;&gt;std::fmaximum()&lt;/a&gt;&lt;/code&gt; (-0.0と+0.0では+0.0を返し、NaNと数値ではNaNを返す)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/fmaximum_num.html&#34;&gt;std::fmaximum_num()&lt;/a&gt;&lt;/code&gt; (-0.0と+0.0では+0.0を返し、NaNと数値では数値を返す)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/fminimum.html&#34;&gt;std::fminimum()&lt;/a&gt;&lt;/code&gt; (-0.0と+0.0では-0.0を返し、NaNと数値ではNaNを返す)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/fminimum_num.html&#34;&gt;std::fminimum_num()&lt;/a&gt;&lt;/code&gt; (-0.0と-0.0では+0.0を返し、NaNと数値では数値を返す)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に、飽和演算 (Saturation Arithmetic) として、型の表現可能な範囲で演算を行う以下の関数を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/add_sat.html&#34;&gt;std::add_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/sub_sat.html&#34;&gt;std::sub_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/mul_sat.html&#34;&gt;std::mul_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/div_sat.html&#34;&gt;std::div_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/saturate_cast.html&#34;&gt;std::saturate_cast()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;を構造化束縛や、将来のパターンマッチで使用できるようタプルインタフェースの特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;の範囲&lt;code&gt;[0, 1)&lt;/code&gt;の乱数を生成する&lt;code&gt;&lt;a href=&#34;../reference/random/generate_canonical.html&#34;&gt;std::generate_canonical()&lt;/a&gt;&lt;/code&gt;を、望ましい統計的性質を保証するようアルゴリズムと制約を変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に、乱数列を生成する&lt;code&gt;&lt;a href=&#34;../reference/random/generate_random.html&#34;&gt;std::ranges::generate_random()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に、乱数生成器は並列シミュレーションに効果的なカウンターベースのPhilox乱数生成器として、&lt;code&gt;&lt;a href=&#34;../reference/random/philox_engine.html&#34;&gt;std::philox_engine&lt;/a&gt;&lt;/code&gt;クラス、およびその別名である&lt;code&gt;&lt;a href=&#34;../reference/random/philox4x32.html&#34;&gt;std::philox4x32&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/random/philox4x64.html&#34;&gt;std::philox4x64&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (特殊関数と、グローバルの丸めモードに依存する丸め関数以外の全て)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atan2.html&#34;&gt;std::atan2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/exp2.html&#34;&gt;std::exp2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/expm1.html&#34;&gt;std::expm1()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log1p.html&#34;&gt;std::log1p()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log2.html&#34;&gt;std::log2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cbrt.html&#34;&gt;std::cbrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/hypot.html&#34;&gt;std::hypot()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/erf.html&#34;&gt;std::erf()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/erfc.html&#34;&gt;std::erfc()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/lgamma.html&#34;&gt;std::lgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tgamma.html&#34;&gt;std::tgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex.html&#34;&gt;&amp;lt;complex&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (すべて)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/abs.html&#34;&gt;std::abs()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/arg.html&#34;&gt;std::arg()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/proj.html&#34;&gt;std::proj()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/polar.html&#34;&gt;std::polar()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/norm.html&#34;&gt;std::norm()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/conj.html&#34;&gt;std::conj()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/imag_free.html&#34;&gt;std::imag()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/real_free.html&#34;&gt;std::real()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;クラスに、メンバ関数版の&lt;code&gt;&lt;a href=&#34;../reference/variant/variant/visit.html&#34;&gt;visit()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::monostate&lt;/code&gt;を&lt;code&gt;&lt;a href=&#34;../reference/variant.html&#34;&gt;&amp;lt;variant&amp;gt;&lt;/a&gt;&lt;/code&gt;から&lt;code&gt;&lt;a href=&#34;../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に移動&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional.html&#34;&gt;std::optional&lt;/a&gt;&lt;/code&gt;クラスに、0もしくは1要素のRangeとして扱えるようにするための拡張として、イテレータインタフェースを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iterator&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_iterator&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional/begin.html&#34;&gt;begin()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional/end.html&#34;&gt;end()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional.html&#34;&gt;std::optional&lt;/a&gt;&lt;/code&gt;に、参照を保持するための&lt;code&gt;T&amp;amp;&lt;/code&gt;の部分特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/tuple/apply.html&#34;&gt;std::apply&lt;/a&gt;&lt;/code&gt;の戻り値型推論をやめて、戻り値型用の&lt;code&gt;&lt;a href=&#34;../reference/tuple/apply_result.md.nolink&#34;&gt;std::apply_result&lt;/a&gt;&lt;/code&gt;クラスを追加し、関連する以下の機能を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_applicable.md.nolink&#34;&gt;std::is_applicable&lt;/a&gt;&lt;/code&gt;型特性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_nothrow_applicable.md.nolink&#34;&gt;std::is_nothrow_applicable&lt;/a&gt;&lt;/code&gt;型特性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/tuple/ignore.html&#34;&gt;std::ignore&lt;/a&gt;&lt;/code&gt;をファーストクラス・オブジェクトとして型を詳細に定義&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/bitset/bitset.html&#34;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るコンストラクタを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio.html&#34;&gt;&amp;lt;ratio&amp;gt;&lt;/a&gt;&lt;/code&gt;に、新たなSI接頭辞として、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;ronna&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;ronto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;quetta&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;30&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;quecto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−30&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定数式での例外送出が許可されることにともない、以下を&lt;code&gt;constexpr&lt;/code&gt;化&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception.html&#34;&gt;&amp;lt;exception&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/exception.html&#34;&gt;std::exception&lt;/a&gt;&lt;/code&gt;クラスの全メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/nested_exception.html&#34;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;クラスの全メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/bad_exception.html&#34;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/uncaught_exceptions.html&#34;&gt;std::uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/current_exception.html&#34;&gt;std::current_exception()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/rethrow_exception.html&#34;&gt;std::rethrow_exception()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/make_exception_ptr.html&#34;&gt;std::make_exception_ptr()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/throw_with_nested.html&#34;&gt;std::throw_with_nested()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/rethrow_if_nested.html&#34;&gt;std::rethrow_if_nested()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new.html&#34;&gt;&amp;lt;new&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new/bad_alloc.html&#34;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new/bad_array_new_length.html&#34;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo.html&#34;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo/bad_cast.html&#34;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo/bad_typeid.html&#34;&gt;std::bad_typeid&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;&amp;lt;stdexcept&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::domain_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::logic_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::range_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/stdexcept.html&#34;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/expected.html&#34;&gt;&amp;lt;expected&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/expected/bad_expected_access.html&#34;&gt;std::bad_expected_access&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional.html&#34;&gt;&amp;lt;optional&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/bad_optional_access.html&#34;&gt;std::bad_optional_access&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/variant.html&#34;&gt;&amp;lt;variant&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/variant/bad_variant_access.html&#34;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/format.html&#34;&gt;&amp;lt;format&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/format/format_error.html&#34;&gt;std::format_error&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、ポインタのアライメントを判定する&lt;code&gt;&lt;a href=&#34;../reference/memory/is_sufficiently_aligned.html&#34;&gt;std::is_sufficiently_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、タイムトラベル最適化を抑止するための観測可能ポイントとして&lt;code&gt;&lt;a href=&#34;../reference/utility/observable_checkpoint.md.nolink&#34;&gt;std::observable_checkpoint()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/exception_ptr.html&#34;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;を指定した例外型にキャストする&lt;code&gt;&lt;a href=&#34;../reference/exception/exception_ptr_cast.html&#34;&gt;std::exception_ptr_cast()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;に、型の順序を取得する&lt;code&gt;&lt;a href=&#34;../reference/compare/type_order.md.nolink&#34;&gt;std::type_order&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;デバッグ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cassert/assert.html&#34;&gt;assert&lt;/a&gt;&lt;/code&gt;マクロの引数としてカンマを含む式を指定できるよう、可変引数化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、共用体の指定されたメンバがアクティブかを定数式で判定するための関数として&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_within_lifetime.html&#34;&gt;std::is_within_lifetime()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、仮想継承の関係を判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_virtual_base_of.html&#34;&gt;std::is_virtual_base_of&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;../reference/type_traits/integral_constant.html&#34;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt;クラスを置き換える定数ラッパーとして&lt;code&gt;&lt;a href=&#34;../reference/type_traits/constant_wrapper.md.nolink&#34;&gt;std::constant_wrapper&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/index_sequence.html&#34;&gt;std::index_sequence&lt;/a&gt;&lt;/code&gt;クラスを&lt;a href=&#34;cpp17/structured_bindings.html&#34;&gt;構造化束縛&lt;/a&gt;と&lt;a href=&#34;cpp26/expansion_statements.md.nolink&#34;&gt;template for文&lt;/a&gt;で使用できるようにするため、タプルインタフェースの特殊化を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;制約&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;間接実行に関連する制約から、共通参照の要件を削除&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirectly_unary_invocable.html&#34;&gt;std::indirectly_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirectly_unary_invocable.html&#34;&gt;std::indirectly_regular_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_unary_predicate.html&#34;&gt;std::indirect_unary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_binary_predicate.html&#34;&gt;std::indirect_binary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_equivalence_relation.html&#34;&gt;std::indirect_equivalence_relation&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_strict_weak_order.html&#34;&gt;std::indirect_strict_weak_order&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;の&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivial.html&#34;&gt;std::is_trivial&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;ul&gt;
&lt;li&gt;これは&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivially_copyable.html&#34;&gt;std::is_trivially_copyable&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivially_default_constructible.html&#34;&gt;std::is_trivially_default_constructible&lt;/a&gt;&lt;/code&gt;の2つが合わさったものであるが、それらは異なる状況で必要になるものであった&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/memory_order.html&#34;&gt;std::memory_order::consume&lt;/a&gt;&lt;/code&gt;と、それに関連して&lt;code&gt;&lt;a href=&#34;../reference/atomic/kill_dependency.html&#34;&gt;std::kill_dependency()&lt;/a&gt;&lt;/code&gt;を非推奨化し、&lt;code&gt;&lt;a href=&#34;cpp11/attributes.html&#34;&gt;[[carries_dependency]]&lt;/a&gt;&lt;/code&gt;属性を削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path.html&#34;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt;クラスの以下のメンバ関数を非推奨化&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path/string.html&#34;&gt;string()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path/generic_string.html&#34;&gt;generic_string()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;非推奨の取り消し&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::polymorphic_allocator&lt;/a&gt;::&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;の非推奨を取り消し&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++98から非推奨となっていた&lt;code&gt;&amp;lt;strstream&amp;gt;&lt;/code&gt;ライブラリを削除&lt;/li&gt;
&lt;li&gt;C++17から非推奨となっていたUnicode変換ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/codecvt.html&#34;&gt;&amp;lt;codecvt&amp;gt;&lt;/a&gt;&lt;/code&gt;と、&lt;code&gt;&lt;a href=&#34;../reference/locale/wstring_convert.html&#34;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/locale/wbuffer_convert.html&#34;&gt;std::wbuffer_convert&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;C++20から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;../reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;のパラメータなしのオーバーロードを削除&lt;/li&gt;
&lt;li&gt;C++20から非推奨となっていた&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;に対する、以下の古いアトミック操作関数のオーバーロードを削除&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_is_lock_free.html&#34;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load.html&#34;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load_explicit.html&#34;&gt;std::atomic_load_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store.html&#34;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store_explicit.html&#34;&gt;std::atomic_store_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange.html&#34;&gt;std::atomic_exchange&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange_explicit.html&#34;&gt;std::atomic_exchange_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak.html&#34;&gt;std::atomic_compare_exchange_weak&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong.html&#34;&gt;std::atomic_compare_exchange_strong&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.html&#34;&gt;std::atomic_compare_exchange_weak_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.html&#34;&gt;std::atomic_compare_exchange_strong_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++23から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;のメンバ型&lt;code&gt;is_always_equal&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;取り決め&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C言語の参照をC17からC23に更新&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>initializer_list -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/initializer_list/initializer_list.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/initializer_list/initializer_list.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/initializer_list/initializer_list.md b/reference/initializer_list/initializer_list.md
index b68433652..d4ba9087b 100644
--- a/reference/initializer_list/initializer_list.md
+++ b/reference/initializer_list/initializer_list.md
@@ -21,9 +21,11 @@ namespace std {
 |--------------------------------|----------------|-------|
 | [`(constructor)`](initializer_list/op_constructor.md) | コンストラクタ | C++11 |
 | `~initializer_list() = default;`                      | デストラクタ | C++11 |
-| [`size`](initializer_list/size.md)                  | 要素数を取得する | C++11 |
-| [`begin`](initializer_list/begin.md)                | 先頭要素へのポインタを取得する | C++11 |
-| [`end`](initializer_list/end.md)                    | 最後尾要素の次を指すポインタを取得する | C++11 |
+| [`size`](initializer_list/size.md)                    | 要素数を取得する | C++11 |
+| [`begin`](initializer_list/begin.md)                  | 先頭要素へのポインタを取得する | C++11 |
+| [`end`](initializer_list/end.md)                      | 最後尾要素の次を指すポインタを取得する | C++11 |
+| [`data`](initializer_list/data.md)                    | 配列の先頭へのポインタを取得する | C++26 |
+| [`empty`](initializer_list/empty.md)                  | 配列が空かどうかを判定する | C++26 |
 
 
 ## メンバ型
@@ -42,8 +44,8 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |-------------------|------------|-------|
-| [`begin`](initializer_list/begin_free.md) | 先頭要素へのポインタを取得する | C++11 |
-| [`end`](initializer_list/end_free.md)     | 最後尾要素の次を指すポインタを取得する | C++11 |
+| [`begin`](initializer_list/begin_free.md) | 先頭要素へのポインタを取得する | C++11&amp;lt;br/&amp;gt;C++26で削除 |
+| [`end`](initializer_list/end_free.md)     | 最後尾要素の次を指すポインタを取得する | C++11&amp;lt;br/&amp;gt;C++26で削除 |
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>begin (非メンバ関数) -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/initializer_list/initializer_list/begin_free.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/initializer_list/initializer_list/begin_free.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/initializer_list/initializer_list/begin_free.md b/reference/initializer_list/initializer_list/begin_free.md
index 87c424f4c..7b38f0fea 100644
--- a/reference/initializer_list/initializer_list/begin_free.md
+++ b/reference/initializer_list/initializer_list/begin_free.md
@@ -3,15 +3,18 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp26removed[meta cpp]
 
 ```cpp
 template &amp;lt;class E&amp;gt;
-const E* begin(initializer_list&amp;lt;E&amp;gt; il) noexcept;           // C++11
+const E* begin(initializer_list&amp;lt;E&amp;gt; il) noexcept;           // C++11、C++26で削除
 
 template &amp;lt;class E&amp;gt;
-constexpr const E* begin(initializer_list&amp;lt;E&amp;gt; il) noexcept; // C++14
+constexpr const E* begin(initializer_list&amp;lt;E&amp;gt; il) noexcept; // C++14、C++26で削除
 ```
 
+この関数はC++26で削除された。代わりに[`&amp;lt;iterator&amp;gt;`](/reference/iterator.md)ヘッダで定義される[`std::begin()`](/reference/iterator/begin.md)関数を使用すること。[`&amp;lt;iterator&amp;gt;`](/reference/iterator.md)ヘッダの[`std::begin()`](/reference/iterator/begin.md)関数経由でメンバ関数の[`begin()`](begin.md)を呼び出せるため不要である。
+
 ## 概要
 先頭要素を指すポインタを取得する。
 
@@ -61,3 +64,4 @@ int main()
 ## 参照
 - [N3257 Range-based for statements and ADL](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3257.pdf)
 - [N3471 Constexpr Library Additions: utilities, v3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>data -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/initializer_list/initializer_list/data.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/initializer_list/initializer_list/data.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/initializer_list/initializer_list/data.md b/reference/initializer_list/initializer_list/data.md
new file mode 100644
index 000000000..c3a71e8f3
--- /dev/null
+++ b/reference/initializer_list/initializer_list/data.md
@@ -0,0 +1,60 @@
+# data
+* initializer_list[meta header]
+* std[meta namespace]
+* initializer_list[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+constexpr const E* data() const noexcept; // (1) C++26
+```
+
+## 概要
+配列の先頭へのポインタを取得する。
+
+
+## 戻り値
+配列の先頭要素を指すポインタを返す。
+
+配列の要素数が空である場合、[`begin()`](begin.md)と同じ未規定のポインタ値を返す。
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;initializer_list&amp;gt;
+
+int main()
+{
+  std::initializer_list&amp;lt;int&amp;gt; init = {1, 2, 3};
+
+  const int* p = init.data();
+
+  std::cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; std::endl;
+}
+```
+* init.data()[color ff0000]
+
+### 出力
+```
+1
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>empty -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/initializer_list/initializer_list/empty.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/initializer_list/initializer_list/empty.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/initializer_list/initializer_list/empty.md b/reference/initializer_list/initializer_list/empty.md
new file mode 100644
index 000000000..f9e1b9f15
--- /dev/null
+++ b/reference/initializer_list/initializer_list/empty.md
@@ -0,0 +1,63 @@
+# empty
+* initializer_list[meta header]
+* std[meta namespace]
+* initializer_list[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+constexpr bool empty() const noexcept; // (1) C++26
+```
+
+## 概要
+配列が空かどうかを判定する。
+
+
+## 戻り値
+```cpp
+size() == 0
+```
+* size()[link size.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;initializer_list&amp;gt;
+
+int main()
+{
+  std::initializer_list&amp;lt;int&amp;gt; init = {1, 2, 3};
+  std::initializer_list&amp;lt;int&amp;gt; empty_init = {};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; init.empty() &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; empty_init.empty() &amp;lt;&amp;lt; std::endl;
+}
+```
+* empty()[color ff0000]
+
+### 出力
+```
+false
+true
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>end (非メンバ関数) -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/initializer_list/initializer_list/end_free.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/initializer_list/initializer_list/end_free.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/initializer_list/initializer_list/end_free.md b/reference/initializer_list/initializer_list/end_free.md
index a4b91264b..b250398a9 100644
--- a/reference/initializer_list/initializer_list/end_free.md
+++ b/reference/initializer_list/initializer_list/end_free.md
@@ -3,15 +3,18 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp26removed[meta cpp]
 
 ```cpp
 template &amp;lt;class E&amp;gt;
-const E* end(initializer_list&amp;lt;E&amp;gt; il) noexcept;           // C++11
+const E* end(initializer_list&amp;lt;E&amp;gt; il) noexcept;           // C++11、C++26で削除
 
 template &amp;lt;class E&amp;gt;
-constexpr const E* end(initializer_list&amp;lt;E&amp;gt; il) noexcept; // C++14
+constexpr const E* end(initializer_list&amp;lt;E&amp;gt; il) noexcept; // C++14、C++26で削除
 ```
 
+この関数はC++26で削除された。代わりに[`&amp;lt;iterator&amp;gt;`](/reference/iterator.md)ヘッダで定義される[`std::end()`](/reference/iterator/end.md)関数を使用すること。[`&amp;lt;iterator&amp;gt;`](/reference/iterator.md)ヘッダの[`std::end()`](/reference/iterator/end.md)関数経由でメンバ関数の[`end()`](end.md)を呼び出せるため不要である。
+
 ## 概要
 最後尾要素の次を指すポインタを取得する。
 
@@ -65,3 +68,4 @@ int main()
 ## 参照
 - [N3257 Range-based for statements and ADL](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3257.pdf)
 - [N3471 Constexpr Library Additions: utilities, v3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>begin -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/begin.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/begin.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/begin.md b/reference/iterator/begin.md
index 9bb8652b1..22689d2ac 100644
--- a/reference/iterator/begin.md
+++ b/reference/iterator/begin.md
@@ -7,22 +7,40 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  auto begin(C&amp;amp; c) -&amp;gt; decltype(c.begin());                 // (1) C++11
-
+  auto
+    begin(C&amp;amp; c)
+      -&amp;gt; decltype(c.begin());       // (1) C++11
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    begin(C&amp;amp; c)
+      -&amp;gt; decltype(c.begin());       // (1) C++17
   template &amp;lt;class C&amp;gt;
-  constexpr auto begin(C&amp;amp; c) -&amp;gt; decltype(c.begin());       // (1) C++17
+  constexpr auto
+    begin(C&amp;amp; c)
+      noexcept(noexcept(c.begin()))
+      -&amp;gt; decltype(c.begin());       // (1) C++26
 
   template &amp;lt;class C&amp;gt;
-  auto begin(const C&amp;amp; c) -&amp;gt; decltype(c.begin());           // (2) C++11
+  auto
+    begin(const C&amp;amp; c)
+      -&amp;gt; decltype(c.begin());         // (2) C++11
 
   template &amp;lt;class C&amp;gt;
-  constexpr auto begin(const C&amp;amp; c) -&amp;gt; decltype(c.begin()); // (2) C++17
+  constexpr auto
+    begin(const C&amp;amp; c)
+      -&amp;gt; decltype(c.begin());         // (2) C++17
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    begin(const C&amp;amp; c)
+      noexcept(noexcept(c.begin()))
+      -&amp;gt; decltype(c.begin());         // (2) C++26
 
   template &amp;lt;class T, size_t N&amp;gt;
-  T* begin(T (&amp;amp;array)[N]);                                 // (3) C++11
-
+  T*
+    begin(T (&amp;amp;array)[N]);             // (3) C++11
   template &amp;lt;class T, size_t N&amp;gt;
-  constexpr T* begin(T (&amp;amp;array)[N]) noexcept;              // (3) C++14
+  constexpr T*
+    begin(T (&amp;amp;array)[N]) noexcept;    // (3) C++14
 }
 ```
 
@@ -106,3 +124,4 @@ int main()
 - [boost::begin() - Boost Range Library](http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/concept_implementation/semantics/functions.html)
 - [LWG2280 - begin/end for arrays should be constexpr and noexcept](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2280)
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cbegin -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/cbegin.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/cbegin.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/cbegin.md b/reference/iterator/cbegin.md
index 849fd6557..2173ba759 100644
--- a/reference/iterator/cbegin.md
+++ b/reference/iterator/cbegin.md
@@ -67,3 +67,4 @@ int main()
 
 ## 参照
 - [LWG Issue 2128. Absence of global functions `cbegin`/`cend`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cend -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/cend.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/cend.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/cend.md b/reference/iterator/cend.md
index ac7f5c720..91837eb2d 100644
--- a/reference/iterator/cend.md
+++ b/reference/iterator/cend.md
@@ -67,3 +67,4 @@ int main()
 
 ## 参照
 - [LWG Issue 2128. Absence of global functions `cbegin`/`cend`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>crbegin -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/crbegin.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/crbegin.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/crbegin.md b/reference/iterator/crbegin.md
index 52901c357..7445f8872 100644
--- a/reference/iterator/crbegin.md
+++ b/reference/iterator/crbegin.md
@@ -7,7 +7,14 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  auto crbegin(const C&amp;amp; c) -&amp;gt; decltype(std::rbegin(c));
+  auto
+    crbegin(const C&amp;amp; c)
+      -&amp;gt; decltype(std::rbegin(c));        // (1) C++14
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    crbegin(const C&amp;amp; c)
+      noexcept(noexcept(std::rbegin(c)))
+      -&amp;gt; decltype(std::rbegin(c));        // (1) C++26
 }
 ```
 * std::rbegin[link rbegin.md]
@@ -94,3 +101,4 @@ int main()
 
 ## 参照
 - [LWG Issue 2128. Absence of global functions `cbegin`/`cend`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>crend -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/crend.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/crend.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/crend.md b/reference/iterator/crend.md
index de627c147..6201900b8 100644
--- a/reference/iterator/crend.md
+++ b/reference/iterator/crend.md
@@ -7,7 +7,14 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  auto crend(const C&amp;amp; c) -&amp;gt; decltype(std::rend(c));
+  auto
+    crend(const C&amp;amp; c)
+      -&amp;gt; decltype(std::rend(c));         // (1) C++14
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    crend(const C&amp;amp; c)
+      noexcept(noexcept(std::rend(c)))
+      -&amp;gt; decltype(std::rend(c));         // (1) C++26
 }
 ```
 * std::rend[link rend.md]
@@ -94,3 +101,4 @@ int main()
 
 ## 参照
 - [LWG Issue 2128. Absence of global functions `cbegin`/`cend`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>data -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/data.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/data.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/data.md b/reference/iterator/data.md
index f4a8964c5..fc00782f8 100644
--- a/reference/iterator/data.md
+++ b/reference/iterator/data.md
@@ -7,20 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  constexpr auto data(C&amp;amp; c) -&amp;gt; decltype(c.data());          // (1) C++17
+  constexpr
+    auto data(C&amp;amp; c)
+      -&amp;gt; decltype(c.data());       // (1) C++17
+  template &amp;lt;class C&amp;gt;
+  constexpr auto data(C&amp;amp; c)
+    noexcept(noexcept(c.data()))
+    -&amp;gt; decltype(c.data());         // (1) C++26
 
   template &amp;lt;class C&amp;gt;
-  constexpr auto data(const C&amp;amp; c) -&amp;gt; decltype(c.data());    // (2) C++17
+  constexpr auto
+    data(const C&amp;amp; c)
+      -&amp;gt; decltype(c.data());       // (2) C++17
+  template &amp;lt;class C&amp;gt;
+  constexpr auto data(const C&amp;amp; c)
+    noexcept(noexcept(c.data()))
+    -&amp;gt; decltype(c.data());         // (2) C++26
 
   template &amp;lt;class T, std::size_t N&amp;gt;
-  constexpr T* data(T (&amp;amp;array)[N]) noexcept;                // (3) C++17
+  constexpr T*
+    data(T (&amp;amp;array)[N]) noexcept;  // (3) C++17
 
   template &amp;lt;class E&amp;gt;
-  constexpr const E* data(initializer_list&amp;lt;E&amp;gt; il) noexcept; // (4) C++17
+  constexpr const E*
+    data(initializer_list&amp;lt;E&amp;gt; il) noexcept;  // (4) C++17、C++26で削除
 }
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 
+(4)はC++26で削除された。[`std::initializer_list`](/reference/initializer_list/initializer_list.md)に、メンバ関数版の[`data()`](/reference/initializer_list/initializer_list/data.md)が追加されたため、このオーバーフローは不要になった。使い方としてはこれまで通りに使用できる。
+
 ## 概要
 コンテナの要素が格納されたメモリ領域へのポインタを取得する。
 
@@ -89,3 +105,4 @@ array size:1 at 0x22e42b0
 ## 参照
 - [N4280: Non-member `data()` and more (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf)
 - [LWG Issue 3009. Including `&amp;lt;string_view&amp;gt;` doesn&amp;#39;t provide `std::size/empty/data`](https://wg21.cmeerw.net/lwg/issue3009)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>empty -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/empty.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/empty.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/empty.md b/reference/iterator/empty.md
index f7d983b58..8f0010614 100644
--- a/reference/iterator/empty.md
+++ b/reference/iterator/empty.md
@@ -7,37 +7,51 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  constexpr auto empty(const C&amp;amp; c) -&amp;gt; decltype(c.empty());               // (1) C++17
+  constexpr auto
+    empty(const C&amp;amp; c)
+      -&amp;gt; decltype(c.empty());        // (1) C++17
   template &amp;lt;class C&amp;gt;
-  [[nodiscard]] constexpr auto empty(const C&amp;amp; c) -&amp;gt; decltype(c.empty()); // (1) C++20
+  [[nodiscard]] constexpr auto
+    empty(const C&amp;amp; c)
+      -&amp;gt; decltype(c.empty());        // (1) C++20
   template &amp;lt;class C&amp;gt;
-  constexpr auto empty(const C&amp;amp; c) -&amp;gt; decltype(c.empty());               // (1) C++26
+  constexpr auto
+    empty(const C&amp;amp; c)
+      noexcept(noexcept(c.empty()))
+      -&amp;gt; decltype(c.empty());        // (1) C++26
 
   template &amp;lt;class T, std::size_t N&amp;gt;
-  constexpr bool empty(const T (&amp;amp;array)[N]) noexcept;                    // (2) C++17
+  constexpr bool
+    empty(const T (&amp;amp;array)[N]) noexcept;   // (2) C++17
   template &amp;lt;class T, std::size_t N&amp;gt;
-  [[nodiscard]] constexpr bool empty(const T (&amp;amp;array)[N]) noexcept;      // (2) C++20
+  [[nodiscard]] constexpr bool
+    empty(const T (&amp;amp;array)[N]) noexcept;   // (2) C++20
   template &amp;lt;class T, std::size_t N&amp;gt;
-  constexpr bool empty(const T (&amp;amp;array)[N]) noexcept;                    // (2) C++26
+  constexpr bool
+    empty(const T (&amp;amp;array)[N]) noexcept;   // (2) C++26
 
   template &amp;lt;class E&amp;gt;
-  constexpr bool empty(initializer_list&amp;lt;E&amp;gt; il) noexcept;                 // (3) C++17
+  constexpr bool
+    empty(initializer_list&amp;lt;E&amp;gt; il) noexcept;   // (3) C++17、C++26で削除
   template &amp;lt;class E&amp;gt;
-  [[nodiscard]] constexpr bool empty(initializer_list&amp;lt;E&amp;gt; il) noexcept;   // (3) C++20
-  template &amp;lt;class E&amp;gt;
-  constexpr bool empty(initializer_list&amp;lt;E&amp;gt; il) noexcept;                 // (3) C++26
+  [[nodiscard]] constexpr bool
+    empty(initializer_list&amp;lt;E&amp;gt; il) noexcept;   // (3) C++20、C++26で削除
 }
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 
+(3)はC++26で削除された。[`std::initializer_list`](/reference/initializer_list/initializer_list.md)に、メンバ関数版の[`empty()`](/reference/initializer_list/initializer_list/empty.md)が追加されたため、このオーバーフローは不要になった。使い方としてはこれまで通りに使用できる。
+
 ## 概要
 コンテナが空かどうかを判定する。
 
+- (3) : C++26で削除。汎用オーバーロード(1)を使用すること。
+
 
 ## 戻り値
 - (1) : `return c.empty();`
 - (2) : `return false;`
-- (3) : `return il.size() == 0;`
+- (3) : `return il.size() == 0;` (C++26で削除)
 
 
 ## 備考
@@ -109,3 +123,4 @@ false
 - [LWG Issue 3009. Including `&amp;lt;string_view&amp;gt;` doesn&amp;#39;t provide `std::size/empty/data`](https://wg21.cmeerw.net/lwg/issue3009)
 - [P2422R1 Remove `nodiscard` annotations from the standard library specification](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2422r1.html)
     - C++26で`[[nodiscard]]`指定が削除された
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>end -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/end.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/end.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/end.md b/reference/iterator/end.md
index 9ce6ab36f..4720c3146 100644
--- a/reference/iterator/end.md
+++ b/reference/iterator/end.md
@@ -7,22 +7,40 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  auto end(C&amp;amp; c) -&amp;gt; decltype(c.end());                 // (1) C++11
-
+  auto
+    end(C&amp;amp; c)
+      -&amp;gt; decltype(c.end());         // (1) C++11
   template &amp;lt;class C&amp;gt;
-  constexpr auto end(C&amp;amp; c) -&amp;gt; decltype(c.end());       // (1) C++17
-
+  constexpr auto
+    end(C&amp;amp; c)
+      -&amp;gt; decltype(c.end());         // (1) C++17
   template &amp;lt;class C&amp;gt;
-  auto end(const C&amp;amp; c) -&amp;gt; decltype(c.end());           // (2) C++11
+  constexpr auto
+    end(C&amp;amp; c)
+      noexcept(noexcept(c.end()))
+      -&amp;gt; decltype(c.end());         // (1) C++26
 
   template &amp;lt;class C&amp;gt;
-  constexpr auto end(const C&amp;amp; c) -&amp;gt; decltype(c.end()); // (2) C++17
+  auto
+    end(const C&amp;amp; c)
+      -&amp;gt; decltype(c.end());         // (2) C++11
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    end(const C&amp;amp; c)
+      -&amp;gt; decltype(c.end());         // (2) C++17
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    end(const C&amp;amp; c)
+      noexcept(noexcept(c.end()))
+      -&amp;gt; decltype(c.end());         // (2) C++26
 
   template &amp;lt;class T, size_t N&amp;gt;
-  T* end(T (&amp;amp;array)[N]);                               // (3) C++11
+  T*
+    end(T (&amp;amp;array)[N]);             // (3) C++11
 
   template &amp;lt;class T, size_t N&amp;gt;
-  constexpr T* end(T (&amp;amp;array)[N]) noexcept;            // (3) C++14
+  constexpr T*
+    end(T (&amp;amp;array)[N]) noexcept;    // (3) C++14
 }
 ```
 
@@ -105,3 +123,4 @@ int main()
 - [N2930 Range-Based For Loop Wording (Without Concepts)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html)
 - [LWG2280 - begin/end for arrays should be constexpr and noexcept](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2280)
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rbegin -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/rbegin.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/rbegin.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/rbegin.md b/reference/iterator/rbegin.md
index 173f6b21a..7acdbca09 100644
--- a/reference/iterator/rbegin.md
+++ b/reference/iterator/rbegin.md
@@ -7,28 +7,47 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  auto rbegin(C&amp;amp; c) -&amp;gt; decltype(c.rbegin());                           // (1) C++14
-
+  auto
+    rbegin(C&amp;amp; c)
+      -&amp;gt; decltype(c.rbegin());         // (1) C++14
   template &amp;lt;class C&amp;gt;
-  constexpr auto rbegin(C&amp;amp; c) -&amp;gt; decltype(c.rbegin());                 // (1) C++17
-
+  constexpr auto
+    rbegin(C&amp;amp; c)
+      -&amp;gt; decltype(c.rbegin());         // (1) C++17
   template &amp;lt;class C&amp;gt;
-  auto rbegin(const C&amp;amp; c) -&amp;gt; decltype(c.rbegin());                     // (2) C++14
+  constexpr auto
+    rbegin(C&amp;amp; c)
+      noexcept(noexcept(c.rbegin()))
+      -&amp;gt; decltype(c.rbegin());         // (1) C++26
 
   template &amp;lt;class C&amp;gt;
-  constexpr auto rbegin(const C&amp;amp; c) -&amp;gt; decltype(c.rbegin());           // (2) C++17
+  auto
+    rbegin(const C&amp;amp; c)
+      -&amp;gt; decltype(c.rbegin());         // (2) C++14
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    rbegin(const C&amp;amp; c)
+      -&amp;gt; decltype(c.rbegin());         // (2) C++17
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    rbegin(const C&amp;amp; c)
+      noexcept(noexcept(c.rbegin()))
+      -&amp;gt; decltype(c.rbegin());         // (2) C++26
 
   template &amp;lt;class T, size_t N&amp;gt;
-  reverse_iterator&amp;lt;T*&amp;gt; rbegin(T (&amp;amp;array)[N]);                          // (3) C++14
-
+  reverse_iterator&amp;lt;T*&amp;gt;
+    rbegin(T (&amp;amp;array)[N]);             // (3) C++14
   template &amp;lt;class T, size_t N&amp;gt;
-  constexpr reverse_iterator&amp;lt;T*&amp;gt; rbegin(T (&amp;amp;array)[N]);                // (3) C++17
+  constexpr reverse_iterator&amp;lt;T*&amp;gt;
+    rbegin(T (&amp;amp;array)[N]) noexcept;    // (3) C++17
 
   template &amp;lt;class E&amp;gt;
-  reverse_iterator&amp;lt;const E*&amp;gt; rbegin(initializer_list&amp;lt;E&amp;gt; il);           // (4) C++14
+  reverse_iterator&amp;lt;const E*&amp;gt;
+    rbegin(initializer_list&amp;lt;E&amp;gt; il);    // (4) C++14
 
   template &amp;lt;class E&amp;gt;
-  constexpr reverse_iterator&amp;lt;const E*&amp;gt; rbegin(initializer_list&amp;lt;E&amp;gt; il); // (4) C++17
+  constexpr reverse_iterator&amp;lt;const E*&amp;gt;
+    rbegin(initializer_list&amp;lt;E&amp;gt; il);    // (4) C++17
 }
 ```
 * reverse_iterator[link reverse_iterator.md]
@@ -40,7 +59,7 @@ namespace std {
 - (1) : コンテナの`rbegin()`メンバ関数で、範囲の末尾を指す、逆イテレータを返す。
 - (2) : コンテナの`rbegin()`メンバ関数で、範囲の末尾を指す、読み取り専用逆イテレータを返す。
 - (3) : 組み込み配列の末尾を指す、逆イテレータを返す。
-- (4) : `initializer_list`オブジェクトの末尾を指す、読み取り専用逆イテレータを返す。
+- (4) : `initializer_list`オブジェクトの末尾を指す、読み取り専用逆イテレータを返す。C++26で削除。
 
 
 ## 戻り値
@@ -122,3 +141,4 @@ int main()
 ## 参照
 - [LWG Issue 2128. Absence of global functions `cbegin`/`cend`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128)
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rend -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/rend.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/rend.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/rend.md b/reference/iterator/rend.md
index e4c664362..e485f0baf 100644
--- a/reference/iterator/rend.md
+++ b/reference/iterator/rend.md
@@ -7,28 +7,47 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  auto rend(C&amp;amp; c) -&amp;gt; decltype(c.rend());                             // (1) C++14
-
+  auto
+   rend(C&amp;amp; c)
+     -&amp;gt; decltype(c.rend());          // (1) C++14
   template &amp;lt;class C&amp;gt;
-  constexpr auto rend(C&amp;amp; c) -&amp;gt; decltype(c.rend());                   // (1) C++17
-
+  constexpr auto
+    rend(C&amp;amp; c)
+      -&amp;gt; decltype(c.rend());         // (1) C++17
   template &amp;lt;class C&amp;gt;
-  auto rend(const C&amp;amp; c) -&amp;gt; decltype(c.rend());                       // (2) C++14
+  constexpr auto
+    rend(C&amp;amp; c)
+      noexcept(noexcept(c.rend()))
+      -&amp;gt; decltype(c.rend());         // (1) C++26
 
   template &amp;lt;class C&amp;gt;
-  constexpr auto rend(const C&amp;amp; c) -&amp;gt; decltype(c.rend());             // (2) C++17
+  auto
+    rend(const C&amp;amp; c)
+      -&amp;gt; decltype(c.rend());         // (2) C++14
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    rend(const C&amp;amp; c)
+      -&amp;gt; decltype(c.rend());         // (2) C++17
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    rend(const C&amp;amp; c)
+      noexcept(noexcept(c.rend()))
+      -&amp;gt; decltype(c.rend());         // (2) C++26
 
   template &amp;lt;class T, size_t N&amp;gt;
-  reverse_iterator&amp;lt;T*&amp;gt; rend(T (&amp;amp;array)[N]);                          // (3) C++14
-
+  reverse_iterator&amp;lt;T*&amp;gt;
+    rend(T (&amp;amp;array)[N]);             // (3) C++14
   template &amp;lt;class T, size_t N&amp;gt;
-  constexpr reverse_iterator&amp;lt;T*&amp;gt; rend(T (&amp;amp;array)[N]);                // (3) C++17
+  constexpr reverse_iterator&amp;lt;T*&amp;gt;
+    rend(T (&amp;amp;array)[N]) noexcept;    // (3) C++17
 
   template &amp;lt;class E&amp;gt;
-  reverse_iterator&amp;lt;const E*&amp;gt; rend(initializer_list&amp;lt;E&amp;gt; il);           // (4) C++14
+  reverse_iterator&amp;lt;const E*&amp;gt;
+    rend(initializer_list&amp;lt;E&amp;gt; il);    // (4) C++14
 
   template &amp;lt;class E&amp;gt;
-  constexpr reverse_iterator&amp;lt;const E*&amp;gt; rend(initializer_list&amp;lt;E&amp;gt; il); // (4) C++17
+  constexpr reverse_iterator&amp;lt;const E*&amp;gt;
+    rend(initializer_list&amp;lt;E&amp;gt; il);    // (4) C++17
 }
 ```
 * reverse_iterator[link reverse_iterator.md]
@@ -40,7 +59,7 @@ namespace std {
 - (1) : コンテナの`rend()`メンバ関数で、範囲の先頭の前を指す、逆イテレータを返す。
 - (2) : コンテナの`rend()`メンバ関数で、範囲の先頭の前を指す、読み取り専用逆イテレータを返す。
 - (3) : 組み込み配列の先頭の前を指す、逆イテレータを返す。
-- (4) : `initializer_list`オブジェクトの先頭の前を指す、読み取り専用逆イテレータを返す。
+- (4) : `initializer_list`オブジェクトの先頭の前を指す、読み取り専用逆イテレータを返す。C++26で削除。
 
 
 ## 戻り値
@@ -122,3 +141,4 @@ int main()
 ## 参照
 - [LWG Issue 2128. Absence of global functions `cbegin`/`cend`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128)
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>size -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/size.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/size.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/size.md b/reference/iterator/size.md
index 21906c4d5..e5eff625b 100644
--- a/reference/iterator/size.md
+++ b/reference/iterator/size.md
@@ -7,10 +7,18 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  constexpr auto size(const C&amp;amp; c) -&amp;gt; decltype(c.size());    // (1)
+  constexpr auto
+    size(const C&amp;amp; c)
+      -&amp;gt; decltype(c.size());            // (1) C++17
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    size(const C&amp;amp; c)
+      noexcept(noexcept(c.size()))
+      -&amp;gt; decltype(c.size());            // (1) C++26
 
   template &amp;lt;class T, std::size_t N&amp;gt;
-  constexpr std::size_t size(const T (&amp;amp;array)[N]) noexcept; // (2)
+  constexpr std::size_t
+    size(const T (&amp;amp;array)[N]) noexcept; // (2) C++17
 }
 ```
 
@@ -101,3 +109,4 @@ int main()
 - [`boost::size()` - Boost Range Library](http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/concept_implementation/semantics/functions.html)
 - [N4280: Non-member `size()` and more (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf)
 - [LWG Issue 3009. Including `&amp;lt;string_view&amp;gt;` doesn&amp;#39;t provide `std::size/empty/data`](https://wg21.cmeerw.net/lwg/issue3009)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ssize -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/iterator/ssize.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/iterator/ssize.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/ssize.md b/reference/iterator/ssize.md
index 47dab83d4..c7d45bfa7 100644
--- a/reference/iterator/ssize.md
+++ b/reference/iterator/ssize.md
@@ -7,11 +7,18 @@
 ```cpp
 namespace std {
   template &amp;lt;class C&amp;gt;
-  constexpr auto ssize(const C&amp;amp; c)
-    -&amp;gt; common_type_t&amp;lt;ptrdiff_t, make_signed_t&amp;lt;decltype(c.size())&amp;gt;&amp;gt;; // (1)
+  constexpr auto
+    ssize(const C&amp;amp; c)
+      -&amp;gt; common_type_t&amp;lt;ptrdiff_t, make_signed_t&amp;lt;decltype(c.size())&amp;gt;&amp;gt;;  // (1) C++20
+  template &amp;lt;class C&amp;gt;
+  constexpr auto
+    ssize(const C&amp;amp; c)
+      noexcept(noexcept(c.size()))
+      -&amp;gt; common_type_t&amp;lt;ptrdiff_t, make_signed_t&amp;lt;decltype(c.size())&amp;gt;&amp;gt;;  // (1) C++26
 
   template &amp;lt;class T, ptrdiff_t N&amp;gt;
-  constexpr ptrdiff_t ssize(const T (&amp;amp;array)[N]) noexcept;          // (2)
+  constexpr ptrdiff_t
+    ssize(const T (&amp;amp;array)[N]) noexcept;                               // (2) C++20
 }
 ```
 * ptrdiff_t[link /reference/cstddef/ptrdiff_t.md]
@@ -75,3 +82,4 @@ int main()
 
 ## 参照
 - [P1227: Signed `ssize()` functions, unsigned `size()` functions (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1227r2.html)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>valarray -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/valarray/valarray.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray.md b/reference/valarray/valarray.md
index c73e7165b..4c7814685 100644
--- a/reference/valarray/valarray.md
+++ b/reference/valarray/valarray.md
@@ -87,6 +87,14 @@ valarray&amp;lt;int&amp;gt; c = a + b;
 | [`operator&amp;gt;&amp;gt;=`](valarray/op_right_shift_assign.md)       | 右シフトの複合代入                       | |
 
 
+### イテレータ
+
+| 名前 | 説明 | 対応バージョン |
+|--------------------------------|--------------------------------------|-------|
+| [`begin`](valarray/begin.md) | 先頭の要素を指すイテレータを取得する | C++26 |
+| [`end`](valarray/end.md)     | 末尾の次を指すイテレータを取得する   | C++26 |
+
+
 ### その他メンバ関数
 
 | 名前 | 説明 | 対応バージョン |
@@ -108,6 +116,8 @@ valarray&amp;lt;int&amp;gt; c = a + b;
 | 名前         | 説明      | 対応バージョン |
 |--------------|-----------|----------------|
 | `value_type` | 要素型`T` | |
+| `iterator` | イテレータ型 (具体的な型は未規定) | C++26 |
+| `const_iterator` | 読み取り専用イテレータ型 (具体的な型は未規定) | C++26 |
 
 
 ## 非メンバ関数
@@ -123,8 +133,8 @@ valarray&amp;lt;int&amp;gt; c = a + b;
 
 | 名前 | 説明 | 対応バージョン |
 |--------------------------------|--------------------------------------|-------|
-| [`begin`](valarray/begin_free.md) | 先頭の要素を指すイテレータを取得する | C++11 |
-| [`end`](valarray/end_free.md)     | 末尾の次を指すイテレータを取得する   | C++11 |
+| [`begin`](valarray/begin_free.md) | 先頭の要素を指すイテレータを取得する | C++11&amp;lt;br/&amp;gt;C++26で削除 |
+| [`end`](valarray/end_free.md)     | 末尾の次を指すイテレータを取得する   | C++11&amp;lt;br/&amp;gt;C++26で削除 |
 
 
 ### 四則演算
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>begin -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/begin.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/valarray/valarray/begin.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/begin.md b/reference/valarray/valarray/begin.md
new file mode 100644
index 000000000..ced1bb49c
--- /dev/null
+++ b/reference/valarray/valarray/begin.md
@@ -0,0 +1,63 @@
+# begin
+* valarray[meta header]
+* std[meta namespace]
+* valarray[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+iterator begin();             // (1) C++26
+const_iterator begin() const; // (2) C++26
+```
+
+## 概要
+先頭の要素を指すイテレータを取得する。
+
+
+## 戻り値
+先頭要素を指すイテレータを返す。
+
+
+## 備考
+- この関数によって返されるイテレータは、[`resize()`](resize.md)メンバ関数が呼び出されると無効になる
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;valarray&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::valarray&amp;lt;int&amp;gt; va = {1, 2, 3};
+
+  std::for_each(va.begin(), va.end(), [](int x) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  });
+}
+```
+* va.begin()[color ff0000]
+* va.end()[link end.md]
+
+### 出力
+```
+1
+2
+3
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>begin (非メンバ関数) -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/begin_free.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/valarray/valarray/begin_free.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/begin_free.md b/reference/valarray/valarray/begin_free.md
index 226d030cd..10ed0f699 100644
--- a/reference/valarray/valarray/begin_free.md
+++ b/reference/valarray/valarray/begin_free.md
@@ -3,19 +3,22 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp26removed[meta cpp]
 
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  unspecified1 begin(valarray&amp;lt;T&amp;gt;&amp;amp; va);       // (1)
+  unspecified1 begin(valarray&amp;lt;T&amp;gt;&amp;amp; va);       // (1) C++11、C++26で削除
 
   template &amp;lt;class T&amp;gt;
-  unspecified2 begin(const valarray&amp;lt;T&amp;gt;&amp;amp; va); // (2)
+  unspecified2 begin(const valarray&amp;lt;T&amp;gt;&amp;amp; va); // (2) C++11、C++26で削除
 }
 ```
 * unspecified1[italic]
 * unspecified2[italic]
 
+この関数はC++26で削除された。代わりにメンバ関数版の[`begin()`](begin.md)および、[`&amp;lt;iterator&amp;gt;`](/reference/iterator.md)ヘッダで定義される[`std::begin()`](/reference/iterator/begin.md)関数を使用すること。
+
 ## 概要
 先頭の要素を指すイテレータを取得する。
 
@@ -86,3 +89,4 @@ int main()
 ## 参照
 - [N2930 Range-Based For Loop Wording (Without Concepts)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html)
 - [LWG2058. valarray and begin/end](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2058)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>end -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/end.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/valarray/valarray/end.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/end.md b/reference/valarray/valarray/end.md
new file mode 100644
index 000000000..0636bd553
--- /dev/null
+++ b/reference/valarray/valarray/end.md
@@ -0,0 +1,63 @@
+# end
+* valarray[meta header]
+* std[meta namespace]
+* valarray[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+iterator end();             // (1) C++26
+const_iterator end() const; // (2) C++26
+```
+
+## 概要
+末尾の次を指すイテレータを取得する。
+
+
+## 戻り値
+末尾の次を指すイテレータを返す。
+
+
+## 備考
+- この関数によって返されるイテレータは、[`resize()`](resize.md)メンバ関数が呼び出されると無効になる
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;valarray&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::valarray&amp;lt;int&amp;gt; va = {1, 2, 3};
+
+  std::for_each(va.begin(), va.end(), [](int x) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  });
+}
+```
+* va.end()[color ff0000]
+* va.begin()[link begin.md]
+
+### 出力
+```
+1
+2
+3
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>end (非メンバ関数) -- C++26対応としてinitializer_list/valarray関連のイテレータの不整合を直す変更を適用 #1564</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/end_free.html"/>
      <id>8c372ac4c311708f8c1439e807595198767defe0:reference/valarray/valarray/end_free.md</id>
      <updated>2026-01-31T13:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/end_free.md b/reference/valarray/valarray/end_free.md
index 61a91a36f..41dc9e129 100644
--- a/reference/valarray/valarray/end_free.md
+++ b/reference/valarray/valarray/end_free.md
@@ -3,19 +3,22 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp26removed[meta cpp]
 
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  unspecified1 end(valarray&amp;lt;T&amp;gt;&amp;amp; va);       // (1)
+  unspecified1 end(valarray&amp;lt;T&amp;gt;&amp;amp; va);       // (1) C++11、C++26で削除
 
   template &amp;lt;class T&amp;gt;
-  unspecified2 end(const valarray&amp;lt;T&amp;gt;&amp;amp; va); // (2)
+  unspecified2 end(const valarray&amp;lt;T&amp;gt;&amp;amp; va); // (2) C++11、C++26で削除
 }
 ```
 * unspecified1[italic]
 * unspecified2[italic]
 
+この関数はC++26で削除された。代わりにメンバ関数版の[`end()`](end.md)および、[`&amp;lt;iterator&amp;gt;`](/reference/iterator.md)ヘッダで定義される[`std::end()`](/reference/iterator/end.md)関数を使用すること。
+
 ## 概要
 末尾の次を指すイテレータを取得する。
 
@@ -86,3 +89,4 @@ int main()
 ## 参照
 - [N2930 Range-Based For Loop Wording (Without Concepts)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html)
 - [LWG2058. valarray and begin/end](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2058)
+- [P3016R6 Resolve inconsistencies in `begin`/`end` for `valarray` and `braced-initializer-list`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stdexcept -- stdexcept : 作成済み例外ページへのリンクを追加 #1549</title>
      <link href="https://cpprefjp.github.io/reference/stdexcept.html"/>
      <id>bf831f72899662db93cb4bed43bf8e834fd8f6f4:reference/stdexcept.md</id>
      <updated>2026-01-29T15:24:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdexcept.md b/reference/stdexcept.md
index 66ffb68de..5d5caccd6 100644
--- a/reference/stdexcept.md
+++ b/reference/stdexcept.md
@@ -28,9 +28,9 @@
 - [`exception`](/reference/exception/exception.md)
 	- [`logic_error`](stdexcept/logic_error.md)
 		- [`domain_error`](stdexcept/domain_error.md)
-		- `invalid_argument`
+		- [`invalid_argument`](stdexcept/invalid_argument.md)
 		- `length_error`
-		- `out_of_range`
+		- [`out_of_range`](stdexcept/out_of_range.md)
 	- `runtime_error`
 		- `range_error`
 		- `overflow_error`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- C++26対応としてpackaged_taskのアロケータ指定コンストラクタを復活 #1513</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/op_constructor.html"/>
      <id>d73f68dac029b1a43cd483ddff03ba6d3f170d98:reference/future/packaged_task/op_constructor.md</id>
      <updated>2026-01-29T13:22:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/op_constructor.md b/reference/future/packaged_task/op_constructor.md
index dc60a0569..3fc3d1d4d 100644
--- a/reference/future/packaged_task/op_constructor.md
+++ b/reference/future/packaged_task/op_constructor.md
@@ -13,7 +13,7 @@ explicit packaged_task(F&amp;amp;&amp;amp; f);                     // (2)
 
 template &amp;lt;class F, class Allocator&amp;gt;
 explicit packaged_task(allocator_arg_t,
-                       const Allocator&amp;amp; a, F&amp;amp;&amp;amp; f); // (3) C++17で削除
+                       const Allocator&amp;amp; a, F&amp;amp;&amp;amp; f); // (3) C++17で削除、C++26で再追加
 
 packaged_task(packaged_task&amp;amp;) = delete;            // (4) C++11
 packaged_task(const packaged_task&amp;amp;) = delete;      // (4) C++14
@@ -117,3 +117,5 @@ int main()
 - [LWG Issue 2921. `packaged_task` and type-erased allocators](https://wg21.cmeerw.net/lwg/issue2921)
     - [`std::function`のコンストラクタ](/reference/functional/function/op_constructor.md)と同様の理由により、アロケータを受け取るコンストラクタを削除
 - [LWG Issue 3039. Unnecessary `decay` in `thread` and `packaged_task`](https://wg21.cmeerw.net/lwg/issue3039)
+- [P3503R3 Make type-erased allocator use in `promise` and `packaged_task` consistent](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r3.html)
+    - C++26でアロケータを受け取るコンストラクタを再追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reset -- C++26対応としてpackaged_taskのアロケータ指定コンストラクタを復活 #1513</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/reset.html"/>
      <id>d73f68dac029b1a43cd483ddff03ba6d3f170d98:reference/future/packaged_task/reset.md</id>
      <updated>2026-01-29T13:22:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/reset.md b/reference/future/packaged_task/reset.md
index 9d1277343..d58567819 100644
--- a/reference/future/packaged_task/reset.md
+++ b/reference/future/packaged_task/reset.md
@@ -16,14 +16,26 @@ void reset();
 
 
 ## 効果
-```cpp
-*this = packaged_task(std::move(f));
-```
-* std::move[link /reference/utility/move.md]
+メンバ変数として保持している、非同期実行する関数オブジェクトを`f`として、
+
+- C++11: あたかも以下のように動作する
+    ```cpp
+    *this = packaged_task(std::move(f));
+    ```
+    * std::move[link /reference/utility/move.md]
 
-によって、新たに共有状態を作成する。古い共有状態は放棄される(詳細は[`operator=`](op_assign.md)を参照)。
+    - この操作によって、新たに共有状態を作成する。古い共有状態は放棄される(詳細は[`operator=`](op_assign.md)を参照)。
 
-`f`はメンバ変数として保持している、非同期実行する関数オブジェクト。
+- C++26: 以下と等価
+    ```cpp
+    if (!valid())
+      throw future_error(future_errc::no_state);
+    *this = packaged_task(allocator_arg, a, std::move(f));
+    ```
+    * valid[link valid.md]
+    * future_error[link ../future_error.md]
+    * allocator_arg[link /reference/memory/allocator_arg_t.md]
+    * std::move[link /reference/utility/move.md]
 
 
 ## 戻り値
@@ -33,8 +45,7 @@ void reset();
 ## 例外
 この関数は、以下の例外を送出する可能性がある：
 
-- [`bad_alloc`](/reference/new/bad_alloc.md) ： 新たな共有状態のアロケートに失敗
-- タスク`f`のムーブコンストラクタが送出するあらゆる例外
+- `package_task`のコンストラクタ、またはタスク`f`のムーブコンストラクタが送出するあらゆる例外
 - [`future_error`](../future_error.md) ： 共有状態を持っていない状態でこの関数を呼び出した場合、[`no_state`](../future_errc.md)をerror conditionにして送出する
 
 
@@ -86,3 +97,5 @@ int main()
 
 
 ## 参照
+- [P3503R3 Make type-erased allocator use in `promise` and `packaged_task` consistent](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r3.html)
+    - C++26でアロケータを受け取るコンストラクタで再構築するよう変更された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>promise -- C++26対応としてpackaged_taskのアロケータ指定コンストラクタを復活 #1513</title>
      <link href="https://cpprefjp.github.io/reference/future/promise.html"/>
      <id>d73f68dac029b1a43cd483ddff03ba6d3f170d98:reference/future/promise.md</id>
      <updated>2026-01-29T13:22:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/promise.md b/reference/future/promise.md
index 3eae319a2..ecee0fb36 100644
--- a/reference/future/promise.md
+++ b/reference/future/promise.md
@@ -66,7 +66,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| [`uses_allocator`](promise/uses_allocator.md) | `promise`による特殊化 |
+| [`uses_allocator`](promise/uses_allocator.md) | `promise`による特殊化 | C++11&amp;lt;br/&amp;gt; C++26で削除 |
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses_allocator -- C++26対応としてpackaged_taskのアロケータ指定コンストラクタを復活 #1513</title>
      <link href="https://cpprefjp.github.io/reference/future/promise/uses_allocator.html"/>
      <id>d73f68dac029b1a43cd483ddff03ba6d3f170d98:reference/future/promise/uses_allocator.md</id>
      <updated>2026-01-29T13:22:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/promise/uses_allocator.md b/reference/future/promise/uses_allocator.md
index 4eed5135b..91fabb609 100644
--- a/reference/future/promise/uses_allocator.md
+++ b/reference/future/promise/uses_allocator.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * class template[meta id-type]
 * cpp11[meta cpp]
+* cpp26removed[meta cpp]
 
 ```cpp
 namespace std {
@@ -13,18 +14,12 @@ namespace std {
 ```
 * true_type[link /reference/type_traits/true_type.md]
 
+この特殊化はC++11で導入され、C++26で削除された。
+
 ## 概要
 `uses_allocator`の、`promise&amp;lt;R&amp;gt;`に対する特殊化。
 
 
-## 例
-```cpp
-```
-
-### 出力
-```
-```
-
 ## バージョン
 ### 言語
 - C++11
@@ -37,3 +32,5 @@ namespace std {
 
 
 ## 参照
+- [P3503R3 Make type-erased allocator use in `promise` and `packaged_task` consistent](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r3.html)
+    - C++26でこの特殊化が削除された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>