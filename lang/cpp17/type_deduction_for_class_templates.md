# ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°æ¨è«–
* cpp17[meta cpp]

## æ¦‚è¦
ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚Œã‚‹å€¤ã«ã‚ˆã£ã¦ã€ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’æ¨è«–ã™ã‚‹ã€‚

```cpp
// std::vectorã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’çœç•¥ã€‚
// åˆæœŸåŒ–æ™‚ã«ä»£å…¥ã•ã‚Œã‚‹åˆæœŸåŒ–åãƒªã‚¹ãƒˆã®è¦ç´ å‹ãŒã€std::vectorã®è¦ç´ å‹ã¨ãªã‚‹
std::vector v = {1, 2, 3}; // å¤‰æ•°vã®å‹ã¯std::vector<int>
```

å˜ç´”ãªã‚±ãƒ¼ã‚¹ã§ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§å—ã‘å–ã‚‹å€¤ã®å‹ãŒã‚¯ãƒ©ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã‚ã‚‹å ´åˆã«ã€ã‚¯ãƒ©ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ãŒæ¨è«–ã•ã‚Œã‚‹ã€‚

```cpp
template <class T>
struct Point {
  T x, y;

  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€ã‚¯ãƒ©ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿Tå‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã¨ã‚‹
  Point(T x_, T y_)
    : x(x_), y(y_) {}
};

int main()
{
  Point p {1.0f, 3.0f}; // å¤‰æ•°pã®å‹ã¯Point<float>ã«æ¨è«–ã•ã‚Œã‚‹
  Point q {1.0, 3.0};   // å¤‰æ•°qã®å‹ã¯Point<double>ã«æ¨è«–ã•ã‚Œã‚‹
}
```

ã‚ˆã‚Šè¤‡é›‘ãªä¾‹ã¨ã—ã¦ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒã‚¯ãƒ©ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã®å€¤ã‚’ç›´æ¥å—ã‘å–ã‚‰ãªã„å ´åˆã¯ã€ã€Œæ¨è«–è£œåŠ© (deduction guide)ã€ã‚’ã‚¯ãƒ©ã‚¹å¤–ã«è¨˜è¿°ã™ã‚‹ã€‚

```cpp example
#include <iostream>
#include <vector>
#include <list>
#include <iterator>

namespace mine {

// std::vectorã‚’ãƒ©ãƒƒãƒ—ã—ãŸå¯å¤‰é•·é…åˆ—ã‚¯ãƒ©ã‚¹
template <class T>
class MyVector {
  std::vector<T> data_;

public:
  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã¯ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿Tã‚’ç›´æ¥ä½¿ç”¨ã›ãšã€
  // ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ç¯„å›²ã§åˆæœŸåŒ–ã™ã‚‹
  template <class InputIterator>
  MyVector(InputIterator first, InputIterator last)
    : data_(first, last) {}

  void print()
  {
    for (const T& x : data_) {
      std::cout << x << std::endl;
    }
  }
};

// æ¨è«–è£œåŠ©å®£è¨€ã€‚ã‚¯ãƒ©ã‚¹ãŒæ‰€å±ã™ã‚‹åå‰ç©ºé–“ã®ã€ã‚¯ãƒ©ã‚¹å¤–ã«è¨˜è¿°ã™ã‚‹ã€‚
// ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®è¦ç´ å‹ã‚’MyVectorã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã€‚
template <class InputIterator>
MyVector(InputIterator, InputIterator)
  -> MyVector<typename std::iterator_traits<InputIterator>::value_type>;

} // namespace mine

int main()
{
  std::list ls = {1, 2, 3};

  // å¤‰æ•°vã®å‹ã¯mine::MyVector<int>ã«æ¨è«–ã•ã‚Œã‚‹
  mine::MyVector v {ls.begin(), ls.end()};

  v.print(); // 1, 2, 3ãŒé †ã«å‡ºåŠ›ã•ã‚Œã‚‹
}
```
* std::iterator_traits[link /reference/iterator/iterator_traits.md]

ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã‹ã‚‰ã€ç›´æ¥ã‚ã‚‹ã„ã¯é–“æ¥çš„ã«ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å¼•æ•°ã‚’æ±‚ã‚ã‚‰ã‚Œãªã„å ´åˆã¯ã€æ¨è«–ã§ããªã„ã€‚


## ä»•æ§˜
- ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã‚¯ãƒ©ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã¨ã‚‹å ´åˆã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ã‹ã‚‰ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’æ¨è«–ã§ãã‚‹
- ã‚¯ãƒ©ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’æ¨è«–ã§ãã‚‹å ´åˆã€ãã®ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰ã¯ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’çœç•¥ã§ãã‚‹ï¼š
    ```cpp
    template <class T>
    struct AnyValue {
      T x;

      // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦
      // ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã®
      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚‹ã€‚
      // ã“ã®çŠ¶æ³ã§ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ã‹ã‚‰ã‚¯ãƒ©ã‚¹ã®
      // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’æ¨è«–ã§ãã‚‹
      AnyValue(T x_) : x(x_) {}
    };

    AnyValue<int> v {3}; // å‹æ¨è«–ã—ãªã„å¾“æ¥ã®æ›¸ãæ–¹
    AnyValue w {3};      // å‹æ¨è«–ã—ã¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’çœç•¥ã€‚wã®å‹ã¯AnyValue<int>
    ```

- ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’çœç•¥ã—ãŸã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆåã¯ã€ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã€‚å‹æ¨è«–ã®çµæœã¨ã—ã¦ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’è£œå®Œã—ãŸå®Œå…¨ãªå‹åã«ç½®ãæ›ãˆã‚‰ã‚Œã‚‹
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹ã‹ã‚‰ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’ç›´æ¥æ¨è«–ã§ããªã„å ´åˆã€ã€Œæ¨è«–è£œåŠ© (deduction guide)ã€ã‚’å®£è¨€ã™ã‚‹ã€‚æ¨è«–è£œåŠ©ã¯ã€ã‚¯ãƒ©ã‚¹å¤–ã®ã‚¯ãƒ©ã‚¹ã¨åŒã˜ã‚¹ã‚³ãƒ¼ãƒ—ã€åŒã˜ã‚¢ã‚¯ã‚»ã‚¹ä¿®é£¾å†…ã«å®£è¨€ã™ã‚‹ã€‚æ§‹æ–‡ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ï¼š
    ```cpp
    ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå(ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆ) -> ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå<ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°>;

    // -> ã®ã†ã—ã‚ã¯ã€æ¨è«–çµæœã¨ã—ã¦ã®å®Œå…¨ãªå‹å
    ```

- æ¨è«–è£œåŠ©å®£è¨€ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°ã‚’æŒã£ã¦ã¯ãªã‚‰ãªã„
- åŒã˜ç¿»è¨³å˜ä½ã«2ã¤ã®æ¨è«–è£œåŠ©ãŒã‚ã‚‹å ´åˆã€ãã‚Œã‚‰ã®æ¨è«–è£œåŠ©ã¯ã€åŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã‚’æŒã£ã¦ã¯ãªã‚‰ãªã„
- æ¨è«–è£œåŠ©ã«ã¯ã€å…ˆé ã«`explicit`ã‚’ä»»æ„ã«ä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚ã—ã‹ã—ã€`noexcept`ã‚„å±æ€§ã¨ã„ã£ãŸä¿®é£¾ã¯ä»˜ã‘ã‚‰ã‚Œãªã„
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ã‚’ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚Œã‚‹å‰ã®çŠ¶æ…‹ (é…åˆ—ã‹ã‚‰ãƒã‚¤ãƒ³ã‚¿ã¸ã®å¤‰æ›ãªã©ãŒè¡Œã‚ã‚Œã‚‹å‰ã®çŠ¶æ…‹) ã§æ¨è«–è£œåŠ©ã«è»¢é€ã—ãŸã¨ã—ã¦æ¨è«–ãŒè¡Œã‚ã‚Œã‚‹ã€‚ãã®ãŸã‚ã€æ¨è«–è£œåŠ©ã¯ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨åŒä¸€ã®ã‚·ã‚°ãƒ‹ãƒãƒ£ã§ã‚ã‚‹å¿…è¦ã¯ãªã„
- ã“ã®æ©Ÿèƒ½ã«ã¨ã‚‚ãªã£ã¦ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã®ã¿ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–æ™‚ã«å±±ã‚«ãƒƒã‚³ã‚’çœç•¥ã§ãã‚‹
    ```cpp
    template <class=int>
    struct X {};

    auto x = X{}; // X<>{}; ã¨æ›¸ãå¿…è¦ãŒãªã„
    ```


## ä¾‹
### æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã®ä½¿ç”¨ä¾‹
```cpp example
#include <vector>
#include <array>
#include <set>
#include <complex>
#include <functional>
#include <memory>
#include <utility>
#include <future>
#include <mutex>

int main()
{
  // åˆæœŸåŒ–åãƒªã‚¹ãƒˆã‹ã‚‰ã‚³ãƒ³ãƒ†ãƒŠã®è¦ç´ å‹ã‚’æ¨è«–
  {
    std::vector v = {1, 2, 3}; // std::vector<int>ã«æ¨è«–ã•ã‚Œã‚‹
    std::array ar = {4, 5, 6}; // std::array<int, 3>ã«æ¨è«–ã•ã‚Œã‚‹
    std::set s = {7, 8, 9};    // std::set<int>ã«æ¨è«–ã•ã‚Œã‚‹
  }

  // è¤‡ç´ æ•°ã®è¦ç´ å‹ã‚’æ¨è«–
  {
    std::complex c {1.0, 2.0};    // std::complex<double>ã«æ¨è«–ã•ã‚Œã‚‹
    std::complex cf {1.0f, 2.0f}; // std::complex<float>ã«æ¨è«–ã•ã‚Œã‚‹
  }

  // é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ãƒ»é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰std::functionã®ã‚·ã‚°ãƒ‹ãƒãƒ£ã‚’æ¨è«–
  {
    // std::function<int(int, double)>ã«æ¨è«–ã•ã‚Œã‚‹
    std::function f = [](int, double) { return 0; };
  }

  // ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã®å‹æ¨è«–
  {
    // std::shared_ptrã¨std::unique_ptrã¯ç”Ÿãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰ã®æ¨è«–ã‚’è¨±å¯ã—ãªã„ã€‚
    // std::shared_ptrã‹ã‚‰std::weak_ptrã¨ãã®é€†ã¯æ¨è«–ã§ãã‚‹
    std::shared_ptr<int> sp {new int(3)};
    std::weak_ptr wp = sp;
    std::shared_ptr locked_sp = wp.lock();
  }

  // std::pairã¨std::tupleã®å‹æ¨è«–
  {
    // std::make_pair()ã‚„std::make_tuple()ã®ã‚ˆã†ãªå˜ç´”ãªç”Ÿæˆé–¢æ•°ãŒä¸è¦ã¨ãªã‚‹ä¾‹
    std::pair p {1, "Hello"};        // std::pair<int, const char*>ã«æ¨è«–ã•ã‚Œã‚‹
    std::tuple t {1, 3.14, "Hello"}; // std::tuple<int, double, const char*>ã«æ¨è«–ã•ã‚Œã‚‹
  }

  // std::lock_guardãŒç®¡ç†ã™ã‚‹ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã®å‹ã‚’æ¨è«–
  {
    std::mutex mut;
    std::lock_guard lk {mut}; // std::lock_guard<std::mutex>ã«æ¨è«–ã•ã‚Œã‚‹
  }

  // promiseã‹ã‚‰å–å¾—ã™ã‚‹futureã§ã€çµæœå‹ã‚’æ¨è«–
  {
    // std::future<int>ã«æ¨è«–ã•ã‚Œã‚‹
    std::promise<int> pro;
    std::future fut = pro.get_future();
  }
}
```
* std::complex[link /reference/complex/complex.md]
* std::function[link /reference/functional/function.md]
* std::weak_ptr[link /reference/memory/weak_ptr.md]
* wp.lock()[link /reference/memory/weak_ptr/lock.md]
* std::tuple[link /reference/tuple/tuple.md]
* std::make_tuple[link /reference/tuple/make_tuple.md]
* std::promise[link /reference/future/promise.md]
* p.get_future()[link /reference/future/promise/get_future.md]
* std::future[link /reference/future/future.md]

#### å‡ºåŠ›
```
```


### ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å‹æ¨è«–ã‚’å›é¿ã™ã‚‹ä¾‹
```cpp
template <class T>
struct X {
  using T_ = T;

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç›´æ¥ä½¿ç”¨ã›ãšã€å‹ã®åˆ¥åã‚’ä»˜ã‘ã¦ã‹ã‚‰ä½¿ç”¨ã™ã‚‹ã€‚
  // ã“ã‚Œã«ã‚ˆã£ã¦ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã•ã›ã‚‰ã‚Œã‚‹
  X(T_) {}
};

int main()
{
//X x{1};      // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ï¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’æ¨è«–ã§ããªã„
  X<int> y{1}; // OK
}
```

#### å‡ºåŠ›
```
```


### ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã®ã¿ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½¿ç”¨ä¾‹
```cpp example
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

int main()
{
  std::vector v = {3, 1, 4};

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ãŒä½¿ç”¨ã•ã‚Œã€std::greater<void>{}ã¨ãªã‚‹ã€‚
  // std::greater<>{}ã®ã‚ˆã†ã«å±±ã‚«ãƒƒã‚³ã‚’æ›¸ãå¿…è¦ãŒãªã„
  std::sort(v.begin(), v.end(), std::greater{});

  for (auto x : v) {
    std::cout << x << std::endl;
  }
}
```
* std::greater[link /reference/functional/greater.md]

#### å‡ºåŠ›
```
4
3
1
```


## ã“ã®æ©Ÿèƒ½ãŒå¿…è¦ã«ãªã£ãŸèƒŒæ™¯ãƒ»çµŒç·¯

ã“ã®æ©Ÿèƒ½ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«å°å…¥ã•ã‚ŒãŸï¼š

- `make_*()`ã®ã‚ˆã†ãªç”Ÿæˆé–¢æ•°ã¯ã€å†—é•·ã§ã€ã‹ã¤æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®éã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®æ§‹ç¯‰æ–¹æ³•ã¨ä¸€è²«æ€§ãŒãªã‹ã£ãŸ
- ç”Ÿæˆé–¢æ•°ã®è¨è¨ˆãŒæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã§ä¸€è²«ã—ã¦ãŠã‚‰ãšã€[`std::make_pair()`](/reference/utility/make_pair.md)ã‚„[`make_tuple()`](/reference/tuple/make_tuple.md)ã¨ã„ã£ãŸ`make_`æ¥é è¾ãŒä»˜ãå ´åˆã‚‚ã‚ã‚Œã°ã€[`std::back_insert_iterator`](/reference/iterator/back_insert_iterator.md)ã«å¯¾ã™ã‚‹[`std::back_inserter()`](/reference/iterator/back_inserter.md)é–¢æ•°ã®ã‚ˆã†ã«ã€`make_`æ¥é è¾ãŒä»˜ã‹ãªã„å ´åˆãŒã‚ã£ãŸã€‚ãã®ãŸã‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ç”Ÿæˆé–¢æ•°ã®ç´°ã‹ãªé•ã„ã‚’ãƒ‰ã‚ãƒ¥ãƒ¡ãƒ³ãƒˆã§èª¿ã¹ãªãŒã‚‰ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸ
- é–¢æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã¯å¼•æ•°ã®å‹ã‹ã‚‰ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’æ¨è«–ã§ãã‚‹ã«ã‚‚é–¢ã‚ã‚‰ãšã€ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã¯`pair<int, double>(2, 4.5)`ã®`<int, double>`ã®ã‚ˆã†ã«å†—é•·ãªæŒ‡å®šã‚’ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸ
- ç”Ÿæˆé–¢æ•°ã¯ã€å˜ã«å¼•æ•°ã®å‹ã‚’æ¨è«–ã™ã‚‹ã ã‘ã§ã¯ãªã„å ´åˆãŒã‚ã£ãŸã€‚ä¾‹ã¨ã—ã¦ã€[`std::make_pair()`](/reference/utility/make_pair.md)ã‚„[`make_tuple()`](/reference/tuple/make_tuple.md)ã¨ã„ã£ãŸé–¢æ•°ã¯ã€å‹ãŒ[`std::reference_wrapper<T>`](/reference/functional/reference_wrapper.md)ã§ã‚ã£ãŸå ´åˆã«ã€ãã‚Œã‚’`T&`ã«å±•é–‹ã™ã‚‹æ©Ÿèƒ½ãŒã‚ã‚‹ã€‚å˜ã«å¼•æ•°ã®å‹ã‚’æ¨è«–ã™ã‚‹ã ã‘ã®ç”Ÿæˆé–¢æ•°ãªã®ã‹ã€ã‚ˆã‚Šè¤‡é›‘ãªã“ã¨ã‚’ã™ã‚‹ç”Ÿæˆé–¢æ•°ãªã®ã‹ã‚’ãƒ‰ã‚ãƒ¥ãƒ¡ãƒ³ãƒˆã§èª¿æŸ»ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãã†ã—ãªã„å ´åˆã«äºˆæœŸã›ã¬ãƒã‚°ãŒç™ºç”Ÿã™ã‚‹ã“ã¨ãŒã‚ã£ãŸ
- ç”Ÿæˆé–¢æ•°ã‚’æŒãŸãªã„å ´åˆã€ãŸã¨ãˆã°ãƒ©ãƒ ãƒ€å¼ã‚’ä½¿ç”¨ã™ã‚‹éš›ã«ã€ãã®å‹ã‚’è¨˜è¿°ã§ããªã„å•é¡ŒãŒã‚ã£ãŸ
- [`std::lock_guard`](/reference/mutex/lock_guard.md)ã®ã‚ˆã†ã«ã‚³ãƒ”ãƒ¼ã‚‚ãƒ ãƒ¼ãƒ–ã‚‚ã§ããªã„å‹ã¯ã€ç”Ÿæˆé–¢æ•°ã‚’ä½œã‚‹ãŸã‚ã«ã€Œ[ã‚³ãƒ”ãƒ¼çœç•¥](guaranteed_copy_elision.md)ã€ã®ã‚ˆã†ãªé›£è§£ãªæ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸ
- å¾ªç’°çš„ãªè¤‡é›‘ã• (Cyclomatic complexity) ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã«å¤§ããªé–¢æ•°ã‚’ã‚¯ãƒ©ã‚¹ã§ç½®ãæ›ãˆã‚‹ä¾¿åˆ©ãªæ‰‹æ³•ãŒã€é–¢æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã¯ä½¿ç”¨ã§ããªã‹ã£ãŸ


## é–¢é€£é …ç›®
- [`std::pair`ã®æ¨è«–è£œåŠ©](/reference/utility/pair/op_deduction_guide.md)
- [`std::tuple`ã®æ¨è«–è£œåŠ©](/reference/tuple/tuple/op_deduction_guide.md)
    - `std::pair`ã¨`std::tuple`ã®æ¨è«–è£œåŠ©ã®ä¾‹ã‹ã‚‰ã¯ã€[`std::make_pair()`](/reference/utility/make_pair.md)ã®ã‚ˆã†ãªç”Ÿæˆé–¢æ•°ã®å¿…è¦æ€§ãŒè–„ããªã‚‹ã“ã¨ã¨ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã®ç”Ÿæˆé–¢æ•°ã¨æ¨è«–è£œåŠ©ã§ã€å°ã•ãªæ©Ÿèƒ½çš„å·®ç•°ãŒã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹
- [`std::shared_ptr`ã®æ¨è«–è£œåŠ©](/reference/memory/shared_ptr/op_deduction_guide.md)
    - `std::shared_ptr`ã¯ã€ç”Ÿãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰ã®æ¨è«–ã‚’è¨±å¯ã—ãªã„ã€‚`std::shared_ptr`ã«ã¯å˜ä¸€è¦ç´ ç‰ˆã¨é…åˆ—ç‰ˆãŒã‚ã‚‹ãŒã€ç”Ÿãƒã‚¤ãƒ³ã‚¿ã®å€¤ã¨å‹ã‹ã‚‰ã¯ã€ã©ã¡ã‚‰ã«æŒ¯ã‚Šåˆ†ã‘ã‚‹ã¹ãã‹ãŒå®šã¾ã‚‰ãªã„ãŸã‚ã§ã‚ã‚‹
- [`std::array`ã®æ¨è«–è£œåŠ©](/reference/array/array/op_deduction_guide.md)
    - `std::array`ã®æ¨è«–è£œåŠ©ã‹ã‚‰ã¯ã€éè‡ªæ˜ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’æŒãŸãªã„ã‚¯ãƒ©ã‚¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã‚ã£ã¦ã‚‚ã€æ¨è«–è£œåŠ©ã‚’å®šç¾©ã§ãã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚ãŸã ã—ã€é…åˆ—ã®è¦ç´ å‹ã‚’æ¨è«–ã™ã‚‹ãŸã‚ã«ã¯ã€æ¨è«–ã—ãªã„å ´åˆã¨ã¯é•ã£ãŸåˆ¶é™ãŒå¿…è¦ã¨ãªã‚‹


## å‚ç…§
- [P0091R3 Template argument deduction for class templates (Rev. 6)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html)
- [P0620R0 Drafting for class template argument deduction issues](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0620r0.html)
- [LWG Issue 2981. Remove redundant deduction guides from standard library](https://wg21.cmeerw.net/lwg/issue2981)
- [P0702R1 Language support for Constructor Template Argument Deduction](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0702r1.html)
- [Class Template Argument Deduction - A New Abstraction - Zhihao Yuan - CppCon 2017](https://github.com/CppCon/CppCon2017/raw/master/Presentations/Class%20Template%20Argument%20Deduction%20-%20A%20New%20Abstraction/Class%20Template%20Argument%20Deduction%20-%20A%20New%20Abstraction%20-%20Zhihao%20Yuan%20-%20CppCon%202017.pdf)
