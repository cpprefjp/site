# char16_tとchar32_tの文字・文字列リテラルを、文字コードUTF-16/32に規定 [P1041R4]
* cpp20[meta cpp]

## 概要
C++11で追加された文字型[`char16_t`と`char32_t`](/lang/cpp11/char16_32.md)の文字・文字列リテラルの文字コード、C++20からはUTF-16とUTF-32であることが規定される。

これまでは、以下のような仕様であった：

- `<uchar>`ヘッダでマクロ`__STDC_UTF_16__`が定義される場合、`char16_t`型の値はUTF-16の妥当なコードポイントを持つ。そうでない場合、`char16_t`型の値は実装定義の文字コードとなる。
- `<uchar>`ヘッダでマクロ`__STDC_UTF_32__`が定義される場合、`char32_t`型の値はUTF-32の妥当なコードポイントを持つ。そうでない場合、`char32_t`型の値は実装定義の文字コードとなる。

C++20では、無条件にUTF-16とUTF-32であることが規定される。

なお、`u8`プレフィックスをつけた文字・文字列リテラルは、UTF-8であることがこれまでに規定されていた。


## この機能が必要になった背景・経緯
これまで、`<uchar>`ヘッダのマクロ`__STDC_UTF_16__`と`__STDC_UTF_32__`が定義されている場合にのみ、`char16_t`と`char32_t`はUTF-16/UTF-32エンコーディングであると規定されていた。

しかし、これらが定義されなかった場合にコンパイラがほかのエンコーディングを選択することが疑わしかった。また、`char16_t`の仕様として「サロゲートペア」が含まれているが、その概念をもつ他のよく知られた文字コードはない。単一の文字を32ビットで表現する他のよく知られた文字コードもない。

実際にはすべての実装でこれらの文字・文字列リテラルはUTF-16とUTF-32にエンコーディングされるため、要件を示すだけではなく、より明確にするために、`char16_t`と`char32_t`の文字・文字列リテラルがUTF-16とUTF-32文字コードであることを規定する。


## 関連項目
- [C++11 `char16_t`と`char32_t`](/lang/cpp11/char16_32.md)
- [C++11 UTF-8文字列リテラル](/lang/cpp11/utf8_string_literals.md)
- [C++17 UTF-8文字リテラル](/lang/cpp17/utf8_character_literals.md)


## 参照
- [P1041R4 Make `char16_t`/`char32_t` string literals be UTF-16/32](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1041r4.html)
