# launder
* new[meta header]
* function template[meta id-type]
* std[meta namespace]
* cpp17[meta cpp]

```cpp
namespace std {
  template <class T>
    constexpr T* launder(T* p) noexcept; // C++17

  template<class T>
    [[nodiscard]] constexpr T* launder(T* p) noexcept; // C++20
}
```


## æ¦‚è¦
`placement new`æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ã€å‚ç…§å‹ã‚„`const`ãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒã‚’å«ã‚€æ§‹é€ ä½“/ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†æ§‹ç¯‰ã™ã‚‹ã‚±ãƒ¼ã‚¹ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿå˜æœŸé–“(lifetime)ã«åŸºã¥ã„ãŸæœ€é©åŒ–ã®æŠ‘æ¢ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ä¼ãˆã‚‹é–¢æ•°ã€‚
é©åˆ‡ã«`std::launder()`ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€ãƒã‚¤ãƒ³ã‚¿å€¤ã®ç›´æ¥åˆ©ç”¨ãŒæœªå®šç¾©å‹•ä½œã¨ãªã£ã¦ã—ã¾ã†æ–‡è„ˆã«ãŠã„ã¦ã€å‚ç…§å‹ã‚„`const`ãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒã¸ã®å®‰å…¨ãªã‚¢ã‚¯ã‚»ã‚¹ãŒå¯èƒ½ã¨ãªã‚‹ã€‚


## è¦ä»¶
- ãƒã‚¤ãƒ³ã‚¿ã®å¼•æ•°`p`ã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã®1ãƒã‚¤ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ A ã‚’è¡¨ã™ã€‚
- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ X ã¯ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ A ã«ã‚ã‚‹ã€‚
- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ X ã¯ã€ç”Ÿå˜æœŸé–“(lifetime)å†…ã«ã‚ã‚‹ã€‚
- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ X ã®å‹ãŒ T ã«é¡ä¼¼(similar)ã—ã¦ã„ã‚‹ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ X ã®å‹ã¨ T ãã‚Œãã‚Œã§ã€å…¨ã¦ã®ãƒ¬ãƒ™ãƒ«ã®cvä¿®é£¾ã‚’é™¤å»ã—ãŸå‹ãŒç‰ã—ã„ã€‚ï¼ˆä¾‹: `const int * const *`ã¨`int**`ã¯é¡ä¼¼ã—ãŸå‹ï¼‰
- çµæœã‚’é€šã—ã¦åˆ°é”å¯èƒ½ã§ã‚ã‚‹ã§ã‚ã‚ã†è¨˜æ†¶åŸŸã®ã™ã¹ã¦ã®ãƒã‚¤ãƒˆã¯`p`ã‚’é€šã—ã¦åˆ°é”å¯èƒ½ã§ã‚ã‚‹ã€‚

æ³¨ï¼šã€Œåˆ°é”å¯èƒ½ã€ã«ã¤ã„ã¦ã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®1ãƒã‚¤ãƒˆã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆYãŒYã«ã‚ˆã£ã¦å æœ‰ã•ã‚Œã¦ã„ã‚‹ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å†…ã«ã‚ã‚‹å ´åˆã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆYã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿å€¤ã€YãŒé…åˆ—è¦ç´ ã®å ´åˆã¯ç›´æ¥å›²ã‚€é…åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»‹ã—ã¦åˆ°é”å¯èƒ½ã§ã‚ã‚‹ã€‚


## æˆ»ã‚Šå€¤
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ X ã‚’æŒ‡ã™ `T*` å‹ã®å€¤ã€‚


## å‚™è€ƒ
ã“ã®é–¢æ•°ã®å‘¼ã³å‡ºã—ã¯ã€ãã®å¼•æ•°ã®å€¤ãŒã‚³ã‚¢å®šæ•°å¼ã§ä½¿ç”¨ã•ã‚Œã‚‹å ´åˆã¯ã„ã¤ã§ã‚‚ã‚³ã‚¢å®šæ•°å¼ã§ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚ã¾ãŸã€T ãŒé–¢æ•°å‹ ãªã„ã— ï¼ˆcvä¿®é£¾ã•ã‚ŒãŸï¼‰void ã®å ´åˆã€ãƒ—ãƒã‚°ãƒ©ãƒ ã¯ä¸é©æ ¼ã§ã‚ã‚‹ã€‚ 

ä¸€èˆ¬ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å˜ç¶šæœŸé–“ãŒçµ‚äº†ã—ãŸå¾Œã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå æœ‰ã—ã¦ã„ãŸã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒå†åˆ©ç”¨ã¾ãŸã¯è§£æ”¾ã•ã‚Œã‚‹å‰ã«å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå æœ‰ã—ã¦ã„ãŸè¨˜æ†¶åŸŸã«æ–°è¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç™»éŒ²ã•ã‚ŒãŸå ´åˆï¼ˆ`placement new`æ§‹æ–‡ã‚’ä½¿ã£ãŸéš›ï¼‰ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™å‚ç…§ã¾ãŸã¯å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ã¯è‡ªå‹•çš„ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã™ã‚‹ã€‚æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æœ‰åŠ¹æœŸé–“ãŒé–‹å§‹ã•ã‚Œã‚‹ã¨ã€æ¬¡ã®å ´åˆã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ“ä½œã§ãã‚‹ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯æœªå®šç¾©å‹•ä½œã‚’å¼•ãèµ·ã“ã™ã€‚

- æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”¨ã®è¨˜æ†¶åŸŸã¯ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå ã‚ã¦ã„ãŸè¨˜æ†¶åŸŸã‚’æ£ç¢ºã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã™ã‚‹ã€‚
- æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜å‹ã§ã‚ã‚‹ï¼ˆæœ€ä¸Šä½ã® cv ä¿®é£¾åã¯ç„¡è¦–ã•ã‚Œã‚‹ï¼‰ã€‚
- å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ãŒ`const`ä¿®é£¾ã§ã¯ãªãã€ã‚¯ãƒ©ã‚¹å‹ã®å ´åˆã¯ã€å‹ãŒ`const`ä¿®é£¾ã¾ãŸã¯å‚ç…§å‹ã®éé™çš„ãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒã‚’å«ã¾ãªã„ã€‚
- å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã€æ½œåœ¨çš„ã«é‡è¤‡ã™ã‚‹ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(potentially-overlapping subobject)ã§ã¯ãªã„ã€‚

æ³¨ï¼šã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹éstaticãƒ¡ãƒ³ãƒå¤‰æ•°ã€ åŸºåº•ã‚¯ãƒ©ã‚¹åŠã³åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¾ãŸã¯é…åˆ—è¦ç´ ã€ã®ãã‚Œãã‚Œã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã“ã¨ã§ã‚ã‚‹ã€‚

æ³¨ï¼šæ½œåœ¨çš„ã«é‡è¤‡ã™ã‚‹ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(potentially-overlapping subobject)ã¨ã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¾ãŸã¯ no_unique_address å±æ€§(C++20)ã§å®£è¨€ã•ã‚ŒãŸéé™çš„ãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã€‚

æ³¨ï¼šåŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã€ä»¥ä¸‹ã®ä¾‹ã§ã¯ã‚¯ãƒ©ã‚¹`Derived2`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¯ãƒ©ã‚¹`Derived`ã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆ`b`åŠã³`Base`ï¼‰ã‚’æŒã¡ã€ãã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¯ãƒ©ã‚¹`Base`ã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆ`a, b, c`ï¼‰ã‚’æŒã¤ã€‚

```cpp
struct Base {
  int a, b, c;
};

struct Derived : Base {
  int b;
};

struct Derived2 : Derived {
  int c;
};
```

ä»¥ä¸‹ã¯ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ“ä½œã§ãã‚‹å ´åˆã®ä¾‹ã§ã‚ã‚‹ã€‚

```cpp
struct C {
  int i;
  void f();
  const C& operator=( const C& );
};

const C& C::operator=( const C& other) {
  if ( this != &other ) {
    this->~C();                 // *this ã®ç”Ÿå˜æœŸé–“(lifetime)ã®çµ‚äº†
    new (this) C(other);        // Cå‹ã®æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ
    f();                        // well-defined
  }
  return *this;
}

C c1;
C c2;
c1 = c2;                        // well-defined
c1.f();                         // well-defined; c1ã¯Cå‹ã®æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¦ã„ã¾ã™
```

ä¸Šè¨˜ã®æ¡ä»¶ãŒæº€ãŸã•ã‚Œãªã„å ´åˆã§ã‚‚ã€ãƒã‚¤ãƒ³ã‚¿å€¤ã«å¯¾ã—ã¦`std::launder`é–¢æ•°ã‚’é€šã™ã“ã¨ã«ã‚ˆã£ã¦ã€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã—ã¦å®‰å…¨ã«æ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚

ã¤ã¾ã‚Šã€`placement new`ä½¿ç”¨æ™‚ã¯ã€`std::launder`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æœªå®šç¾©å‹•ä½œã‚’é¿ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚


## ä¾‹
```cpp example
#include <new>

int main()
{
  struct X { const int n; };
  X *p = new X{3};
  const int a = p->n;
  new (p) X{5};                       // X::nãŒconstã§ã‚ã‚‹ãŸã‚ã€pã¯æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã•ãªã„
  const int b = p->n;                 // æœªå®šç¾©å‹•ä½œ
  const int c = std::launder(p)->n;   // OK
}
```
* launder[color ff0000]

### å‡ºåŠ›
```
```

ãƒ¡ãƒ³ãƒã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã€æ¬¡ã«ç¤ºã—ãŸã€‚ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å‚ç…§ãƒ¡ãƒ³ãƒã¾ãŸã¯`const`ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå«ã¾ã‚Œã‚‹å ´åˆã€å…ƒã®ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ã‚’ä½¿ç”¨ã—ã¦æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«ã¯ã€`std::launder`ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```cpp
struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f;                            // OK, u ã®æ–°ã—ã„ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
  X *p = new (&u.x) X {2};              // OK, u ã®æ–°ã—ã„ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
  assert(p->n == 2);                    // OK
  assert(*std::launder(&u.x.n) == 2);   // OK
  assert(u.x.n == 2);                   // æœªå®šç¾©å‹•ä½œ, u.xã¯ æ–°ã—ã„ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãªã„
}
```
* launder[color ff0000]


## ãƒãƒ¼ã‚¸ãƒ§ãƒ³
### è¨€èª
- C++17


### å‡¦ç†ç³»
- [Clang](/implementation.md#clang): 6.0.0
- [GCC](/implementation.md#gcc): 7.1.0
- [ICC](/implementation.md#icc): ??
- [Visual C++](/implementation.md#visual_cpp): 2017 update 7


## é–¢é€£é …ç›®
- [å‚ç…§ãƒ¡ãƒ³ãƒã‚’ã‚‚ã¤ã‚¯ãƒ©ã‚¹ã®ç½®ãæ›ãˆ](/lang/cpp17/replacement_of_class_objects_containing_reference_members.md)


## å‚ç…§
- [P0137R1 Core Issue 1776: Replacement of class objects containing reference members](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html)
- [std::launderé–¢æ•° - yohhoyã®æ—¥è¨˜](http://d.hatena.ne.jp/yohhoy/20170817/p1)
- [std::launder - cppreference.com](https://ja.cppreference.com/w/cpp/utility/launder)
- [Lifetime - cppreference.com](https://en.cppreference.com/w/cpp/language/lifetime)
